---
title: "Math Crossword Generator - Math Fun for Kids!"
custom_css: |
    .crossword-container {
        background: #f7fafc;
        border-radius: 15px;
        padding: 30px;
        margin-bottom: 30px;
        border: 3px dashed #cbd5e0;
    }

    .crossword-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 30px;
        align-items: center;
        justify-content: center;
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
        background: white;
        padding: 15px 20px;
        border-radius: 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .control-group label {
        font-weight: bold;
        color: #4a5568;
        margin: 0;
    }

    .control-group input[type="range"] {
        width: 120px;
    }

    .control-group output {
        min-width: 30px;
        text-align: center;
        background: #e2e8f0;
        padding: 5px 10px;
        border-radius: 8px;
        font-weight: bold;
    }

    .checkbox-control {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .checkbox-control input[type="checkbox"] {
        transform: scale(1.3);
    }

    #grid {
        display: block;
        margin: 20px auto;
        border-radius: 10px;
        background: white;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .crossword-status {
        text-align: center;
        margin-top: 20px;
        padding: 15px;
        background: #e6fffa;
        border: 2px solid #81e6d9;
        border-radius: 10px;
        color: #234e52;
        font-weight: bold;
    }

    /* Print grid styles */
    .print-grid {
        position: relative;
        margin: 0 auto;
        font-family: Arial, sans-serif;
    }

    .print-cell {
        position: absolute;
        width: 40px;
        height: 40px;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        box-sizing: border-box;

        /* Only add borders on specific sides to avoid doubling */
        border-top: 1px solid black;
        border-left: 1px solid black;
    }

    /* Add right border only to rightmost cells */
    .print-cell.border-right {
        border-right: 1px solid black;
    }

    /* Add bottom border only to bottom cells */
    .print-cell.border-bottom {
        border-bottom: 1px solid black;
    }

    /* Colorful screen styles */
    .print-cell.screen-view {
        border-top-color: #666;
        border-left-color: #666;
        transition: all 0.2s ease;
    }

    .print-cell.screen-view.border-right {
        border-right-color: #666;
    }

    .print-cell.screen-view.border-bottom {
        border-bottom-color: #666;
    }

    .print-cell.screen-view:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    /* Operator colors - soft pastels */
    .print-cell.op-add {
        background: #e8f5e8;
        color: #4a7c59;
    }
    .print-cell.op-sub {
        background: #fff3e0;
        color: #8d4004;
    }
    .print-cell.op-mul {
        background: #f3e5f5;
        color: #6a1b9a;
    }
    .print-cell.op-div {
        background: #e3f2fd;
        color: #1565c0;
    }
    .print-cell.op-eq {
        background: #fce4ec;
        color: #ad1457;
    }

    /* Number cell alternating colors */
    .print-cell.num-even {
        background: #f8f9fa;
        color: #495057;
    }
    .print-cell.num-odd {
        background: #f1f8e9;
        color: #2e7d32;
    }

    /* Given number highlight */
    .print-cell.given {
        background: #fff8e1;
        color: #f57c00;
        font-weight: 900;
    }

    @media print {
        /* Hide everything except the print grid */
        .header { display: none !important; }
        .crossword-controls { display: none !important; }
        .crossword-status { display: none !important; }
        .footer { display: none !important; }
        #grid { display: none !important; }

        /* Hide screen version and show print version */
        #screenGrid { display: none !important; }
        #printGrid {
            display: block !important;
            margin: 0 auto !important;
            padding: 20px !important;
        }

        /* Simple color printing approach */
        body {
            -webkit-print-color-adjust: exact;
        }

        /* Clean body and container */
        body {
            background: white !important;
            margin: 0 !important;
            padding: 0 !important;
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
        }

        .container {
            background: white !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            padding: 10mm !important;
            margin: 0 !important;
            min-height: auto !important;
        }

        .crossword-container {
            background: white !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            box-shadow: none !important;
            border-radius: 0 !important;
        }

        /* Print grid styles */
        .print-grid {
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
        }

        .print-cell {
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
            border: 2px solid black !important;
            background: white !important;
        }

        /* Page setup - dynamic orientation with minimal margins */
        @page {
            /* Add ~5% extra margin to ensure single-page fit */
            margin: 12mm 12mm 15mm 12mm; /* top right bottom left */
        }

        /* Specific orientation rules */
        @page :first {
            size: A4 portrait;
        }

        @media print and (orientation: landscape) {
            @page {
                size: A4 landscape;
                /* Slightly larger bottom margin for printers */
                margin: 12mm 12mm 16mm 12mm;
            }
        }
    }

    @media (max-width: 768px) {
        .crossword-controls {
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            width: 100%;
            justify-content: space-between;
        }
    }
---
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-btn">‚Üê Back Home</a>
            <h1>üß© Math Crossword Generator</h1>
        </div>

        <div class="crossword-container">
            <div class="crossword-controls">
                <button id="gen" class="btn">Generate New Puzzle</button>
                <button id="printColor" class="btn secondary">Print</button>

                <div class="control-group">
                    <label>Number of equations:</label>
                    <input id="eqSlider" type="range" min="3" max="30" step="1">
                    <output id="eqOut"></output>
                </div>

                <div class="control-group">
                    <label>Difficulty Level:</label>
                    <select id="difficultySelect">
                        <option value="easy">Easy (More clues)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="hard">Hard (Fewer clues)</option>
                        <option value="expert">Expert (Minimal clues)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Number Range:</label>
                    <select id="rangePreset">
                        <option value="0-10">0-10</option>
                        <option value="0-20" selected>0-20</option>
                        <option value="0-50">0-50</option>
                        <option value="0-100">0-100</option>
                    </select>
                </div>
                

                <div class="control-group">
                    <label>Operations:</label>
                    <div class="checkbox-group">
                        <label><input id="opAdd" type="checkbox" checked> + Addition</label>
                        <label><input id="opSub" type="checkbox" checked> - Subtraction</label>
                        <label><input id="opMul" type="checkbox" checked> √ó Multiplication</label>
                        <label><input id="opDiv" type="checkbox" checked> √∑ Division</label>
                    </div>
                </div>

                <div class="control-group checkbox-control">
                    <label><input id="ans" type="checkbox"> Show Answers</label>
                </div>
            </div>

            <svg id="grid" xmlns="http://www.w3.org/2000/svg" style="display: none;"></svg>

            <!-- Colorful screen version -->
            <div id="screenGrid"></div>

            <!-- Hidden print version using HTML table -->
            <div id="printGrid" style="display: none;"></div>

            <div id="stat" class="crossword-status">Click "Generate New Puzzle" to create a math crossword!</div>
        </div>
    </div>

<script>
/* Strict, intersecting math crossword
   - Token sequence per strip: [NUM][OP][NUM][=][NUM]
   - Each number is a single cell with value 1‚Äì99
   - Exact equation count and exact givens
   - After every placement, newly completed segments must be valid equations
   - No segment may exceed length 5
   - Final board fully validated before draw
   - Values for sliders persist via cookies
*/

const ROWS=24, COLS=24;
const MAX_TRIES=25000;        // stronger search
const REGEN_ATTEMPTS=250;

const svg=document.getElementById('grid'), ans=document.getElementById('ans');
const eqSlider=document.getElementById('eqSlider'), eqOut=document.getElementById('eqOut');
const difficultySelect=document.getElementById('difficultySelect');
const rangePreset=document.getElementById('rangePreset');
const opAdd=document.getElementById('opAdd'), opSub=document.getElementById('opSub');
const opMul=document.getElementById('opMul'), opDiv=document.getElementById('opDiv');
const stat=document.getElementById('stat');

const R=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const pick=a=>a[Math.floor(Math.random()*a.length)];
const inside=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

function setCookie(name,value,days=365){
  const d=new Date(); d.setTime(d.getTime()+days*24*60*60*1000);
  document.cookie=`${name}=${encodeURIComponent(value)};expires=${d.toUTCString()};path=/;SameSite=Lax`;
}
function getCookie(name){
  const m=document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(name+'='));
  return m?decodeURIComponent(m.split('=')[1]):null;
}
function syncFromCookies(){
  const eqC=getCookie('mx_eq'), diffC=getCookie('mx_diff');
  const rangeC=getCookie('mx_range');
  const opsC=getCookie('mx_ops');

  eqSlider.value = clamp(parseInt(eqC)||30,3,30);    // Start with 30 equations
  difficultySelect.value = diffC || 'medium';       // Start with medium difficulty
  if(rangeC){
    rangePreset.value = rangeC;
  } else {
    rangePreset.value = '0-20';
  }
  // no custom range UI
  eqOut.textContent = eqSlider.value;

  // Restore operation settings
  const ops = opsC ? JSON.parse(opsC) : {add: true, sub: true, mul: true, div: true};
  opAdd.checked = ops.add !== false;
  opSub.checked = ops.sub !== false;
  opMul.checked = ops.mul !== false;
  opDiv.checked = ops.div !== false;
}

function empty(){return Array.from({length:ROWS},()=>Array(COLS).fill(null))}

function seq(e){return[
  {k:'num',ch:String(e.A)},
  {k:'op', ch:e.op},
  {k:'num',ch:String(e.B)},
  {k:'eq', ch:'='},
  {k:'num',ch:String(e.C)}
];}

function segment(g, r, c, dr, dc){
  // walk to start
  while(inside(r-dr,c-dc) && g[r-dr][c-dc]){ r-=dr; c-=dc; }
  const cells=[];
  let i=0;
  while(inside(r+dr*i,c+dc*i) && g[r+dr*i][c+dc*i]){
    cells.push({r:r+dr*i,c:c+dc*i,cell:g[r+dr*i][c+dc*i]}); i++;
  }
  return cells;
}
function evalOk(a,op,b,c){
  a=+a; b=+b; c=+c;
  if(op==='+') return a+b===c;
  if(op==='-') return a-b===c;
  if(op==='√ó') return a*b===c;
  if(op==='√∑') return b!==0 && a/b===c;
  return false;
}
function validStrip(cells){
  if(cells.length!==5) return false;
  const ks=cells.map(x=>x.cell.k);
  if(ks.join(',')!=='num,op,num,eq,num') return false;
  return evalOk(cells[0].cell.ch,cells[1].cell.ch,cells[2].cell.ch,cells[4].cell.ch);
}

// placement rules: token-by-token match, and no segment > 5, and any completed segment must be valid
function canPlace(g,r,c,dr,dc,s,needIntersect){
  let inter=0;
  const touched=[];
  for(let i=0;i<s.length;i++){
    const rr=r+dr*i, cc=c+dc*i; if(!inside(rr,cc)) return false;
    const cell=g[rr][cc];
    if(cell){
      if(cell.k!==s[i].k || cell.ch!==s[i].ch) return false;
      inter++;
    }
    touched.push([rr,cc]);
  }
  if(needIntersect && inter===0) return false;

  // local validation: for each touched cell, check both directions
  for(const [tr,tc] of touched){
    for(const [xr,xc] of [[0,1],[1,0]]){
      const seg=segment(g, tr, tc, xr, xc);
      // simulate new token where empty
      const idx=seg.findIndex(p=>p.r===tr&&p.c===tc);
      if(idx===-1){
        // tc,tr currently empty in seg view; build a transient segment including new token
        const tmp=segmentWithHypo(g,tr,tc,xr,xc);
        if(tmp.length>5) return false;
        if(tmp.length===5 && !validStrip(tmp)) return false;
      }else{
        if(seg.length>5) return false;
        if(seg.length===5 && !validStrip(seg)) return false;
      }
    }
  }
  return true;
}
function segmentWithHypo(g, r, c, dr, dc){
  // build segment including hypothetical filled cell at r,c (we only call this one when we know r,c is empty)
  // walk back
  let sr=r, sc=c;
  while(inside(sr-dr,sc-dc) && g[sr-dr][sc-dc]){ sr-=dr; sc-=dc; }
  const out=[];
  let i=0;
  while(true){
    const rr=sr+dr*i, cc=sc+dc*i;
    if(!inside(rr,cc)) break;
    const cell = (rr===r && cc===c) ? {k:'__hypo__'} : g[rr][cc];
    if(!cell) break;
    out.push({r:rr,c:cc,cell});
    i++;
  }
  return out;
}
function place(g,r,c,dr,dc,s,id){
  const coords=[];
  for(let i=0;i<s.length;i++){
    const rr=r+dr*i, cc=c+dc*i;
    g[rr][cc]={...(g[rr][cc]||{}),...s[i], id};
    coords.push([rr,cc]);
  }
  return coords;
}

function generateExact(target){
  const g=empty(), placed=[];
  // seed anywhere near center
  for(let seedTry=0; seedTry<300; seedTry++){
    const e0=generateRandomEquation(), s0=seq(e0), d0=Math.random()<0.5?'ac':'dn';
    const dr0=d0==='ac'?0:1, dc0=d0==='ac'?1:0;
    const r0=R(6,ROWS-7), c0=R(6,COLS-7);
    if(canPlace(g,r0,c0,dr0,dc0,s0,false)){
      place(g,r0,c0,dr0,dc0,s0,1); placed.push({id:1,eq:e0});
      break;
    }
  }
  if(placed.length===0) return null;

  let id=2, tries=0;
  while(id<=target && tries<MAX_TRIES){
    tries++;
    const e=generateRandomEquation(), s=seq(e);
    let best=null;
    for(const dir of ['ac','dn']){
      const dr=dir==='ac'?0:1, dc=dir==='ac'?1:0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlace(g,r,c,dr,dc,s,true)){
            const sc=score(g,r,c,dr,dc,s);
            if(!best || sc>best.sc) best={r,c,dr,dc,sc};
          }
        }
      }
    }
    if(best){
      place(g,best.r,best.c,best.dr,best.dc,s,id);
      placed.push({id,eq:e});
      id++;
    }else{
      return null; // cannot reach target under strict rules
    }
  }
  // final full validation: every contiguous segment must be length 5 and valid
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(!g[r][c]) continue;
      for(const [dr,dc] of [[0,1],[1,0]]){
        const seg=segment(g,r,c,dr,dc);
        if(seg.length>0){
          if(seg.length!==5 || !validStrip(seg)) return null;
        }
      }
    }
  }
  return {g,placed};
}

function score(g,r,c,dr,dc,s){
  // prefer more intersections and centrality
  let inter=0; for(let i=0;i<s.length;i++){ if(g[r+dr*i][c+dc*i]) inter++; }
  const mr=(ROWS-1)/2, mc=(COLS-1)/2;
  const er=r+dr*(s.length-1), ec=c+dc*(s.length-1);
  const dist=Math.hypot((r+er)/2-mr, (c+ec)/2-mc);
  return inter*10 - dist;
}

function cropBounds(g){
  const cells=[]; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(g[r][c]) cells.push([r,c]);
  const minR=Math.min(...cells.map(x=>x[0])), maxR=Math.max(...cells.map(x=>x[0]));
  const minC=Math.min(...cells.map(x=>x[1])), maxC=Math.max(...cells.map(x=>x[1]));
  return {minR,maxR,minC,maxC,rows:maxR-minR+1,cols:maxC-minC+1};
}
function t(tag,attrs){const n=document.createElementNS('http://www.w3.org/2000/svg',tag);for(const k in attrs)n.setAttribute(k,attrs[k]);return n}

function draw(model,givensCount){
  const {g}=model;
  // collect number cells
  const numCells=[];
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const cell=g[r][c]; if(cell && cell.k==='num') numCells.push({r,c});}
  if(givensCount>numCells.length) throw new Error(`requested ${givensCount} givens but only ${numCells.length} number cells exist`);

  // choose exact givens
  const arr=[...numCells]; for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];}
  const givenSet=new Set(arr.slice(0,givensCount).map(p=>p.r+','+p.c));

  const b=cropBounds(g);
  const targetPx=720, cell=Math.max(18, Math.floor(targetPx/b.cols));
  const W=b.cols*cell, H=b.rows*cell;
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('width',W); svg.setAttribute('height',H);
  svg.innerHTML='';

  for(let r=b.minR;r<=b.maxR;r++){
    for(let c=b.minC;c<=b.maxC;c++){
      const cellObj=g[r][c]; if(!cellObj) continue;
      const x=(c-b.minC)*cell, y=(r-b.minR)*cell;
      svg.appendChild(t('rect',{x,y,width:cell,height:cell,fill:'#fff',stroke:'#000','stroke-width':1}));
      let text=cellObj.ch;
      if(cellObj.k==='num' && !ans.checked){ text = givenSet.has(r+','+c) ? cellObj.ch : ''; }
      const fs = (text && text.length>=2) ? Math.floor(cell*0.55) : Math.floor(cell*0.7);
      const node=t('text',{x:x+cell/2,y:y+cell/2+1,'text-anchor':'middle','dominant-baseline':'middle','font-size':fs,'font-family':'sans-serif'});
      node.textContent=text||''; svg.appendChild(node);
    }
  }
  svg.appendChild(t('rect',{x:0,y:0,width:W,height:H,fill:'none',stroke:'#000','stroke-width':2}));

  // adjust givens slider max and persist
  givSlider.max = String(numCells.length);
  if(parseInt(givSlider.value)>numCells.length){
    givSlider.value=String(numCells.length); givOut.textContent=givSlider.value; setCookie('mx_gv', givSlider.value);
  }
  return {numTotal:numCells.length};
}

function getSelectedOperations() {
  const ops = [];
  if (opAdd.checked) ops.push('+');
  if (opSub.checked) ops.push('-');
  if (opMul.checked) ops.push('√ó');
  if (opDiv.checked) ops.push('√∑');
  return ops.length > 0 ? ops : ['+']; // Fallback to addition if none selected
}

function getNumberRange() {
  let min=0, max=20;
  const preset = rangePreset.value;
  if(/^(\d+)-(\d+)$/.test(preset)){
    const m=preset.match(/^(\d+)-(\d+)$/);
    min = parseInt(m[1]);
    max = parseInt(m[2]);
  }
  // Ensure positive non-zero results where needed
  return { min, max };
}

function validateEquation(A, B, C, op, range = null) {
  A = parseInt(A); B = parseInt(B); C = parseInt(C);

  const currentRange = range || getNumberRange();

  // Ensure all numbers are positive and within range
  if (A < currentRange.min || A > currentRange.max ||
      B < currentRange.min || B > currentRange.max ||
      C < currentRange.min || C > currentRange.max) return false;
  if (!Number.isInteger(A) || !Number.isInteger(B) || !Number.isInteger(C)) return false;
  if (A <= 0 || B <= 0 || C <= 0) return false; // Ensure all positive

  switch (op) {
    case '+': return A + B === C;
    case '-': return A - B === C && C > 0; // Explicitly check result is positive
    case '√ó': return A * B === C;
    case '√∑': return B !== 0 && A / B === C && A % B === 0; // Must be exact division
    default: return false;
  }
}

function generateRandomEquation() {
  const operations = getSelectedOperations();
  const range = getNumberRange();
  const digits = 'auto';

  for (let attempts = 0; attempts < 300; attempts++) {
    const op = operations[Math.floor(Math.random() * operations.length)];
    let A, B, C;

    switch (op) {
      case '+': {
        // Pick operands within selected range; result constraints handled in validateEquation
        A = R(range.min, range.max);
        B = R(range.min, range.max);
        // digits auto: do not clamp operands by digits; rely on range
        C = A + B;
        break; }

      case '-': {
        // Ensure A >= B and both in range
        A = R(Math.max(range.min, 1), range.max);
        B = R(range.min, range.max);
        if (B > A) [A, B] = [B, A];
        // digits auto: do not clamp operands by digits; rely on range
        C = A - B;
        break; }

      case '√ó': {
        const maxFactor = Math.min(Math.floor(Math.sqrt(range.max)), 20);
        A = R(2, Math.max(2, maxFactor));
        B = R(2, Math.max(2, maxFactor));
        // digits auto: do not clamp operands by digits; rely on range
        C = A * B;
        if (C < range.min || C > range.max) continue;
        break; }

      case '√∑': {
        // Generate exact division with operands in range
        B = R(Math.max(range.min, 2), Math.max(range.min, range.max));
        C = R(Math.max(range.min, 1), Math.max(range.min, range.max));
        A = B * C;
        if (A < 1) continue;
        // digits auto: do not clamp operands by digits; rely on range
        break; }
    }

    if (validateEquation(A, B, C, op, range)) {
      return {A, B, C, op};
    }
  }

  // Guaranteed valid fallback based on range
  const fallbackRange = range.max <= 20 ? {A: 8, B: 4, C: 2} : {A: 12, B: 4, C: 3};
  return {...fallbackRange, op: '√∑'};
}

function getIntersectionValue(grid, r, c) {
  return grid[r] && grid[r][c] && grid[r][c].k === 'num' ? parseInt(grid[r][c].ch) : null;
}

function findValidEquationForConstraints(constraints) {
  // constraints: {pos0: value, pos2: value, pos4: value} where positions are 0=A, 2=B, 4=C
  const operations = ['+', '-', '√ó', '√∑'];

  for (let attempt = 0; attempt < 1000; attempt++) {
    const eq = generateRandomEquation();
    const values = [eq.A, eq.B, eq.C];

    let valid = true;
    for (const [pos, requiredValue] of Object.entries(constraints)) {
      if (values[parseInt(pos) / 2] !== requiredValue) {
        valid = false;
        break;
      }
    }

    if (valid && validateEquation(eq.A, eq.B, eq.C, eq.op)) {
      return eq;
    }
  }

  // If no valid equation found with constraints, try to modify an equation
  if (Object.keys(constraints).length === 1) {
    const [pos, value] = Object.entries(constraints)[0];
    const position = parseInt(pos) / 2;

    // Try to build equation around the constraint
    for (const op of operations) {
      let A, B, C;

      if (position === 0) { // A is constrained
        A = value;
        for (let i = 0; i < 50; i++) {
          if (op === '+') {
            B = Math.floor(Math.random() * 40) + 10;
            C = A + B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '-') {
            B = Math.floor(Math.random() * Math.min(A - 1, 40)) + 1;
            C = A - B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√ó') {
            B = Math.floor(Math.random() * Math.min(9, Math.floor(99/A))) + 2;
            C = A * B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√∑') {
            const divisors = [];
            for (let d = 2; d <= Math.min(9, A); d++) {
              if (A % d === 0) divisors.push(d);
            }
            if (divisors.length > 0) {
              B = divisors[Math.floor(Math.random() * divisors.length)];
              C = A / B;
              if (validateEquation(A, B, C, op)) return {A, B, C, op};
            }
          }
        }
      } else if (position === 1) { // B is constrained
        B = value;
        for (let i = 0; i < 50; i++) {
          if (op === '+') {
            A = Math.floor(Math.random() * (99 - B)) + 10;
            C = A + B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '-') {
            A = Math.floor(Math.random() * 40) + B + 10;
            C = A - B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√ó') {
            A = Math.floor(Math.random() * Math.min(9, Math.floor(99/B))) + 2;
            C = A * B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√∑') {
            C = Math.floor(Math.random() * 10) + 2;
            A = B * C;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          }
        }
      } else if (position === 2) { // C is constrained
        C = value;
        for (let i = 0; i < 50; i++) {
          if (op === '+') {
            A = Math.floor(Math.random() * Math.min(C - 10, 50)) + 10;
            B = C - A;
            if (B >= 10 && B <= 50) return {A, B, C, op};
          } else if (op === '-') {
            B = Math.floor(Math.random() * Math.min(30, C - 1)) + 10;
            A = C + B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√ó') {
            const factors = [];
            for (let f = 2; f <= Math.min(9, C); f++) {
              if (C % f === 0 && C/f >= 2 && C/f <= 9) {
                factors.push([f, C/f]);
              }
            }
            if (factors.length > 0) {
              const [A, B] = factors[Math.floor(Math.random() * factors.length)];
              if (validateEquation(A, B, C, op)) return {A, B, C, op};
            }
          } else if (op === '√∑') {
            B = Math.floor(Math.random() * 8) + 2;
            A = C * B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          }
        }
      }
    }
  }

  return generateRandomEquation(); // Fallback
}

// BACKWARD GENERATION ALGORITHM
// 1. Generate complete crossword with all numbers filled
// 2. Strategically remove numbers while maintaining unique solvability
// 3. Stop when target difficulty percentage is reached

function generateBackwardCrossword(targetEquations, difficulty) {
  // Step 1: Generate a complete crossword with all numbers visible
  const fullModel = createRandomCrossword(targetEquations, difficulty);
  if (!fullModel) return null;

  // Step 2: Start with all numbers as givens and strategically remove them
  return optimizeGivensBackward(fullModel, difficulty);
}

function optimizeGivensBackward(model, difficulty) {
  const {grid, equations} = model;

  // Start with ALL numbers as givens (complete solution)
  const allNumberPositions = [];
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r] && grid[r][c] && grid[r][c].k === 'num') {
        allNumberPositions.push(`${r},${c}`);
      }
    }
  }

  let currentGivens = new Set(allNumberPositions);
  const difficultyTargets = getNewDifficultyTargets(difficulty, allNumberPositions.length);

  console.log(`=== BACKWARD GENERATION DEBUG ===`);
  console.log(`Difficulty: ${difficulty}`);
  console.log(`Total numbers: ${allNumberPositions.length}`);
  console.log(`Difficulty targets:`, difficultyTargets);

  if (!difficultyTargets || !difficultyTargets.percentage) {
    console.error('Invalid difficulty targets!', difficultyTargets);
    return model; // Return original model if targets are invalid
  }

  console.log(`Target range: ${difficultyTargets.minGivens}-${difficultyTargets.maxGivens} givens (${difficultyTargets.percentage.min}-${difficultyTargets.percentage.max}%)`);
  console.log(`Starting with: ${currentGivens.size} givens (100%)`);
  console.log(`===================================`);

  // Step 3: Remove numbers strategically until we hit target difficulty
  let attempts = 0;
  const maxAttempts = 200; // Prevent infinite loops

  while (currentGivens.size > difficultyTargets.maxGivens && attempts < maxAttempts) {
    attempts++;
    const bestRemoval = findBestNumberToRemove(grid, equations, currentGivens);

    if (!bestRemoval) {
      console.log(`No more removals found at ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%) - target was ${difficultyTargets.maxGivens}`);
      break; // Cannot remove any more numbers safely
    }

    if (attempts % 10 === 0) {
      console.log(`Attempt ${attempts}: ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%) - removing next...`);
    }

    currentGivens.delete(bestRemoval);

    // For expert mode, use mathematical constraint validation instead of full solvability
    if (difficulty === 'expert') {
      // Check if removal creates mathematical ambiguity (multiple valid solutions)
      if (createsMathematicalAmbiguity(grid, equations, currentGivens)) {
        currentGivens.add(bestRemoval);
        console.log(`Removed number created mathematical ambiguity at ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%)`);
        break;
      }
    } else {
      // For other difficulties, verify puzzle is still computationally solvable
      if (!canSolvePuzzle(grid, equations, currentGivens)) {
        currentGivens.add(bestRemoval);
        console.log(`Removed number broke solvability at ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%)`);
        break;
      }
    }
  }

  console.log(`Final: ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%), target was ${Math.round(difficultyTargets.maxGivens)} (${Math.round(difficultyTargets.maxGivens/allNumberPositions.length*100)}%)`);
  console.log(`Attempts made: ${attempts}`);
  console.log(`Generated ${equations.length} equations with ${allNumberPositions.length} total numbers`);

  // Step 4: Final validation to ensure we haven't created any isolated equations
  const beforeFix = currentGivens.size;
  currentGivens = fixAnyIsolatedEquations(grid, equations, currentGivens);
  const afterFix = currentGivens.size;

  if (afterFix > beforeFix) {
    console.log(`Final validation added ${afterFix - beforeFix} givens back (${beforeFix} -> ${afterFix})`);
  }

  return {
    ...model,
    optimizedGivens: currentGivens
  };
}

function findBestNumberToRemove(grid, equations, currentGivens) {
  const candidates = [];

  // Analyze each given number for removal potential
  for (const givenPos of currentGivens) {
    const [r, c] = givenPos.split(',').map(Number);
    const removalScore = calculateRemovalScore(grid, equations, currentGivens, r, c);

    if (removalScore > 0) {
      candidates.push({pos: givenPos, score: removalScore, r, c});
    }
  }

  if (candidates.length === 0) {
    console.log(`No removal candidates found! Current givens: ${currentGivens.size}`);
    return null;
  }

  // Sort by removal score (higher = better to remove)
  candidates.sort((a, b) => b.score - a.score);

  // Debug: Show top candidates
  if (candidates.length > 0) {
    console.log(`Found ${candidates.length} removal candidates, best score: ${candidates[0].score}`);
  }

  return candidates[0].pos;
}

function calculateRemovalScore(grid, equations, currentGivens, r, c) {
  let score = 0;

  // Find which equation(s) this number belongs to
  const containingEquations = [];
  for (const eq of equations) {
    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (numbers)
      const eqR = eq.across ? eq.row : eq.row + i;
      const eqC = eq.across ? eq.col + i : eq.col;
      if (eqR === r && eqC === c) {
        containingEquations.push({eq, position: i});
        break;
      }
    }
  }

  for (const {eq, position} of containingEquations) {
    // Count how many givens this equation currently has
    const eqPositions = [];
    for (let i = 0; i < 5; i += 2) {
      const eqR = eq.across ? eq.row : eq.row + i;
      const eqC = eq.across ? eq.col + i : eq.col;
      if (eqR < 24 && eqC < 24) {
        eqPositions.push(`${eqR},${eqC}`);
      }
    }

    const currentEqGivens = eqPositions.filter(pos => currentGivens.has(pos)).length;

    // CRITICAL: Never remove the last given from an equation
    if (currentEqGivens <= 1) {
      return 0; // Cannot remove - would create equation with 0 givens
    }

    // EXPERT MODE: Be much more aggressive about removal scoring
    if (currentEqGivens >= 3) {
      score += 20; // Heavily favor removing from fully-given equations
    } else if (currentEqGivens === 2) {
      // Check if this number has intersection constraints
      const intersectionCount = countIntersectionConstraints(grid, equations, currentGivens, r, c);
      if (intersectionCount >= 2) {
        score += 15; // Strong intersections = high removal score
      } else if (intersectionCount >= 1) {
        score += 10; // Even single intersections get good scores for expert
      } else {
        score += 5; // Still consider for removal with weaker constraints
      }
    }

    // Prefer removing results over operands for cleaner puzzles
    if (position === 4) { // Result position
      score += 2;
    }

    // Prefer removing larger numbers (they're easier to deduce)
    const cellValue = parseInt(grid[r][c].ch);
    if (cellValue > 20) score += 1;
  }

  return score;
}

function countIntersectionConstraints(grid, equations, currentGivens, r, c) {
  let count = 0;

  for (const eq of equations) {
    // Check if this position intersects with this equation
    for (let i = 0; i < 5; i += 2) {
      const eqR = eq.across ? eq.row : eq.row + i;
      const eqC = eq.across ? eq.col + i : eq.col;

      if (eqR === r && eqC === c) {
        // Found intersection! Check if this equation provides constraints
        const eqPositions = [];
        for (let j = 0; j < 5; j += 2) {
          const checkR = eq.across ? eq.row : eq.row + j;
          const checkC = eq.across ? eq.col + j : eq.col;
          if (checkR < 24 && checkC < 24) {
            eqPositions.push(`${checkR},${checkC}`);
          }
        }

        const eqGivens = eqPositions.filter(pos => currentGivens.has(pos)).length;
        if (eqGivens >= 2) {
          count++;
        }
        break;
      }
    }
  }

  return count;
}

function fixAnyIsolatedEquations(grid, equations, currentGivens) {
  const fixedGivens = new Set([...currentGivens]);
  let fixes = 0;

  for (const eq of equations) {
    const eqPositions = [];
    for (let i = 0; i < 5; i += 2) {
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqPositions.push(`${r},${c}`);
      }
    }

    const givenCount = eqPositions.filter(pos => fixedGivens.has(pos)).length;

    // Only fix truly unsolvable cases - be very conservative for expert puzzles
    if (givenCount === 0) {
      fixedGivens.add(eqPositions[0]);
      fixes++;
      console.log(`Fixed equation with 0 givens (fix #${fixes})`);
    } else if (givenCount === 1 && eqPositions.length >= 3) {
      // For expert mode, be extremely conservative - only fix if ALL empty positions are completely isolated
      let completelyIsolatedCount = 0;

      for (const pos of eqPositions) {
        if (!fixedGivens.has(pos)) {
          const [r, c] = pos.split(',').map(Number);

          // Check if this position has ANY intersection at all
          let hasAnyIntersection = false;
          for (const otherEq of equations) {
            if (otherEq === eq) continue;
            for (let j = 0; j < 5; j += 2) {
              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;
              if (otherR === r && otherC === c) {
                hasAnyIntersection = true;
                break;
              }
            }
            if (hasAnyIntersection) break;
          }

          if (!hasAnyIntersection) {
            completelyIsolatedCount++;
          }
        }
      }

      // Only fix if ALL empty positions are completely isolated (extremely rare case)
      if (completelyIsolatedCount === eqPositions.length - givenCount) {
        const ungiven = eqPositions.filter(pos => !fixedGivens.has(pos));
        if (ungiven.length > 0) {
          fixedGivens.add(ungiven[0]);
          fixes++;
          console.log(`Fixed equation with ${completelyIsolatedCount} completely isolated positions (fix #${fixes})`);
        }
      }
    }
  }

  console.log(`Final validation made ${fixes} fixes total`);
  return fixedGivens;
}

function createRandomCrossword(numEquations, difficulty = 'expert') {
  const grid = Array.from({length: 24}, () => Array(24).fill(null));
  const equations = [];
  const maxAttempts = 100;

  // Start with first equation in center area
  const firstRow = Math.floor(Math.random() * 8) + 8;
  const firstCol = Math.floor(Math.random() * 8) + 8;
  const firstAcross = Math.random() < 0.5;

  const firstEq = generateRandomEquation();
  const firstSeq = [
    {k: 'num', ch: String(firstEq.A)},
    {k: 'op', ch: firstEq.op},
    {k: 'num', ch: String(firstEq.B)},
    {k: 'eq', ch: '='},
    {k: 'num', ch: String(firstEq.C)}
  ];

  // Place first equation
  for (let i = 0; i < 5; i++) {
    const r = firstAcross ? firstRow : firstRow + i;
    const c = firstAcross ? firstCol + i : firstCol;
    grid[r][c] = {...firstSeq[i], id: 1};
  }

  equations.push({
    across: firstAcross,
    row: firstRow,
    col: firstCol,
    eq: firstEq
  });

  // Add remaining equations with difficulty-based connectivity
  for (let eqNum = 2; eqNum <= numEquations; eqNum++) {
    let placed = false;

    for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
      // Enhanced intersection finding - connectivity varies by difficulty
      const possibleIntersections = [];

      for (let r = 1; r < 23; r++) {
        for (let c = 1; c < 23; c++) {
          if (grid[r][c] && grid[r][c].k === 'num') {
            // Try both orientations
            for (const across of [true, false]) {
              for (let pos = 0; pos < 5; pos += 2) { // Only number positions (0, 2, 4)
                const startR = across ? r : r - pos;
                const startC = across ? c - pos : c;

                // Check if this position would work
                if (startR >= 0 && startR < 24 && startC >= 0 && startC < 24) {
                  let canPlace = true;
                  const constraints = {};
                  let intersectionCount = 0;

                  // Check all 5 positions of potential equation
                  for (let i = 0; i < 5; i++) {
                    const checkR = across ? startR : startR + i;
                    const checkC = across ? startC + i : startC;

                    if (checkR >= 24 || checkC >= 24) {
                      canPlace = false;
                      break;
                    }

                    const existing = grid[checkR][checkC];
                    if (existing) {
                      // ENHANCED: Allow multiple intersections and self-loops
                      if (existing.k === 'num') {
                        constraints[i] = parseInt(existing.ch);
                        intersectionCount++;
                      } else if (existing.k === 'op' && (i === 1)) {
                        // Allow operation intersections for loops (but be more lenient)
                        if (getSelectedOperations().map(op => op.symbol).includes(existing.ch)) {
                          constraints[i] = existing.ch;
                          intersectionCount++;
                        } else {
                          canPlace = false;
                          break;
                        }
                      } else if (existing.k === 'eq' && (i === 3)) {
                        // Allow equals sign intersections for loops
                        constraints[i] = existing.ch;
                        intersectionCount++;
                      } else {
                        // For the first few equations, be more lenient about intersections
                        if (eqNum <= 5) {
                          // Skip this intersection rather than failing
                          canPlace = false;
                          break;
                        } else {
                          // Later equations can be more strict
                          canPlace = false;
                          break;
                        }
                      }
                    }
                  }

                  // ENHANCED: Prefer placements with multiple intersections
                  // Difficulty-based minimum intersection requirements
                  let minIntersections;
                  switch (difficulty) {
                    case 'expert':
                      minIntersections = eqNum <= 3 ? 1 : 1; // Expert allows single intersections but prefers multiple
                      break;
                    case 'hard':
                      minIntersections = 1; // Hard requires at least one intersection
                      break;
                    case 'medium':
                    case 'easy':
                      minIntersections = eqNum <= 5 ? 1 : 1; // Easier modes are more flexible
                      break;
                    default:
                      minIntersections = 1;
                  }

                  if (canPlace && intersectionCount >= minIntersections) {
                    possibleIntersections.push({
                      row: startR,
                      col: startC,
                      across: across,
                      constraints: constraints,
                      intersectionCount: intersectionCount // For scoring
                    });
                  }
                }
              }
            }
          }
        }
      }

      if (possibleIntersections.length > 0) {
        // ENHANCED: Prefer intersections with higher connectivity based on difficulty
        // Sort by intersection count (descending) and pick from top candidates
        possibleIntersections.sort((a, b) => b.intersectionCount - a.intersectionCount);

        // Difficulty-based connectivity selection
        let topPercentage;
        switch (difficulty) {
          case 'expert':
            topPercentage = 0.4; // Pick from top 40% - reduced from 20%
            break;
          case 'hard':
            topPercentage = 0.6; // Pick from top 60% - reduced from 40%
            break;
          case 'medium':
            topPercentage = 0.8; // Pick from top 80% - reduced from 60%
            break;
          case 'easy':
            topPercentage = 1.0; // Pick from all options - reduced from 80%
            break;
          default:
            topPercentage = 0.5; // Default fallback
        }

        const topCandidates = possibleIntersections.slice(0, Math.max(1, Math.ceil(possibleIntersections.length * topPercentage)));
        const intersection = topCandidates[Math.floor(Math.random() * topCandidates.length)];

        let eq = null;
        let attempts = 0;
        while (!eq && attempts < 10) {
          eq = findValidEquationForConstraints(intersection.constraints);
          attempts++;
        }

        // If we still can't find a valid equation, try fallback based on difficulty
        if (!eq && possibleIntersections.length > 1) {
          if (difficulty === 'expert') {
            // For expert, try high-connectivity intersections first, then single
            const multiIntersections = possibleIntersections.filter(int => int.intersectionCount > 1);
            if (multiIntersections.length > 0) {
              const multiIntersection = multiIntersections[Math.floor(Math.random() * multiIntersections.length)];
              eq = findValidEquationForConstraints(multiIntersection.constraints);
            }
          }

          // Fallback to simpler intersections if needed
          if (!eq) {
            const simplerIntersections = possibleIntersections.filter(int => int.intersectionCount === 1);
            if (simplerIntersections.length > 0) {
              const simpleIntersection = simplerIntersections[Math.floor(Math.random() * simplerIntersections.length)];
              eq = findValidEquationForConstraints(simpleIntersection.constraints);
            }
          }
        }

        if (!eq) {
          console.log('Failed to generate equation for constraints, using fallback');
          eq = generateRandomEquation();
        }

        const sequence = [
          {k: 'num', ch: String(eq.A)},
          {k: 'op', ch: eq.op},
          {k: 'num', ch: String(eq.B)},
          {k: 'eq', ch: '='},
          {k: 'num', ch: String(eq.C)}
        ];

        // Place equation
        for (let i = 0; i < 5; i++) {
          const r = intersection.across ? intersection.row : intersection.row + i;
          const c = intersection.across ? intersection.col + i : intersection.col;
          if (!grid[r][c]) {
            grid[r][c] = {...sequence[i], id: eqNum};
          }
        }

        equations.push({
          across: intersection.across,
          row: intersection.row,
          col: intersection.col,
          eq: eq
        });

        placed = true;
      }
    }

    // If we couldn't place intersecting, try placing separately
    if (!placed) {
      for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
        const row = Math.floor(Math.random() * 16) + 4;
        const col = Math.floor(Math.random() * 16) + 4;
        const across = Math.random() < 0.5;

        let canPlace = true;
        for (let i = 0; i < 5; i++) {
          const r = across ? row : row + i;
          const c = across ? col + i : col;
          if (r >= 24 || c >= 24 || grid[r][c]) {
            canPlace = false;
            break;
          }
        }

        if (canPlace) {
          const eq = generateRandomEquation();
          const sequence = [
            {k: 'num', ch: String(eq.A)},
            {k: 'op', ch: eq.op},
            {k: 'num', ch: String(eq.B)},
            {k: 'eq', ch: '='},
            {k: 'num', ch: String(eq.C)}
          ];

          for (let i = 0; i < 5; i++) {
            const r = across ? row : row + i;
            const c = across ? col + i : col;
            grid[r][c] = {...sequence[i], id: eqNum};
          }

          equations.push({
            across: across,
            row: row,
            col: col,
            eq: eq
          });

          placed = true;
        }
      }

      // FALLBACK: If no intersections found, place equation in empty space
      if (!placed) {
        console.log(`No intersections found for equation ${eqNum}, trying fallback placement`);

        for (let fallbackAttempt = 0; fallbackAttempt < 50 && !placed; fallbackAttempt++) {
          const row = Math.floor(Math.random() * 20) + 2;
          const col = Math.floor(Math.random() * 20) + 2;
          const across = Math.random() < 0.5;

          // Check if this space is free
          let canPlace = true;
          for (let i = 0; i < 5; i++) {
            const checkR = across ? row : row + i;
            const checkC = across ? col + i : col;

            if (checkR >= 24 || checkC >= 24 || grid[checkR][checkC]) {
              canPlace = false;
              break;
            }
          }

          if (canPlace) {
            const eq = generateRandomEquation();
            const sequence = [
              {k: 'num', ch: String(eq.A)},
              {k: 'op', ch: eq.op},
              {k: 'num', ch: String(eq.B)},
              {k: 'eq', ch: '='},
              {k: 'num', ch: String(eq.C)}
            ];

            // Place the equation
            for (let i = 0; i < 5; i++) {
              const r = across ? row : row + i;
              const c = across ? col + i : col;
              grid[r][c] = {...sequence[i], id: eqNum};
            }

            equations.push({
              across: across,
              row: row,
              col: col,
              eq: eq
            });

            placed = true;
            console.log(`Fallback placement successful for equation ${eqNum}`);
          }
        }

        if (!placed) {
          console.log(`Failed to place equation ${eqNum} even with fallback`);
        }
      }
    }

    if (!placed) {
      console.log(`Could not place equation ${eqNum} after ${maxAttempts} attempts`);
    }
  }

  return {grid, equations};
}

function findValidEquationForConstraints(constraints) {
  // ENHANCED: Handle multiple constraints including operators and equals
  // constraints: {pos0: value, pos1: op, pos2: value, pos3: '=', pos4: value}
  const operations = getSelectedOperations().map(op => op.symbol);

  for (let attempt = 0; attempt < 2000; attempt++) {
    const eq = generateRandomEquation();

    // Check if this equation satisfies ALL constraints
    let valid = true;

    for (const [pos, requiredValue] of Object.entries(constraints)) {
      const position = parseInt(pos);
      let actualValue;

      if (position === 0) actualValue = eq.A;
      else if (position === 1) actualValue = eq.op;
      else if (position === 2) actualValue = eq.B;
      else if (position === 3) actualValue = '=';
      else if (position === 4) actualValue = eq.C;

      if (actualValue !== requiredValue) {
        valid = false;
        break;
      }
    }

    if (valid && validateEquation(eq.A, eq.B, eq.C, eq.op)) {
      return eq;
    }
  }

  // If no valid equation found with ALL constraints, try to build one systematically
  const numConstraints = Object.keys(constraints).filter(pos => [0, 2, 4].includes(parseInt(pos)));
  if (numConstraints.length >= 1) {
    return buildEquationWithConstraints(constraints);
  }

  // Fallback to random equation
  return generateRandomEquation();
}

function buildEquationWithConstraints(constraints) {
  // Build equation systematically when we have specific number constraints
  const operations = getSelectedOperations().map(op => op.symbol);

  // Extract constraints
  const A = constraints[0] ? parseInt(constraints[0]) : null;
  const op = constraints[1] || null;
  const B = constraints[2] ? parseInt(constraints[2]) : null;
  const C = constraints[4] ? parseInt(constraints[4]) : null;

  // Try to satisfy constraints systematically
  for (const testOp of (op ? [op] : operations)) {
    for (let attempt = 0; attempt < 100; attempt++) {
      let testA, testB, testC;

      if (A !== null && B !== null) {
        // Both operands known, calculate result
        testA = A;
        testB = B;
        if (testOp === '+') testC = testA + testB;
        else if (testOp === '-') testC = testA - testB;
        else if (testOp === '√ó') testC = testA * testB;
        else if (testOp === '√∑' && testB !== 0 && testA % testB === 0) testC = testA / testB;
        else continue;
      } else if (A !== null && C !== null) {
        // First operand and result known, calculate second operand
        testA = A;
        testC = C;
        if (testOp === '+') testB = testC - testA;
        else if (testOp === '-') testB = testA - testC;
        else if (testOp === '√ó' && testA !== 0 && testC % testA === 0) testB = testC / testA;
        else if (testOp === '√∑' && testA !== 0) testB = testA / testC;
        else continue;
      } else if (B !== null && C !== null) {
        // Second operand and result known, calculate first operand
        testB = B;
        testC = C;
        if (testOp === '+') testA = testC - testB;
        else if (testOp === '-') testA = testC + testB;
        else if (testOp === '√ó' && testB !== 0 && testC % testB === 0) testA = testC / testB;
        else if (testOp === '√∑') testA = testC * testB;
        else continue;
      } else {
        // Only one constraint, generate others randomly
        const range = getNumberRange();
        if (A !== null) {
          testA = A;
          testB = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        } else if (B !== null) {
          testB = B;
          testA = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        } else if (C !== null) {
          testC = C;
          testA = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
          testB = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
        }

        // Calculate missing value
        if (testC === undefined) {
          if (testOp === '+') testC = testA + testB;
          else if (testOp === '-') testC = testA - testB;
          else if (testOp === '√ó') testC = testA * testB;
          else if (testOp === '√∑' && testB !== 0 && testA % testB === 0) testC = testA / testB;
          else continue;
        }
      }

      // Validate the constructed equation
      if (testA > 0 && testB > 0 && testC > 0 &&
          testA <= 99 && testB <= 99 && testC <= 99 &&
          validateEquation(testA, testB, testC, testOp)) {
        return {A: testA, B: testB, C: testC, op: testOp};
      }
    }
  }

  // Fallback
  return generateRandomEquation();
}

function getNewDifficultyTargets(difficulty, totalNumbers) {
  console.log(`getNewDifficultyTargets called with: ${difficulty}, ${totalNumbers}`);

  // Define difficulty levels with appropriate percentages
  const difficultySettings = {
    expert: { min: 0.03, max: 0.08, name: 'Expert' },    // 3-8% - Ultra minimal for serious deduction
    hard:   { min: 0.15, max: 0.22, name: 'Hard' },     // 15-22% - Requires logical thinking
    medium: { min: 0.25, max: 0.35, name: 'Medium' },   // 25-35% - Moderate challenge
    easy:   { min: 0.35, max: 0.45, name: 'Easy' }      // 35-45% - More guidance
  };

  const setting = difficultySettings[difficulty] || difficultySettings.medium;
  console.log(`Found setting:`, setting);

  const result = {
    minGivens: Math.ceil(totalNumbers * setting.min),
    maxGivens: Math.ceil(totalNumbers * setting.max),
    name: setting.name,
    percentage: {
      min: Math.round(setting.min * 100),
      max: Math.round(setting.max * 100)
    }
  };

  console.log(`Returning:`, result);
  return result;
}

function canSolvePuzzle(grid, equations, givenPositions) {
  // Create a copy of the grid with only givens
  const solveGrid = Array.from({length: 24}, () => Array(24).fill(null));

  // Place only the given cells
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r][c] && givenPositions.has(`${r},${c}`)) {
        solveGrid[r][c] = grid[r][c];
      } else if (grid[r][c]) {
        solveGrid[r][c] = {k: grid[r][c].k, ch: grid[r][c].k === 'num' ? null : grid[r][c].ch, id: grid[r][c].id};
      }
    }
  }

  // Enhanced solving with multiple passes and techniques
  let globalChanged = true;
  let globalIterations = 0;
  const maxGlobalIterations = 10;

  while (globalChanged && globalIterations < maxGlobalIterations) {
    globalChanged = false;
    globalIterations++;

    // Pass 1: Basic constraint propagation (equations with 2 knowns)
    let changed = true;
    let iterations = 0;
    const maxIterations = 20;

    while (changed && iterations < maxIterations) {
      changed = false;
      iterations++;

      for (const eq of equations) {
        const cells = [];
        for (let i = 0; i < 5; i++) {
          const r = eq.across ? eq.row : eq.row + i;
          const c = eq.across ? eq.col + i : eq.col;
          if (r < 24 && c < 24 && solveGrid[r][c]) {
            cells.push({r, c, cell: solveGrid[r][c], pos: i});
          }
        }

        if (cells.length === 5) {
          const numCells = cells.filter(cell => cell.cell.k === 'num');
          const opCell = cells.find(cell => cell.cell.k === 'op');

          if (opCell && numCells.length >= 2) {
            const knownValues = {};
            const unknownPositions = [];

            for (const numCell of numCells) {
              if (numCell.cell.ch !== null) {
                knownValues[numCell.pos] = parseInt(numCell.cell.ch);
              } else {
                unknownPositions.push(numCell.pos);
              }
            }

            // If we have 2 known values, we can deduce the third
            if (Object.keys(knownValues).length === 2 && unknownPositions.length === 1) {
              const op = opCell.cell.ch;
              const unknownPos = unknownPositions[0];
              let deducedValue = null;

              if (unknownPos === 0) { // Deduce A
                const B = knownValues[2];
                const C = knownValues[4];
                if (op === '+') deducedValue = C - B;
                else if (op === '-') deducedValue = C + B;
                else if (op === '√ó') deducedValue = B !== 0 ? C / B : null;
                else if (op === '√∑') deducedValue = C * B;
              } else if (unknownPos === 2) { // Deduce B
                const A = knownValues[0];
                const C = knownValues[4];
                if (op === '+') deducedValue = C - A;
                else if (op === '-') deducedValue = A - C;
                else if (op === '√ó') deducedValue = A !== 0 ? C / A : null;
                else if (op === '√∑') deducedValue = A !== 0 ? A / C : null;
              } else if (unknownPos === 4) { // Deduce C
                const A = knownValues[0];
                const B = knownValues[2];
                if (op === '+') deducedValue = A + B;
                else if (op === '-') deducedValue = A - B;
                else if (op === '√ó') deducedValue = A * B;
                else if (op === '√∑') deducedValue = B !== 0 ? A / B : null;
              }

              if (deducedValue !== null && deducedValue > 0 && deducedValue <= 99 && Number.isInteger(deducedValue)) {
                const targetCell = cells.find(cell => cell.pos === unknownPos);
                if (targetCell && targetCell.cell.ch === null) {
                  targetCell.cell.ch = String(deducedValue);
                  changed = true;
                  globalChanged = true;
                }
              }
            }
          }
        }
      }
    }

    // Pass 2: Advanced constraint analysis (single constraints with intersection analysis)
    for (const eq of equations) {
      const cells = [];
      for (let i = 0; i < 5; i++) {
        const r = eq.across ? eq.row : eq.row + i;
        const c = eq.across ? eq.col + i : eq.col;
        if (r < 24 && c < 24 && solveGrid[r][c]) {
          cells.push({r, c, cell: solveGrid[r][c], pos: i});
        }
      }

      if (cells.length === 5) {
        const numCells = cells.filter(cell => cell.cell.k === 'num');
        const opCell = cells.find(cell => cell.cell.k === 'op');

        if (opCell && numCells.length >= 1) {
          const knownValues = {};
          const unknownPositions = [];

          for (const numCell of numCells) {
            if (numCell.cell.ch !== null) {
              knownValues[numCell.pos] = parseInt(numCell.cell.ch);
            } else {
              unknownPositions.push(numCell.pos);
            }
          }

          // Advanced: Try to solve with 1 known + intersection constraints
          if (Object.keys(knownValues).length === 1 && unknownPositions.length === 2) {
            // Try to deduce one unknown from intersection constraints
            for (const unknownPos of unknownPositions) {
              const cell = cells.find(c => c.pos === unknownPos);
              const possibleValues = getPossibleValuesFromIntersections(solveGrid, equations, cell.r, cell.c);

              if (possibleValues && possibleValues.length === 1) {
                // Only one possible value from intersections - use it
                cell.cell.ch = String(possibleValues[0]);
                globalChanged = true;
                break; // Process one at a time
              }
            }
          }
        }
      }
    }
  }

  // Check if puzzle is completely solved
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r][c] && grid[r][c].k === 'num') {
        if (!solveGrid[r][c] || solveGrid[r][c].ch === null) {
          return false; // Not solvable
        }
      }
    }
  }

  return true; // Puzzle is solvable
}

function getPossibleValuesFromIntersections(solveGrid, equations, targetR, targetC) {
  // Find intersecting equations that constrain this position
  const possibleValues = [];
  const range = getNumberRange();

  for (let testValue = range.min; testValue <= range.max; testValue++) {
    let isValid = true;

    // Test if this value would be consistent with all intersecting equations
    for (const eq of equations) {
      let isInThisEquation = false;
      let positionInEquation = -1;

      // Check if this position is part of this equation
      for (let i = 0; i < 5; i += 2) {
        const eqR = eq.across ? eq.row : eq.row + i;
        const eqC = eq.across ? eq.col + i : eq.col;
        if (eqR === targetR && eqC === targetC) {
          isInThisEquation = true;
          positionInEquation = i;
          break;
        }
      }

      if (isInThisEquation) {
        // This equation contains our target position
        const eqCells = [];
        for (let i = 0; i < 5; i++) {
          const eqR = eq.across ? eq.row : eq.row + i;
          const eqC = eq.across ? eq.col + i : eq.col;
          if (eqR < 24 && eqC < 24 && solveGrid[eqR][eqC]) {
            eqCells.push({r: eqR, c: eqC, cell: solveGrid[eqR][eqC], pos: i});
          }
        }

        if (eqCells.length === 5) {
          const numCells = eqCells.filter(cell => cell.cell.k === 'num');
          const opCell = eqCells.find(cell => cell.cell.k === 'op');

          if (opCell && numCells.length === 3) {
            // Build equation with test value
            const values = {};
            let hasUnknowns = false;

            for (const numCell of numCells) {
              if (numCell.r === targetR && numCell.c === targetC) {
                values[numCell.pos] = testValue;
              } else if (numCell.cell.ch !== null) {
                values[numCell.pos] = parseInt(numCell.cell.ch);
              } else {
                hasUnknowns = true;
              }
            }

            // If we have at least 2 values (including our test), check equation validity
            if (Object.keys(values).length >= 2 && !hasUnknowns) {
              const A = values[0];
              const B = values[2];
              const C = values[4];
              const op = opCell.cell.ch;

              if (A !== undefined && B !== undefined && C !== undefined) {
                if (!evalOk(A, op, B, C)) {
                  isValid = false;
                  break;
                }
              }
            }
          }
        }
      }
    }

    if (isValid) {
      possibleValues.push(testValue);
    }
  }

  return possibleValues;
}

function createsMathematicalAmbiguity(grid, equations, givenPositions) {
  // ULTRA-PERMISSIVE for expert mode - only prevent the most extreme impossibilities

  for (const eq of equations) {
    const eqPositions = [];
    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqPositions.push({r, c, pos: i});
      }
    }

    const givenCount = eqPositions.filter(pos => givenPositions.has(`${pos.r},${pos.c}`)).length;

    // ONLY prevent equations with absolutely NO constraints
    if (givenCount === 0) {
      console.log('Mathematical ambiguity: equation with 0 givens');
      return true; // No constraints = infinite solutions
    }

    // For equations with only 1 given, check if it's COMPLETELY isolated
    // Only flag if there are literally NO intersections at all for ANY empty position
    if (eqPositions.length >= 3 && givenCount === 1) {
      let totalIntersections = 0;

      for (const pos of eqPositions) {
        if (!givenPositions.has(`${pos.r},${pos.c}`)) {
          // Count intersections for this empty position
          for (const otherEq of equations) {
            if (otherEq === eq) continue;

            for (let j = 0; j < 5; j += 2) {
              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;

              if (otherR === pos.r && otherC === pos.c) {
                totalIntersections++;
                break;
              }
            }
          }
        }
      }

      // Only flag if this equation has ZERO intersections total
      // This is extremely rare with high connectivity
      if (totalIntersections === 0) {
        console.log(`Mathematical ambiguity: equation has zero intersections total`);
        return true;
      }
    }
  }

  return false; // Allow everything else - trust the connectivity network
}

function getDifficultyTargets(difficulty, totalNumbers) {
  // Define difficulty levels - Expert requires serious deduction
  const difficultySettings = {
    expert: { min: 0.03, max: 0.08, name: 'Expert' },    // Ultra minimal clues for serious deduction
    hard:   { min: 0.15, max: 0.22, name: 'Hard' },     // Reduced from previous
    medium: { min: 0.25, max: 0.35, name: 'Medium' },   // Unchanged
    easy:   { min: 0.35, max: 0.45, name: 'Easy' }      // Slightly more clues
  };

  const setting = difficultySettings[difficulty] || difficultySettings.medium;
  return {
    minGivens: Math.ceil(totalNumbers * setting.min),
    maxGivens: Math.ceil(totalNumbers * setting.max),
    name: setting.name
  };
}

function isCompleteEquation(grid, equations, givenSet) {
  // Check if any equation has ALL its numbers given (making it trivial)
  for (const eq of equations) {
    const numberPositions = [];
    let givenNumbers = 0;

    // Find all number positions in this equation
    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (the numbers)
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        numberPositions.push({r, c});
        if (givenSet.has(`${r},${c}`)) {
          givenNumbers++;
        }
      }
    }

    // If ALL numbers in this equation are given, it's complete (trivial)
    if (numberPositions.length > 0 && givenNumbers === numberPositions.length) {
      return true;
    }

    // Also check for equations where 4+ out of 5 numbers are given (nearly complete)
    if (numberPositions.length >= 4 && givenNumbers >= numberPositions.length - 1) {
      return true;
    }
  }
  return false;
}

function hasAnyIsolatedEquations(grid, equations, givenSet) {
  // Check and fix equations with insufficient givens to determine a unique solution
  let foundIssues = false;

  for (const eq of equations) {
    const eqPositions = [];
    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (the numbers)
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqPositions.push({r, c, pos: i});
      }
    }

    // Count givens in this equation
    const givenCount = eqPositions.filter(pos => givenSet.has(`${pos.r},${pos.c}`)).length;

    // CRITICAL: Equations need sufficient givens to prevent ambiguity
    if (givenCount === 0) {
      foundIssues = true;
      continue; // No givens = unsolvable, but continue checking other equations
    }

    // For equations with 3 numbers (A op B = C), having only 1 given can create ambiguity
    // We need to ensure ALL empty positions have intersecting constraints
    if (eqPositions.length >= 3 && givenCount === 1) {
      let emptyPositionsWithConstraints = 0;
      let totalEmptyPositions = 0;

      for (const pos of eqPositions) {
        if (!givenSet.has(`${pos.r},${pos.c}`)) {
          totalEmptyPositions++;

          // Check if this empty position intersects with other equations that have constraints
          let hasIntersectionConstraint = false;
          for (const otherEq of equations) {
            if (otherEq === eq) continue; // Skip same equation

            // Check if this position intersects with the other equation
            for (let j = 0; j < 5; j += 2) {
              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;

              if (otherR === pos.r && otherC === pos.c) {
                // Found intersection! Check if other equation has sufficient constraints
                const otherPositions = [];
                for (let k = 0; k < 5; k += 2) {
                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;
                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;
                  if (checkR < 24 && checkC < 24) {
                    otherPositions.push(`${checkR},${checkC}`);
                  }
                }
                const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;
                const otherEmptyCount = otherPositions.length - otherGivenCount;

                // The intersecting equation must have enough constraints to determine this value
                // For a 3-number equation, need at least 2 knowns (including intersections)
                if (otherGivenCount >= 2 || (otherGivenCount === 1 && otherEmptyCount === 1)) {
                  hasIntersectionConstraint = true;
                }
                break;
              }
            }
            if (hasIntersectionConstraint) break;
          }

          if (hasIntersectionConstraint) {
            emptyPositionsWithConstraints++;
          }
        }
      }

      // ALL empty positions must have intersection constraints to prevent ambiguity
      // Example: "_ - _ = 11" needs both operands constrained by intersections
      if (totalEmptyPositions > 0 && emptyPositionsWithConstraints < totalEmptyPositions) {
        // Instead of rejecting, add a strategic given to fix this equation
        const unconstrainedPositions = [];
        for (const pos of eqPositions) {
          if (!givenSet.has(`${pos.r},${pos.c}`)) {
            // Check if this position lacks intersection constraints
            let hasConstraint = false;
            for (const otherEq of equations) {
              if (otherEq === eq) continue;
              for (let j = 0; j < 5; j += 2) {
                const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
                const otherC = otherEq.across ? otherEq.col + j : otherEq.col;
                if (otherR === pos.r && otherC === pos.c) {
                  const otherPositions = [];
                  for (let k = 0; k < 5; k += 2) {
                    const checkR = otherEq.across ? otherEq.row : otherEq.row + k;
                    const checkC = otherEq.across ? otherEq.col + k : otherEq.col;
                    if (checkR < 24 && checkC < 24) {
                      otherPositions.push(`${checkR},${checkC}`);
                    }
                  }
                  const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;
                  const otherEmptyCount = otherPositions.length - otherGivenCount;
                  if (otherGivenCount >= 2 || (otherGivenCount === 1 && otherEmptyCount === 1)) {
                    hasConstraint = true;
                    break;
                  }
                }
              }
              if (hasConstraint) break;
            }
            if (!hasConstraint) {
              unconstrainedPositions.push(`${pos.r},${pos.c}`);
            }
          }
        }

        // Add a given to one of the unconstrained positions to fix the equation
        if (unconstrainedPositions.length > 0) {
          givenSet.add(unconstrainedPositions[0]);
          // Continue checking other equations instead of returning true
        }
      }
    }

    // If only 1 given and equation has 2 numbers, check if there are intersecting constraints
    if (givenCount === 1 && eqPositions.length === 2) {
      let hasIntersectingConstraints = false;

      // Check each number position for intersections with other equations
      for (const pos of eqPositions) {
        if (!givenSet.has(`${pos.r},${pos.c}`)) {
          // This position is not given, check if it intersects with other equations that have constraints
          for (const otherEq of equations) {
            if (otherEq === eq) continue; // Skip same equation

            // Check if this position intersects with the other equation
            for (let j = 0; j < 5; j += 2) {
              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;

              if (otherR === pos.r && otherC === pos.c) {
                // Found intersection! Check if other equation has enough constraints
                const otherPositions = [];
                for (let k = 0; k < 5; k += 2) {
                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;
                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;
                  if (checkR < 24 && checkC < 24) {
                    otherPositions.push(`${checkR},${checkC}`);
                  }
                }
                const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;
                if (otherGivenCount >= 2) {
                  hasIntersectingConstraints = true;
                  break;
                }
              }
            }
            if (hasIntersectingConstraints) break;
          }
          if (hasIntersectingConstraints) break;
        }
      }

      // If no intersecting constraints found, this equation is isolated
      if (!hasIntersectingConstraints) {
        foundIssues = true;
      }
    }
  }
  return foundIssues;
}

function selectOptimalGivens(grid, equations, difficulty) {
  // Get all number cells for difficulty calculation
  const numCells = [];
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r] && grid[r][c] && grid[r][c].k === 'num') {
        numCells.push({r, c});
      }
    }
  }

  const difficultyTargets = getDifficultyTargets(difficulty, numCells.length);

  // Start with strategic givens - ALWAYS ensure at least 1 number per equation for unique solutions
  const strategicGivens = new Set();

  // Start with minimal strategic givens - let intersections provide constraints
  for (const eq of equations) {
    const eqNumbers = [];
    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqNumbers.push({pos: `${r},${c}`, index: i});
      }
    }

    if (eqNumbers.length > 0) {
      // Start with just 1 number per equation - let intersections provide additional constraints
      const shuffledNumbers = eqNumbers.sort(() => Math.random() - 0.5);
      strategicGivens.add(shuffledNumbers[0].pos);

      // For easier difficulties, add one more number to some equations
      if (difficulty === 'easy' && Math.random() < 0.5) {
        if (eqNumbers.length >= 2) {
          strategicGivens.add(shuffledNumbers[1].pos);
        }
      } else if (difficulty === 'medium' && Math.random() < 0.3) {
        if (eqNumbers.length >= 2) {
          strategicGivens.add(shuffledNumbers[1].pos);
        }
      }
    }
  }

  // Let intersection-based solving work - don't force additional givens here

  // For expert level, be more aggressive about accepting minimal puzzles
  if (difficulty === 'expert') {
    // Try to solve with just strategic givens first
    const hasIsolated = hasAnyIsolatedEquations(grid, equations, strategicGivens);
    const isSolvable = canSolvePuzzle(grid, equations, strategicGivens);

    // Accept expert puzzle if it's solvable, even if it has some challenges
    if (isSolvable && strategicGivens.size >= Math.max(1, Math.floor(difficultyTargets.minGivens * 0.5))) {
      return { givens: strategicGivens, difficulty: difficultyTargets };
    }

    // For expert, try adding just 1-2 more strategic clues if needed
    const expertNumberCells = [];
    for (let r = 0; r < 24; r++) {
      for (let c = 0; c < 24; c++) {
        if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {
          expertNumberCells.push({r, c});
        }
      }
    }

    const remaining = expertNumberCells.filter(cell => !strategicGivens.has(`${cell.r},${cell.c}`));
    const shuffled = remaining.sort(() => Math.random() - 0.5);

    let expertGivens = new Set([...strategicGivens]);
    for (let i = 0; i < Math.min(3, shuffled.length); i++) {
      expertGivens.add(`${shuffled[i].r},${shuffled[i].c}`);
      if (canSolvePuzzle(grid, equations, expertGivens) &&
          !isCompleteEquation(grid, equations, expertGivens)) {
        return { givens: expertGivens, difficulty: difficultyTargets };
      }
    }

    // Expert fallback: if we still can't generate, use the regular algorithm but limit maximum
    // This ensures expert puzzles don't fail to generate
    if (strategicGivens.size > 0) {
      // Continue to regular algorithm but with stricter limits for expert
    }
  }

  // Add more givens until we reach the minimum for this difficulty
  const fallbackNumberCells = [];
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {
        fallbackNumberCells.push({r, c});
      }
    }
  }
  const remaining = fallbackNumberCells.filter(cell => !strategicGivens.has(`${cell.r},${cell.c}`));
  const shuffled = remaining.sort(() => Math.random() - 0.5);

  let currentGivens = new Set([...strategicGivens]);
  let addedIndex = 0;

  // Keep adding until we have enough givens and it's properly solvable
  while (addedIndex < shuffled.length) {
    const needsMoreForDifficulty = currentGivens.size < difficultyTargets.minGivens;
    const isSolvable = canSolvePuzzle(grid, equations, currentGivens);
    const hasCompleteEquation = isCompleteEquation(grid, equations, currentGivens);
    const hasIsolated = hasAnyIsolatedEquations(grid, equations, currentGivens);

    // For expert, be much more strict about complete equations
    if (difficulty === 'expert') {
      if (isSolvable && currentGivens.size >= difficultyTargets.minGivens && !hasCompleteEquation) {
        break; // Expert level: accept if solvable with minimal clues, must not have complete equations
      }
      // Expert level: NEVER accept any complete equations, even if isolated
      if (hasCompleteEquation) {
        // Force continue to avoid this configuration
        if (addedIndex >= shuffled.length) break; // Prevent infinite loop
      }
    } else {
      if (!needsMoreForDifficulty && isSolvable && !hasCompleteEquation && !hasIsolated) {
        break; // Other difficulties: standard requirements
      }
    }

    if (addedIndex < shuffled.length) {
      const testGivens = new Set([...currentGivens]);
      testGivens.add(`${shuffled[addedIndex].r},${shuffled[addedIndex].c}`);

      // Only add if it doesn't create a complete equation
      if (!isCompleteEquation(grid, equations, testGivens)) {
        currentGivens.add(`${shuffled[addedIndex].r},${shuffled[addedIndex].c}`);
      }
      addedIndex++;
    } else {
      break;
    }

    // Stop if we exceed maximum for this difficulty and meet all criteria
    if (difficulty === 'expert') {
      // For expert, stop much earlier to keep puzzles challenging
      if (currentGivens.size >= difficultyTargets.maxGivens && canSolvePuzzle(grid, equations, currentGivens)) {
        break; // Expert: stop at max limit if solvable, regardless of other criteria
      }
    } else {
      if (currentGivens.size >= difficultyTargets.maxGivens &&
          canSolvePuzzle(grid, equations, currentGivens) &&
          !isCompleteEquation(grid, equations, currentGivens) &&
          !hasAnyIsolatedEquations(grid, equations, currentGivens)) {
        break;
      }
    }
  }

  // FINAL SAFETY CHECK: Only add givens for truly isolated equations
  for (const eq of equations) {
    const eqNumbers = [];
    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqNumbers.push(`${r},${c}`);
      }
    }

    // Count givens in this equation
    const givenCount = eqNumbers.filter(pos => currentGivens.has(pos)).length;

    // Only enforce minimum givens if equation has NO givens at all
    if (eqNumbers.length > 0 && givenCount === 0) {
      // Ensure at least 1 given to prevent completely unsolvable equations
      currentGivens.add(eqNumbers[0]);
    }
  }

  // OPTIMIZATION: Remove redundant givens from over-constrained equations
  // Example: if we have "36 - 14 = 22" with both 36 and 22 given, we can remove 22
  const optimizedGivens = new Set([...currentGivens]);

  for (const eq of equations) {
    const eqNumbers = [];
    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers (A, B, C)
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqNumbers.push({pos: `${r},${c}`, index: i});
      }
    }

    if (eqNumbers.length === 3) { // A op B = C equation
      const givenPositions = eqNumbers.filter(num => optimizedGivens.has(num.pos));

      // If we have 3 givens (all positions), we can safely remove one
      if (givenPositions.length === 3) {
        // Remove the result (position 4 = C) as it's most redundant
        const resultPos = eqNumbers.find(num => num.index === 4);
        if (resultPos) {
          optimizedGivens.delete(resultPos.pos);
        }
      }
      // If we have exactly 2 givens, check if one can be removed due to intersections
      else if (givenPositions.length === 2) {
        // For each given position, check if it has strong intersection constraints
        for (const givenPos of givenPositions) {
          const [r, c] = givenPos.pos.split(',').map(Number);

          // Count intersections with well-constrained equations
          let strongIntersections = 0;
          for (const otherEq of equations) {
            if (otherEq === eq) continue;

            // Check if this position intersects with the other equation
            for (let j = 0; j < 5; j += 2) {
              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;

              if (otherR === r && otherC === c) {
                // Found intersection! Check if other equation is well-constrained
                const otherPositions = [];
                for (let k = 0; k < 5; k += 2) {
                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;
                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;
                  if (checkR < 24 && checkC < 24) {
                    otherPositions.push(`${checkR},${checkC}`);
                  }
                }
                const otherGivenCount = otherPositions.filter(p => optimizedGivens.has(p)).length;

                // If the intersecting equation has 2+ givens, it provides strong constraint
                if (otherGivenCount >= 2) {
                  strongIntersections++;
                }
                break;
              }
            }
          }

          // If this position has strong intersection constraints, we might be able to remove it
          // But only for non-expert difficulties to avoid making puzzles too hard
          if (strongIntersections >= 1 && difficulty !== 'expert') {
            // Prefer removing the result (C) over operands (A, B) for cleaner puzzles
            if (givenPos.index === 4) { // This is the result position
              optimizedGivens.delete(givenPos.pos);
              break; // Only remove one per equation
            }
          }
        }
      }
    }
  }

  return { givens: optimizedGivens, difficulty: difficultyTargets };
}

function drawCompletedCrossword(model, difficulty) {
  const {grid, equations, optimizedGivens} = model;

  // Use the optimized givens from backward generation
  const givenSet = optimizedGivens || new Set();

  // Find bounds of used cells to crop the display
  const usedCells = [];
  for(let r = 0; r < 24; r++) {
    for(let c = 0; c < 24; c++) {
      if(grid[r][c]) {
        usedCells.push({r, c});
      }
    }
  }

  const minR = Math.min(...usedCells.map(p => p.r));
  const maxR = Math.max(...usedCells.map(p => p.r));
  const minC = Math.min(...usedCells.map(p => p.c));
  const maxC = Math.max(...usedCells.map(p => p.c));

  const gridRows = maxR - minR + 1;
  const gridCols = maxC - minC + 1;

  // Use smaller cell size for better overview of the whole puzzle
  const cellSize = Math.min(32, Math.floor(320 / Math.max(gridRows, gridCols))); // 20% smaller: 40->32, 400->320
  const W = gridCols * cellSize;
  const H = gridRows * cellSize;

  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('width', W);
  svg.setAttribute('height', H);
  svg.innerHTML = '';

  // Draw grid
  for(let r = minR; r <= maxR; r++) {
    for(let c = minC; c <= maxC; c++) {
      const x = (c - minC) * cellSize;
      const y = (r - minR) * cellSize;
      const cell = grid[r][c];

      if(cell) {
        // Draw cell background
        svg.appendChild(t('rect', {
          x, y, width: cellSize, height: cellSize,
          fill: '#fff', stroke: '#000', 'stroke-width': 2
        }));

        // Draw text
        let text = cell.ch;
        if(cell.k === 'num' && !ans.checked) {
          text = givenSet.has(`${r},${c}`) ? cell.ch : '';
        }

        const fontSize = Math.max(12, text.length >= 2 ? cellSize * 0.5 : cellSize * 0.7);
        const textEl = t('text', {
          x: x + cellSize/2,
          y: y + cellSize/2 + fontSize/4,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          'font-size': fontSize,
          'font-family': 'Arial, sans-serif',
          'font-weight': 'bold'
        });
        textEl.textContent = text;
        svg.appendChild(textEl);
      }
    }
  }

  // Draw border
  svg.appendChild(t('rect', {
    x: 0, y: 0, width: W, height: H,
    fill: 'none', stroke: '#000', 'stroke-width': 3
  }));

  // Hide SVG and generate colorful HTML version for screen
  document.getElementById('grid').style.display = 'none';

  // Generate colorful screen and print versions
  generateScreenVersion(grid, givenSet, minR, maxR, minC, maxC);
  generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC);

  // Count number cells for stats
  const numCells = [];
  for(let r = 0; r < 24; r++) {
    for(let c = 0; c < 24; c++) {
      if(grid[r][c] && grid[r][c].k === 'num') {
        numCells.push({r, c});
      }
    }
  }

  const difficultyTargets = getDifficultyTargets(difficulty, numCells.length);
  return {numTotal: numCells.length, actualGivens: givenSet.size, difficulty: difficultyTargets};
}

function drawSimpleCrossword(model, difficulty) {
  const {grid, equations} = model;

  // Collect number cells
  const numCells = [];
  for(let r = 0; r < 24; r++) {
    for(let c = 0; c < 24; c++) {
      if(grid[r][c] && grid[r][c].k === 'num') {
        numCells.push({r, c});
      }
    }
  }

  // Select optimal givens that ensure solvability for the chosen difficulty
  const result = selectOptimalGivens(grid, equations, difficulty);
  const givenSet = result.givens;

  // Find bounds of used cells to crop the display
  const usedCells = [];
  for(let r = 0; r < 24; r++) {
    for(let c = 0; c < 24; c++) {
      if(grid[r][c]) {
        usedCells.push({r, c});
      }
    }
  }

  const minR = Math.min(...usedCells.map(p => p.r));
  const maxR = Math.max(...usedCells.map(p => p.r));
  const minC = Math.min(...usedCells.map(p => p.c));
  const maxC = Math.max(...usedCells.map(p => p.c));

  const gridRows = maxR - minR + 1;
  const gridCols = maxC - minC + 1;

  // Dynamic sizing for both web and print
  const containerWidth = Math.min(window.innerWidth - 120, 900); // Responsive to screen width
  const containerHeight = Math.min(window.innerHeight - 400, 600); // Leave space for controls

  // A4 constraints (210mm x 297mm with safe margins to prevent overflow)
  const a4PortraitWidth = 175;  // 210mm - 35mm margins (safer)
  const a4PortraitHeight = 250; // 297mm - 47mm margins
  const a4LandscapeWidth = 225; // 297mm - 72mm margins (extra safe for landscape)
  const a4LandscapeHeight = 175; // 210mm - 35mm margins (rotated)
  const mmToPx = 3.78; // Approximate conversion

  // Try both orientations and pick the best fit
  const portraitCellSizeByWidth = Math.floor((a4PortraitWidth * mmToPx) / gridCols);
  const portraitCellSizeByHeight = Math.floor((a4PortraitHeight * mmToPx) / gridRows);
  const portraitCellSize = Math.min(portraitCellSizeByWidth, portraitCellSizeByHeight);

  const landscapeCellSizeByWidth = Math.floor((a4LandscapeWidth * mmToPx) / gridCols);
  const landscapeCellSizeByHeight = Math.floor((a4LandscapeHeight * mmToPx) / gridRows);
  const landscapeCellSize = Math.min(landscapeCellSizeByWidth, landscapeCellSizeByHeight);

  // Choose orientation that gives larger cells
  const usePortrait = portraitCellSize >= landscapeCellSize;
  const a4CellSize = Math.max(portraitCellSize, landscapeCellSize);

  // Calculate cell size to fit both web and A4 constraints
  const webCellSizeByWidth = Math.floor(containerWidth / gridCols);
  const webCellSizeByHeight = Math.floor(containerHeight / gridRows);

  // Use web constraints for screen display (separate from print sizing)
  const cellSize = Math.min(webCellSizeByWidth, webCellSizeByHeight, 80); // Screen-optimized size

  // Store orientation for print function
  window.preferredPrintOrientation = usePortrait ? 'portrait' : 'landscape';

  const W = gridCols * cellSize;
  const H = gridRows * cellSize;
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('width', W);
  svg.setAttribute('height', H);
  svg.innerHTML = '';

  // Draw grid
  for(let r = minR; r <= maxR; r++) {
    for(let c = minC; c <= maxC; c++) {
      const x = (c - minC) * cellSize;
      const y = (r - minR) * cellSize;
      const cell = grid[r][c];

      if(cell) {
        // Draw cell background
        svg.appendChild(t('rect', {
          x, y, width: cellSize, height: cellSize,
          fill: '#fff', stroke: '#000', 'stroke-width': 2
        }));

        // Draw text
        let text = cell.ch;
        if(cell.k === 'num' && !ans.checked) {
          text = givenSet.has(`${r},${c}`) ? cell.ch : '';
        }

        const fontSize = Math.max(12, text.length >= 2 ? cellSize * 0.5 : cellSize * 0.7);
        const textEl = t('text', {
          x: x + cellSize/2,
          y: y + cellSize/2 + fontSize/4,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          'font-size': fontSize,
          'font-family': 'Arial, sans-serif',
          'font-weight': 'bold'
        });
        textEl.textContent = text;
        svg.appendChild(textEl);
      }
    }
  }

  // Draw border
  svg.appendChild(t('rect', {
    x: 0, y: 0, width: W, height: H,
    fill: 'none', stroke: '#000', 'stroke-width': 3
  }));

  // Hide SVG and generate colorful HTML version for screen
  document.getElementById('grid').style.display = 'none';

  // Generate colorful screen version
  const screenGrid = document.getElementById('screenGrid');
  const container = document.createElement('div');
  container.className = 'print-grid';

  // Use same cell size as calculated above for consistency
  const gridWidth = (maxC - minC + 1) * cellSize;
  const gridHeight = (maxR - minR + 1) * cellSize;
  container.style.width = gridWidth + 'px';
  container.style.height = gridHeight + 'px';

  let cellCounter = 0;

  // Create colorful cells for screen
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      const gridCell = grid[r][c];

      if (gridCell) {
        const cell = document.createElement('div');
        cell.className = 'print-cell screen-view';

        // Position the cell
        const x = (c - minC) * cellSize;
        const y = (r - minR) * cellSize;
        cell.style.left = x + 'px';
        cell.style.top = y + 'px';
        cell.style.width = cellSize + 'px';
        cell.style.height = cellSize + 'px';
        cell.style.fontSize = Math.max(12, Math.floor(cellSize * 0.4)) + 'px';

        // Add border classes for cells that need right/bottom borders
        const hasRightNeighbor = grid[r] && grid[r][c + 1];
        if (!hasRightNeighbor) cell.classList.add('border-right');

        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];
        if (!hasBottomNeighbor) cell.classList.add('border-bottom');

        // Set content and colors
        let text = gridCell.ch;
        let isGiven = false;

        if (gridCell.k === 'num' && !ans.checked) {
          isGiven = givenSet.has(`${r},${c}`);
          text = isGiven ? gridCell.ch : '';
        }

        cell.textContent = text;

        // Apply colors based on content type
        if (gridCell.k === 'op') {
          switch (gridCell.ch) {
            case '+': cell.classList.add('op-add'); break;
            case '-': cell.classList.add('op-sub'); break;
            case '√ó': cell.classList.add('op-mul'); break;
            case '√∑': cell.classList.add('op-div'); break;
          }
        } else if (gridCell.k === 'eq') {
          cell.classList.add('op-eq');
        } else if (gridCell.k === 'num') {
          if (isGiven && !ans.checked) {
            cell.classList.add('given');
          } else {
            cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');
          }
          cellCounter++;
        }

        container.appendChild(cell);
      }
    }
  }

  screenGrid.innerHTML = '';
  screenGrid.appendChild(container);

  // Generate print version
  generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC);

  return {numTotal: numCells.length, actualGivens: givenSet.size, difficulty: result.difficulty};
}

function generateScreenVersion(grid, givenSet, minR, maxR, minC, maxC) {
  const screenGrid = document.getElementById('screenGrid');
  const container = document.createElement('div');
  container.className = 'print-grid';

  // Calculate container size - smaller for better overview (20% smaller: 30->24)
  const cellSize = 24;
  const gridWidth = (maxC - minC + 1) * cellSize;
  const gridHeight = (maxR - minR + 1) * cellSize;
  container.style.width = gridWidth + 'px';
  container.style.height = gridHeight + 'px';

  let cellCounter = 0;

  // Create colorful cells for screen
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      const gridCell = grid[r][c];

      if (gridCell) {
        const cell = document.createElement('div');
        cell.className = 'print-cell screen-view';

        // Position the cell
        const x = (c - minC) * cellSize;
        const y = (r - minR) * cellSize;
        cell.style.left = x + 'px';
        cell.style.top = y + 'px';
        cell.style.width = cellSize + 'px';
        cell.style.height = cellSize + 'px';
        cell.style.fontSize = Math.floor(cellSize * 0.6) + 'px';

        // Add border classes for cells that need right/bottom borders
        // Check if there's no cell to the right
        const hasRightNeighbor = grid[r] && grid[r][c + 1];
        if (!hasRightNeighbor) cell.classList.add('border-right');

        // Check if there's no cell below
        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];
        if (!hasBottomNeighbor) cell.classList.add('border-bottom');

        // Set content and colors
        let text = gridCell.ch;
        let isGiven = false;

        if (gridCell.k === 'num' && !ans.checked) {
          isGiven = givenSet.has(`${r},${c}`);
          text = isGiven ? gridCell.ch : '';
        }

        cell.textContent = text;

        // Apply colors based on content type
        if (gridCell.k === 'op') {
          switch (gridCell.ch) {
            case '+': cell.classList.add('op-add'); break;
            case '-': cell.classList.add('op-sub'); break;
            case '√ó': cell.classList.add('op-mul'); break;
            case '√∑': cell.classList.add('op-div'); break;
          }
        } else if (gridCell.k === 'eq') {
          cell.classList.add('op-eq');
        } else if (gridCell.k === 'num') {
          if (isGiven && !ans.checked) {
            cell.classList.add('given');
          } else {
            cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');
          }
          cellCounter++;
        }

        container.appendChild(cell);
      }
    }
  }

  screenGrid.innerHTML = '';
  screenGrid.appendChild(container);
}

function generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC) {
  const printGrid = document.getElementById('printGrid');
  const container = document.createElement('div');
  container.className = 'print-grid';

  // Calculate container size for A4 print
  const gridRows = maxR - minR + 1;
  const gridCols = maxC - minC + 1;

  // A4 constraints - use same logic as screen version with safe margins
  const a4PortraitWidth = 175;  // 210mm - 35mm margins (safer)
  const a4PortraitHeight = 250; // 297mm - 47mm margins
  const a4LandscapeWidth = 225; // 297mm - 72mm margins (extra safe for landscape)
  const a4LandscapeHeight = 175; // 210mm - 35mm margins (rotated)
  const mmToPx = 3.78; // Approximate conversion for print

  // Try both orientations and pick the best fit
  const portraitCellSizeByWidth = Math.floor((a4PortraitWidth * mmToPx) / gridCols);
  const portraitCellSizeByHeight = Math.floor((a4PortraitHeight * mmToPx) / gridRows);
  const portraitCellSize = Math.min(portraitCellSizeByWidth, portraitCellSizeByHeight);

  const landscapeCellSizeByWidth = Math.floor((a4LandscapeWidth * mmToPx) / gridCols);
  const landscapeCellSizeByHeight = Math.floor((a4LandscapeHeight * mmToPx) / gridRows);
  const landscapeCellSize = Math.min(landscapeCellSizeByWidth, landscapeCellSizeByHeight);

  // Use the orientation that gives larger cells - maximize A4 usage for print
  // Reduce print size by 10%
  const printCellSize = Math.max(Math.floor(portraitCellSize * 0.9), Math.floor(landscapeCellSize * 0.9), 23); // 10% smaller print
  const usePortrait = portraitCellSize >= landscapeCellSize;

  // Store the orientation decision and print cell size
  window.printOrientation = usePortrait ? 'portrait' : 'landscape';
  window.printCellSize = printCellSize; // Store for print version

  const gridWidth = (maxC - minC + 1) * printCellSize;
  const gridHeight = (maxR - minR + 1) * printCellSize;
  container.style.width = gridWidth + 'px';
  container.style.height = gridHeight + 'px';

  // Only create cells that contain puzzle content
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      const gridCell = grid[r][c];

      if (gridCell) {
        // Only create a cell if it has content
        const cell = document.createElement('div');
        cell.className = 'print-cell';

        // Position the cell using print-optimized size
        const printCellSize = window.printCellSize || cellSize;
        const x = (c - minC) * printCellSize;
        const y = (r - minR) * printCellSize;
        cell.style.left = x + 'px';
        cell.style.top = y + 'px';
        cell.style.width = printCellSize + 'px';
        cell.style.height = printCellSize + 'px';
        cell.style.fontSize = Math.max(12, Math.floor(printCellSize * 0.4)) + 'px';

        // Add border classes for cells that need right/bottom borders
        // Check if there's no cell to the right
        const hasRightNeighbor = grid[r] && grid[r][c + 1];
        if (!hasRightNeighbor) cell.classList.add('border-right');

        // Check if there's no cell below
        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];
        if (!hasBottomNeighbor) cell.classList.add('border-bottom');

        // Set the content
        let text = gridCell.ch;
        if (gridCell.k === 'num' && !ans.checked) {
          text = givenSet.has(`${r},${c}`) ? gridCell.ch : '';
        }
        cell.textContent = text;

        container.appendChild(cell);
      }
    }
  }

  printGrid.innerHTML = '';
  printGrid.appendChild(container);
}

function saveSettings() {
  setCookie('mx_eq', eqSlider.value);
  setCookie('mx_diff', difficultySelect.value);
  setCookie('mx_range', rangePreset.value);
  // no custom range cookies
  setCookie('mx_ops', JSON.stringify({
    add: opAdd.checked,
    sub: opSub.checked,
    mul: opMul.checked,
    div: opDiv.checked
  }));
}

function regenerate(printAfter=false){
  // Show immediate feedback
  stat.textContent='üîÑ Generating puzzle...';
  stat.style.background = '#fff3cd';
  stat.style.color = '#856404';
  stat.style.border = '2px solid #ffeeba';

  // Use setTimeout to ensure UI updates immediately
  setTimeout(() => {
    const numEquations = parseInt(eqSlider.value) || 30;
    const difficulty = difficultySelect.value || 'medium';

    // Check if at least one operation is selected
    const selectedOps = getSelectedOperations();
    if (selectedOps.length === 0) {
      stat.textContent = '‚ö†Ô∏è Please select at least one operation!';
      stat.style.background = '#f8d7da';
      stat.style.color = '#721c24';
      stat.style.border = '2px solid #f5c6cb';
      return;
    }

    saveSettings();

    try {
      // Use backward generation algorithm for better optimal puzzles
      const model = generateBackwardCrossword(numEquations, difficulty);
      if (!model) {
        stat.textContent = '‚ö†Ô∏è Failed to generate puzzle. Please try again.';
        stat.style.background = '#f8d7da';
        stat.style.color = '#721c24';
        stat.style.border = '2px solid #f5c6cb';
        return;
      }

      const meta = drawCompletedCrossword(model, difficulty);
      const percentage = Math.round((meta.actualGivens / meta.numTotal) * 100);
      const range = getNumberRange();

      // Success styling
      stat.style.background = '#d4edda';
      stat.style.color = '#155724';
      stat.style.border = '2px solid #c3e6cb';
      stat.textContent=`‚úÖ Generated ${meta.difficulty.name} puzzle (${range.min}-${range.max}) with ${model.equations.length} equations, showing ${meta.actualGivens}/${meta.numTotal} numbers (${percentage}%)`;

      if(printAfter) setTimeout(() => window.print(), 100);
    } catch(e) {
      console.error('Error generating crossword:', e);
      stat.textContent = '‚ö†Ô∏è Error generating puzzle. Please try again.';
      stat.style.background = '#f8d7da';
      stat.style.color = '#721c24';
      stat.style.border = '2px solid #f5c6cb';
    }
  }, 10); // Small delay to ensure UI updates
}

function printColorVersion() {
  // Create a new window with only the colored crossword
  const printWindow = window.open('', '_blank', 'width=800,height=600');

  // Generate print-optimized colorful version
  const printGridContent = generateColorfulPrintGrid();

  // Get the orientation decision made during puzzle generation
  const orientation = window.printOrientation || 'portrait';

function generateColorfulPrintGrid() {
  const printGrid = document.getElementById('printGrid');
  if (!printGrid || !printGrid.firstChild) return '<div>No puzzle generated</div>';

  // Clone the print grid but add color classes
  const container = printGrid.firstChild.cloneNode(true);
  const cells = container.querySelectorAll('.print-cell');

  let cellCounter = 0;
  cells.forEach(cell => {
    const text = cell.textContent.trim();

    // Add color classes based on content
    if (['+', '-', '√ó', '√∑'].includes(text)) {
      switch (text) {
        case '+': cell.classList.add('op-add'); break;
        case '-': cell.classList.add('op-sub'); break;
        case '√ó': cell.classList.add('op-mul'); break;
        case '√∑': cell.classList.add('op-div'); break;
      }
    } else if (text === '=') {
      cell.classList.add('op-eq');
    } else if (text && !isNaN(text)) {
      // It's a number
      if (cell.style.fontSize && parseInt(cell.style.fontSize) > 15) {
        cell.classList.add('given'); // Larger font means it's a given
      } else {
        cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');
      }
      cellCounter++;
    }
  });

  return container.outerHTML;
}

  printWindow.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Math Crossword - Color Print</title>
      <style>
        * {
          -webkit-print-color-adjust: exact !important;
          color-adjust: exact !important;
          print-color-adjust: exact !important;
        }

        body {
          margin: 20px;
          font-family: Arial, sans-serif;
          background: white;
        }

        .print-grid {
          position: relative;
          margin: 0 auto;
          font-family: Arial, sans-serif;
        }

        .print-cell {
          position: absolute;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: bold;
          box-sizing: border-box;
          border-top: 1px solid #666;
          border-left: 1px solid #666;
        }

        .print-cell.border-right {
          border-right: 1px solid #666;
        }

        .print-cell.border-bottom {
          border-bottom: 1px solid #666;
        }

        .print-cell.op-add {
          background: #e8f5e8 !important;
          color: #4a7c59 !important;
        }
        .print-cell.op-sub {
          background: #fff3e0 !important;
          color: #8d4004 !important;
        }
        .print-cell.op-mul {
          background: #f3e5f5 !important;
          color: #6a1b9a !important;
        }
        .print-cell.op-div {
          background: #e3f2fd !important;
          color: #1565c0 !important;
        }
        .print-cell.op-eq {
          background: #fce4ec !important;
          color: #ad1457 !important;
        }
        .print-cell.num-even {
          background: #f8f9fa !important;
          color: #495057 !important;
        }
        .print-cell.num-odd {
          background: #f1f8e9 !important;
          color: #2e7d32 !important;
        }
        .print-cell.given {
          background: #fff8e1 !important;
          color: #f57c00 !important;
          font-weight: 900 !important;
        }

        @media print {
          * {
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
            print-color-adjust: exact !important;
          }

          @page {
            size: A4 ${orientation};
            margin: 10mm 10mm 13.5mm 10mm; /* top right bottom left */
          }
        }
      </style>
    </head>
    <body>
      <h2 style="text-align: center; margin-bottom: 20px;">Math Crossword Puzzle</h2>
      ${printGridContent}
      <scr` + `ipt>
        window.onload = function() {
          setTimeout(function() {
            window.print();
          }, 100);
        };
      </scr` + `ipt>
    </body>
    </html>
  `);

  printWindow.document.close();
}

// UI
document.getElementById('gen').addEventListener('click',()=>regenerate(false));
document.getElementById('printColor').addEventListener('click',()=>printColorVersion());
ans.addEventListener('change',()=>regenerate(false));
eqSlider.addEventListener('input',()=>{eqOut.textContent=eqSlider.value; saveSettings();});
difficultySelect.addEventListener('change',()=>{saveSettings(); regenerate(false);});
rangePreset.addEventListener('change',()=>{ saveSettings(); regenerate(false); });
opAdd.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opSub.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opMul.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opDiv.addEventListener('change',()=>{saveSettings(); regenerate(false);});

// init
syncFromCookies();
regenerate(false); // Fixed syntax error
</script>

</div>
