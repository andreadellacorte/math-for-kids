<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Crossword Generator - Math Fun for Kids!</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .crossword-container {
            background: #f7fafc;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 3px dashed #cbd5e0;
        }

        .crossword-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 15px 20px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .control-group label {
            font-weight: bold;
            color: #4a5568;
            margin: 0;
        }

        .control-group input[type="range"] {
            width: 120px;
        }

        .control-group output {
            min-width: 30px;
            text-align: center;
            background: #e2e8f0;
            padding: 5px 10px;
            border-radius: 8px;
            font-weight: bold;
        }

        .checkbox-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-control input[type="checkbox"] {
            transform: scale(1.3);
        }

        #grid {
            display: block;
            margin: 20px auto;
            border-radius: 10px;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .crossword-status {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: #e6fffa;
            border: 2px solid #81e6d9;
            border-radius: 10px;
            color: #234e52;
            font-weight: bold;
        }

        @media print {
            .container > *:not(.crossword-container) { display: none; }
            .crossword-controls { display: none; }
            .crossword-status { display: none; }
            .container { padding: 0; margin: 0; box-shadow: none; }
            .crossword-container { border: none; padding: 0; margin: 0; }
            @page { size: A4 portrait; margin: 8mm; }
        }

        @media (max-width: 768px) {
            .crossword-controls {
                flex-direction: column;
                gap: 15px;
            }

            .control-group {
                width: 100%;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-btn">‚Üê Back Home</a>
            <h1>üß© Math Crossword Generator</h1>
        </div>

        <div class="crossword-container">
            <div class="crossword-controls">
                <button id="gen" class="btn">Generate New Puzzle</button>
                <button id="print" class="btn secondary">Print Puzzle</button>

                <div class="control-group">
                    <label>Numbers to show:</label>
                    <input id="givSlider" type="range" min="0" max="15" step="1">
                    <output id="givOut"></output>
                </div>

                <div class="control-group checkbox-control">
                    <label><input id="ans" type="checkbox"> Show Answers</label>
                </div>
            </div>

            <svg id="grid" xmlns="http://www.w3.org/2000/svg"></svg>

            <div id="stat" class="crossword-status"></div>
        </div>
    </div>

<script>
/* Strict, intersecting math crossword
   - Token sequence per strip: [NUM][OP][NUM][=][NUM]
   - Each number is a single cell with value 1‚Äì99
   - Exact equation count and exact givens
   - After every placement, newly completed segments must be valid equations
   - No segment may exceed length 5
   - Final board fully validated before draw
   - Values for sliders persist via cookies
*/

const ROWS=24, COLS=24;
const MAX_TRIES=25000;        // stronger search
const REGEN_ATTEMPTS=250;

const svg=document.getElementById('grid'), ans=document.getElementById('ans');
const givSlider=document.getElementById('givSlider'), givOut=document.getElementById('givOut');
const stat=document.getElementById('stat');

const R=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const pick=a=>a[Math.floor(Math.random()*a.length)];
const inside=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

function setCookie(name,value,days=365){
  const d=new Date(); d.setTime(d.getTime()+days*24*60*60*1000);
  document.cookie=`${name}=${encodeURIComponent(value)};expires=${d.toUTCString()};path=/;SameSite=Lax`;
}
function getCookie(name){
  const m=document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(name+'='));
  return m?decodeURIComponent(m.split('=')[1]):null;
}
function syncFromCookies(){
  const gvC=getCookie('mx_gv');
  givSlider.value = clamp(parseInt(gvC)||3,0,15);   // Start with a few givens
  givOut.textContent = givSlider.value;
}

function empty(){return Array.from({length:ROWS},()=>Array(COLS).fill(null))}

function makeEq(){
  const op=pick(['+','-','√ó','√∑']); let A,B,C;
  for(let i=0;i<1200;i++){
    if(op==='+'){A=R(10,79);B=R(10,79);C=A+B;if(C<=99)return{A,B,C,op}}
    if(op==='-'){A=R(30,99);B=R(10,69);C=A-B;if(C>=1&&C<=99)return{A,B,C,op}}
    if(op==='√ó'){A=R(2,9);B=R(2,9);C=A*B;if(C<=99)return{A,B,C,op}}
    if(op==='√∑'){B=R(2,9);C=R(2,9);A=B*C;if(A<=99)return{A,B,C,op}}
  }
  return {A:12,B:7,C:84,op:'√ó'};
}
function seq(e){return[
  {k:'num',ch:String(e.A)},
  {k:'op', ch:e.op},
  {k:'num',ch:String(e.B)},
  {k:'eq', ch:'='},
  {k:'num',ch:String(e.C)}
];}

function segment(g, r, c, dr, dc){
  // walk to start
  while(inside(r-dr,c-dc) && g[r-dr][c-dc]){ r-=dr; c-=dc; }
  const cells=[];
  let i=0;
  while(inside(r+dr*i,c+dc*i) && g[r+dr*i][c+dc*i]){
    cells.push({r:r+dr*i,c:c+dc*i,cell:g[r+dr*i][c+dc*i]}); i++;
  }
  return cells;
}
function evalOk(a,op,b,c){
  a=+a; b=+b; c=+c;
  if(op==='+') return a+b===c;
  if(op==='-') return a-b===c;
  if(op==='√ó') return a*b===c;
  if(op==='√∑') return b!==0 && a/b===c;
  return false;
}
function validStrip(cells){
  if(cells.length!==5) return false;
  const ks=cells.map(x=>x.cell.k);
  if(ks.join(',')!=='num,op,num,eq,num') return false;
  return evalOk(cells[0].cell.ch,cells[1].cell.ch,cells[2].cell.ch,cells[4].cell.ch);
}

// placement rules: token-by-token match, and no segment > 5, and any completed segment must be valid
function canPlace(g,r,c,dr,dc,s,needIntersect){
  let inter=0;
  const touched=[];
  for(let i=0;i<s.length;i++){
    const rr=r+dr*i, cc=c+dc*i; if(!inside(rr,cc)) return false;
    const cell=g[rr][cc];
    if(cell){
      if(cell.k!==s[i].k || cell.ch!==s[i].ch) return false;
      inter++;
    }
    touched.push([rr,cc]);
  }
  if(needIntersect && inter===0) return false;

  // local validation: for each touched cell, check both directions
  for(const [tr,tc] of touched){
    for(const [xr,xc] of [[0,1],[1,0]]){
      const seg=segment(g, tr, tc, xr, xc);
      // simulate new token where empty
      const idx=seg.findIndex(p=>p.r===tr&&p.c===tc);
      if(idx===-1){
        // tc,tr currently empty in seg view; build a transient segment including new token
        const tmp=segmentWithHypo(g,tr,tc,xr,xc);
        if(tmp.length>5) return false;
        if(tmp.length===5 && !validStrip(tmp)) return false;
      }else{
        if(seg.length>5) return false;
        if(seg.length===5 && !validStrip(seg)) return false;
      }
    }
  }
  return true;
}
function segmentWithHypo(g, r, c, dr, dc){
  // build segment including hypothetical filled cell at r,c (we only call this one when we know r,c is empty)
  // walk back
  let sr=r, sc=c;
  while(inside(sr-dr,sc-dc) && g[sr-dr][sc-dc]){ sr-=dr; sc-=dc; }
  const out=[];
  let i=0;
  while(true){
    const rr=sr+dr*i, cc=sc+dc*i;
    if(!inside(rr,cc)) break;
    const cell = (rr===r && cc===c) ? {k:'__hypo__'} : g[rr][cc];
    if(!cell) break;
    out.push({r:rr,c:cc,cell});
    i++;
  }
  return out;
}
function place(g,r,c,dr,dc,s,id){
  const coords=[];
  for(let i=0;i<s.length;i++){
    const rr=r+dr*i, cc=c+dc*i;
    g[rr][cc]={...(g[rr][cc]||{}),...s[i], id};
    coords.push([rr,cc]);
  }
  return coords;
}

function generateExact(target){
  const g=empty(), placed=[];
  // seed anywhere near center
  for(let seedTry=0; seedTry<300; seedTry++){
    const e0=makeEq(), s0=seq(e0), d0=Math.random()<0.5?'ac':'dn';
    const dr0=d0==='ac'?0:1, dc0=d0==='ac'?1:0;
    const r0=R(6,ROWS-7), c0=R(6,COLS-7);
    if(canPlace(g,r0,c0,dr0,dc0,s0,false)){
      place(g,r0,c0,dr0,dc0,s0,1); placed.push({id:1,eq:e0});
      break;
    }
  }
  if(placed.length===0) return null;

  let id=2, tries=0;
  while(id<=target && tries<MAX_TRIES){
    tries++;
    const e=makeEq(), s=seq(e);
    let best=null;
    for(const dir of ['ac','dn']){
      const dr=dir==='ac'?0:1, dc=dir==='ac'?1:0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlace(g,r,c,dr,dc,s,true)){
            const sc=score(g,r,c,dr,dc,s);
            if(!best || sc>best.sc) best={r,c,dr,dc,sc};
          }
        }
      }
    }
    if(best){
      place(g,best.r,best.c,best.dr,best.dc,s,id);
      placed.push({id,eq:e});
      id++;
    }else{
      return null; // cannot reach target under strict rules
    }
  }
  // final full validation: every contiguous segment must be length 5 and valid
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(!g[r][c]) continue;
      for(const [dr,dc] of [[0,1],[1,0]]){
        const seg=segment(g,r,c,dr,dc);
        if(seg.length>0){
          if(seg.length!==5 || !validStrip(seg)) return null;
        }
      }
    }
  }
  return {g,placed};
}

function score(g,r,c,dr,dc,s){
  // prefer more intersections and centrality
  let inter=0; for(let i=0;i<s.length;i++){ if(g[r+dr*i][c+dc*i]) inter++; }
  const mr=(ROWS-1)/2, mc=(COLS-1)/2;
  const er=r+dr*(s.length-1), ec=c+dc*(s.length-1);
  const dist=Math.hypot((r+er)/2-mr, (c+ec)/2-mc);
  return inter*10 - dist;
}

function cropBounds(g){
  const cells=[]; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(g[r][c]) cells.push([r,c]);
  const minR=Math.min(...cells.map(x=>x[0])), maxR=Math.max(...cells.map(x=>x[0]));
  const minC=Math.min(...cells.map(x=>x[1])), maxC=Math.max(...cells.map(x=>x[1]));
  return {minR,maxR,minC,maxC,rows:maxR-minR+1,cols:maxC-minC+1};
}
function t(tag,attrs){const n=document.createElementNS('http://www.w3.org/2000/svg',tag);for(const k in attrs)n.setAttribute(k,attrs[k]);return n}

function draw(model,givensCount){
  const {g}=model;
  // collect number cells
  const numCells=[];
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const cell=g[r][c]; if(cell && cell.k==='num') numCells.push({r,c});}
  if(givensCount>numCells.length) throw new Error(`requested ${givensCount} givens but only ${numCells.length} number cells exist`);

  // choose exact givens
  const arr=[...numCells]; for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];}
  const givenSet=new Set(arr.slice(0,givensCount).map(p=>p.r+','+p.c));

  const b=cropBounds(g);
  const targetPx=760, cell=Math.max(18, Math.floor(targetPx/b.cols));
  const W=b.cols*cell, H=b.rows*cell;
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('width',W); svg.setAttribute('height',H);
  svg.innerHTML='';

  for(let r=b.minR;r<=b.maxR;r++){
    for(let c=b.minC;c<=b.maxC;c++){
      const cellObj=g[r][c]; if(!cellObj) continue;
      const x=(c-b.minC)*cell, y=(r-b.minR)*cell;
      svg.appendChild(t('rect',{x,y,width:cell,height:cell,fill:'#fff',stroke:'#000','stroke-width':1}));
      let text=cellObj.ch;
      if(cellObj.k==='num' && !ans.checked){ text = givenSet.has(r+','+c) ? cellObj.ch : ''; }
      const fs = (text && text.length>=2) ? Math.floor(cell*0.55) : Math.floor(cell*0.7);
      const node=t('text',{x:x+cell/2,y:y+cell/2+1,'text-anchor':'middle','dominant-baseline':'middle','font-size':fs,'font-family':'sans-serif'});
      node.textContent=text||''; svg.appendChild(node);
    }
  }
  svg.appendChild(t('rect',{x:0,y:0,width:W,height:H,fill:'none',stroke:'#000','stroke-width':2}));

  // adjust givens slider max and persist
  givSlider.max = String(numCells.length);
  if(parseInt(givSlider.value)>numCells.length){
    givSlider.value=String(numCells.length); givOut.textContent=givSlider.value; setCookie('mx_gv', givSlider.value);
  }
  return {numTotal:numCells.length};
}

function createSimpleCrossword() {
  // Create a simple predetermined crossword layout that always works
  const patterns = [
    {
      equations: [
        {across: true, row: 2, col: 1, eq: {A: 12, op: '+', B: 8, C: 20}},
        {across: false, row: 1, col: 3, eq: {A: 15, op: '-', B: 7, C: 8}},
        {across: true, row: 4, col: 2, eq: {A: 6, op: '√ó', B: 4, C: 24}},
      ]
    },
    {
      equations: [
        {across: true, row: 1, col: 2, eq: {A: 9, op: '+', B: 6, C: 15}},
        {across: false, row: 0, col: 4, eq: {A: 20, op: '-', B: 5, C: 15}},
        {across: true, row: 3, col: 1, eq: {A: 7, op: '√ó', B: 3, C: 21}},
        {across: false, row: 1, col: 1, eq: {A: 18, op: '√∑', B: 2, C: 9}},
      ]
    }
  ];

  const pattern = patterns[Math.floor(Math.random() * patterns.length)];
  const grid = Array.from({length: 8}, () => Array(8).fill(null));

  // Place equations
  pattern.equations.forEach((item, id) => {
    const {across, row, col, eq} = item;
    const sequence = [
      {k: 'num', ch: String(eq.A)},
      {k: 'op', ch: eq.op},
      {k: 'num', ch: String(eq.B)},
      {k: 'eq', ch: '='},
      {k: 'num', ch: String(eq.C)}
    ];

    sequence.forEach((cell, i) => {
      const r = across ? row : row + i;
      const c = across ? col + i : col;
      if (r >= 0 && r < 8 && c >= 0 && c < 8) {
        grid[r][c] = {...cell, id: id + 1};
      }
    });
  });

  return {grid, equations: pattern.equations};
}

function drawSimpleCrossword(model, givensCount) {
  const {grid} = model;

  // Collect number cells
  const numCells = [];
  for(let r = 0; r < 8; r++) {
    for(let c = 0; c < 8; c++) {
      if(grid[r][c] && grid[r][c].k === 'num') {
        numCells.push({r, c});
      }
    }
  }

  // Choose givens
  const shuffled = [...numCells].sort(() => Math.random() - 0.5);
  const actualGivens = Math.min(givensCount, numCells.length);
  const givenSet = new Set(shuffled.slice(0, actualGivens).map(p => `${p.r},${p.c}`));

  // Set up SVG
  const cellSize = 50;
  const W = 8 * cellSize;
  const H = 8 * cellSize;
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('width', W);
  svg.setAttribute('height', H);
  svg.innerHTML = '';

  // Draw grid
  for(let r = 0; r < 8; r++) {
    for(let c = 0; c < 8; c++) {
      const x = c * cellSize;
      const y = r * cellSize;
      const cell = grid[r][c];

      if(cell) {
        // Draw cell background
        svg.appendChild(t('rect', {
          x, y, width: cellSize, height: cellSize,
          fill: '#fff', stroke: '#000', 'stroke-width': 2
        }));

        // Draw text
        let text = cell.ch;
        if(cell.k === 'num' && !ans.checked) {
          text = givenSet.has(`${r},${c}`) ? cell.ch : '';
        }

        const fontSize = text.length >= 2 ? cellSize * 0.4 : cellSize * 0.6;
        const textEl = t('text', {
          x: x + cellSize/2,
          y: y + cellSize/2 + fontSize/4,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          'font-size': fontSize,
          'font-family': 'Arial, sans-serif',
          'font-weight': 'bold'
        });
        textEl.textContent = text;
        svg.appendChild(textEl);
      }
    }
  }

  // Draw border
  svg.appendChild(t('rect', {
    x: 0, y: 0, width: W, height: H,
    fill: 'none', stroke: '#000', 'stroke-width': 3
  }));

  return {numTotal: numCells.length};
}

function regenerate(printAfter=false){
  stat.textContent='Generating puzzle...';
  const desiredGivens = Math.max(0, parseInt(givSlider.value)||0);
  setCookie('mx_gv', givSlider.value);

  try {
    const model = createSimpleCrossword();
    const meta = drawSimpleCrossword(model, desiredGivens);
    stat.textContent=`‚úÖ Generated puzzle with ${model.equations.length} equations, showing ${Math.min(desiredGivens, meta.numTotal)}/${meta.numTotal} numbers`;

    // Update givens slider max
    givSlider.max = String(meta.numTotal);
    if(parseInt(givSlider.value) > meta.numTotal) {
      givSlider.value = String(meta.numTotal);
      givOut.textContent = givSlider.value;
      setCookie('mx_gv', givSlider.value);
    }

    if(printAfter) setTimeout(() => window.print(), 100);
  } catch(e) {
    console.error('Error generating crossword:', e);
    stat.textContent = '‚ö†Ô∏è Error generating puzzle. Please try again.';
  }
}

// UI
document.getElementById('gen').addEventListener('click',()=>regenerate(false));
document.getElementById('print').addEventListener('click',()=>window.print());
ans.addEventListener('change',()=>regenerate(false));
givSlider.addEventListener('input',()=>{givOut.textContent=givSlider.value; setCookie('mx_gv', givSlider.value);});

// init
syncFromCookies();
regenerate(false);
</script>
</body>
</html>
