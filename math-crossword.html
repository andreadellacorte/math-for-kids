---
title: "Math Crossword Generator - Math Fun for Kids!"
custom_css: |
    .crossword-container {
        background: #f7fafc;
        border-radius: 15px;
        padding: 30px;
        margin-bottom: 30px;
        border: 3px dashed #cbd5e0;
    }

    .crossword-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 30px;
        align-items: center;
        justify-content: center;
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
        background: white;
        padding: 15px 20px;
        border-radius: 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .control-group label {
        font-weight: bold;
        color: #4a5568;
        margin: 0;
    }

    .control-group input[type="range"] {
        width: 120px;
    }

    .control-group output {
        min-width: 30px;
        text-align: center;
        background: #e2e8f0;
        padding: 5px 10px;
        border-radius: 8px;
        font-weight: bold;
    }

    .checkbox-control {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .checkbox-control input[type="checkbox"] {
        transform: scale(1.3);
    }

    #grid {
        display: block;
        margin: 20px auto;
        border-radius: 10px;
        background: white;
        padding: 20px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    .crossword-status {
        text-align: center;
        margin-top: 20px;
        padding: 15px;
        background: #e6fffa;
        border: 2px solid #81e6d9;
        border-radius: 10px;
        color: #234e52;
        font-weight: bold;
    }

    /* Print grid styles */
    .print-grid {
        position: relative;
        margin: 0 auto;
        font-family: Arial, sans-serif;
    }

    .print-cell {
        position: absolute;
        width: 40px;
        height: 40px;
        background: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        box-sizing: border-box;

        /* Only add borders on specific sides to avoid doubling */
        border-top: 1px solid black;
        border-left: 1px solid black;
    }

    /* Add right border only to rightmost cells */
    .print-cell.border-right {
        border-right: 1px solid black;
    }

    /* Add bottom border only to bottom cells */
    .print-cell.border-bottom {
        border-bottom: 1px solid black;
    }

    /* Colorful screen styles */
    .print-cell.screen-view {
        border-top-color: #666;
        border-left-color: #666;
        transition: all 0.2s ease;
    }

    .print-cell.screen-view.border-right {
        border-right-color: #666;
    }

    .print-cell.screen-view.border-bottom {
        border-bottom-color: #666;
    }

    .print-cell.screen-view:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    /* Operator colors - soft pastels */
    .print-cell.op-add {
        background: #e8f5e8;
        color: #4a7c59;
    }
    .print-cell.op-sub {
        background: #fff3e0;
        color: #8d4004;
    }
    .print-cell.op-mul {
        background: #f3e5f5;
        color: #6a1b9a;
    }
    .print-cell.op-div {
        background: #e3f2fd;
        color: #1565c0;
    }
    .print-cell.op-eq {
        background: #fce4ec;
        color: #ad1457;
    }

    /* Number cell alternating colors */
    .print-cell.num-even {
        background: #f8f9fa;
        color: #495057;
    }
    .print-cell.num-odd {
        background: #f1f8e9;
        color: #2e7d32;
    }

    /* Given number highlight */
    .print-cell.given {
        background: #fff8e1;
        color: #f57c00;
        font-weight: 900;
    }

    @media print {
        /* Hide everything except the print grid */
        .header { display: none !important; }
        .crossword-controls { display: none !important; }
        .crossword-status { display: none !important; }
        .footer { display: none !important; }
        #grid { display: none !important; }

        /* Hide screen version and show print version */
        #screenGrid { display: none !important; }
        #printGrid {
            display: block !important;
            margin: 0 auto !important;
            padding: 20px !important;
        }

        /* Simple color printing approach */
        body {
            -webkit-print-color-adjust: exact;
        }

        /* Clean body and container */
        body {
            background: white !important;
            margin: 0 !important;
            padding: 0 !important;
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
        }

        .container {
            background: white !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            padding: 10mm !important;
            margin: 0 !important;
            min-height: auto !important;
        }

        .crossword-container {
            background: white !important;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            box-shadow: none !important;
            border-radius: 0 !important;
        }

        /* Print grid styles */
        .print-grid {
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
        }

        .print-cell {
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
            border: 2px solid black !important;
            background: white !important;
        }

        /* Page setup - dynamic orientation with minimal margins */
        @page {
            /* Add ~5% extra margin to ensure single-page fit */
            margin: 12mm 12mm 15mm 12mm; /* top right bottom left */
        }

        /* Specific orientation rules */
        @page :first {
            size: A4 portrait;
        }

        @media print and (orientation: landscape) {
            @page {
                size: A4 landscape;
                /* Slightly larger bottom margin for printers */
                margin: 12mm 12mm 16mm 12mm;
            }
        }
    }

    @media (max-width: 768px) {
        .crossword-controls {
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            width: 100%;
            justify-content: space-between;
        }
    }
---
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-btn">‚Üê Back Home</a>
            <h1>üß© Math Crossword Generator</h1>
        </div>

        <div class="crossword-container">
            <div class="crossword-controls">
                <button id="gen" class="btn">Generate New Puzzle</button>
                <button id="printColor" class="btn secondary">Print</button>

                <div class="control-group">
                    <label>Number of equations:</label>
                    <input id="eqSlider" type="range" min="3" max="30" step="1">
                    <output id="eqOut"></output>
                </div>

                <div class="control-group">
                    <label>Difficulty Level:</label>
                    <select id="difficultySelect">
                        <option value="easy">Easy (More clues)</option>
                        <option value="medium" selected>Medium</option>
                        <option value="hard">Hard (Fewer clues)</option>
                        <option value="expert">Expert (Minimal clues)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Number Range:</label>
                    <select id="rangePreset">
                        <option value="0-10">0-10</option>
                        <option value="0-20" selected>0-20</option>
                        <option value="0-50">0-50</option>
                        <option value="10-20">10-20</option>
                        <option value="custom">Custom‚Ä¶</option>
                    </select>
                    <span id="customRange" style="display:none;">
                        <label style="margin-left:8px;">Min</label>
                        <input type="number" id="minRange" value="0" min="0" max="999" style="width:80px;">
                        <label style="margin-left:8px;">Max</label>
                        <input type="number" id="maxRange" value="20" min="1" max="999" style="width:80px;">
                    </span>
                </div>
                <div class="control-group">
                    <label>Digits:</label>
                    <select id="digitsSelect">
                        <option value="auto" selected>Auto</option>
                        <option value="1">1 digit</option>
                        <option value="2">2 digits</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Operations:</label>
                    <div class="checkbox-group">
                        <label><input id="opAdd" type="checkbox" checked> + Addition</label>
                        <label><input id="opSub" type="checkbox" checked> - Subtraction</label>
                        <label><input id="opMul" type="checkbox" checked> √ó Multiplication</label>
                        <label><input id="opDiv" type="checkbox" checked> √∑ Division</label>
                    </div>
                </div>

                <div class="control-group checkbox-control">
                    <label><input id="ans" type="checkbox"> Show Answers</label>
                </div>
            </div>

            <svg id="grid" xmlns="http://www.w3.org/2000/svg" style="display: none;"></svg>

            <!-- Colorful screen version -->
            <div id="screenGrid"></div>

            <!-- Hidden print version using HTML table -->
            <div id="printGrid" style="display: none;"></div>

            <div id="stat" class="crossword-status"></div>
        </div>
    </div>

<script>
/* Strict, intersecting math crossword
   - Token sequence per strip: [NUM][OP][NUM][=][NUM]
   - Each number is a single cell with value 1‚Äì99
   - Exact equation count and exact givens
   - After every placement, newly completed segments must be valid equations
   - No segment may exceed length 5
   - Final board fully validated before draw
   - Values for sliders persist via cookies
*/

const ROWS=24, COLS=24;
const MAX_TRIES=25000;        // stronger search
const REGEN_ATTEMPTS=250;

const svg=document.getElementById('grid'), ans=document.getElementById('ans');
const eqSlider=document.getElementById('eqSlider'), eqOut=document.getElementById('eqOut');
const difficultySelect=document.getElementById('difficultySelect');
const rangePreset=document.getElementById('rangePreset');
const customRange=document.getElementById('customRange');
const minRange=document.getElementById('minRange');
const maxRange=document.getElementById('maxRange');
const digitsSelect=document.getElementById('digitsSelect');
const opAdd=document.getElementById('opAdd'), opSub=document.getElementById('opSub');
const opMul=document.getElementById('opMul'), opDiv=document.getElementById('opDiv');
const stat=document.getElementById('stat');

const R=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const pick=a=>a[Math.floor(Math.random()*a.length)];
const inside=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

function setCookie(name,value,days=365){
  const d=new Date(); d.setTime(d.getTime()+days*24*60*60*1000);
  document.cookie=`${name}=${encodeURIComponent(value)};expires=${d.toUTCString()};path=/;SameSite=Lax`;
}
function getCookie(name){
  const m=document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(name+'='));
  return m?decodeURIComponent(m.split('=')[1]):null;
}
function syncFromCookies(){
  const eqC=getCookie('mx_eq'), diffC=getCookie('mx_diff');
  const rangeC=getCookie('mx_range');
  const rangeMinC=getCookie('mx_range_min');
  const rangeMaxC=getCookie('mx_range_max');
  const digitsC=getCookie('mx_digits');
  const opsC=getCookie('mx_ops');

  eqSlider.value = clamp(parseInt(eqC)||4,3,30);    // Start with 4 equations
  difficultySelect.value = diffC || 'medium';       // Start with medium difficulty
  if(rangeC){
    rangePreset.value = rangeC;
  } else {
    rangePreset.value = '0-20';
  }
  if(rangePreset.value==='custom'){
    customRange.style.display='inline-block';
    minRange.value = clamp(parseInt(rangeMinC)||0,0,999);
    maxRange.value = clamp(parseInt(rangeMaxC)||20,1,999);
  } else {
    customRange.style.display='none';
  }
  digitsSelect.value = digitsC || 'auto';
  eqOut.textContent = eqSlider.value;

  // Restore operation settings
  const ops = opsC ? JSON.parse(opsC) : {add: true, sub: true, mul: true, div: true};
  opAdd.checked = ops.add !== false;
  opSub.checked = ops.sub !== false;
  opMul.checked = ops.mul !== false;
  opDiv.checked = ops.div !== false;
}

function empty(){return Array.from({length:ROWS},()=>Array(COLS).fill(null))}

function seq(e){return[
  {k:'num',ch:String(e.A)},
  {k:'op', ch:e.op},
  {k:'num',ch:String(e.B)},
  {k:'eq', ch:'='},
  {k:'num',ch:String(e.C)}
];}

function segment(g, r, c, dr, dc){
  // walk to start
  while(inside(r-dr,c-dc) && g[r-dr][c-dc]){ r-=dr; c-=dc; }
  const cells=[];
  let i=0;
  while(inside(r+dr*i,c+dc*i) && g[r+dr*i][c+dc*i]){
    cells.push({r:r+dr*i,c:c+dc*i,cell:g[r+dr*i][c+dc*i]}); i++;
  }
  return cells;
}
function evalOk(a,op,b,c){
  a=+a; b=+b; c=+c;
  if(op==='+') return a+b===c;
  if(op==='-') return a-b===c;
  if(op==='√ó') return a*b===c;
  if(op==='√∑') return b!==0 && a/b===c;
  return false;
}
function validStrip(cells){
  if(cells.length!==5) return false;
  const ks=cells.map(x=>x.cell.k);
  if(ks.join(',')!=='num,op,num,eq,num') return false;
  return evalOk(cells[0].cell.ch,cells[1].cell.ch,cells[2].cell.ch,cells[4].cell.ch);
}

// placement rules: token-by-token match, and no segment > 5, and any completed segment must be valid
function canPlace(g,r,c,dr,dc,s,needIntersect){
  let inter=0;
  const touched=[];
  for(let i=0;i<s.length;i++){
    const rr=r+dr*i, cc=c+dc*i; if(!inside(rr,cc)) return false;
    const cell=g[rr][cc];
    if(cell){
      if(cell.k!==s[i].k || cell.ch!==s[i].ch) return false;
      inter++;
    }
    touched.push([rr,cc]);
  }
  if(needIntersect && inter===0) return false;

  // local validation: for each touched cell, check both directions
  for(const [tr,tc] of touched){
    for(const [xr,xc] of [[0,1],[1,0]]){
      const seg=segment(g, tr, tc, xr, xc);
      // simulate new token where empty
      const idx=seg.findIndex(p=>p.r===tr&&p.c===tc);
      if(idx===-1){
        // tc,tr currently empty in seg view; build a transient segment including new token
        const tmp=segmentWithHypo(g,tr,tc,xr,xc);
        if(tmp.length>5) return false;
        if(tmp.length===5 && !validStrip(tmp)) return false;
      }else{
        if(seg.length>5) return false;
        if(seg.length===5 && !validStrip(seg)) return false;
      }
    }
  }
  return true;
}
function segmentWithHypo(g, r, c, dr, dc){
  // build segment including hypothetical filled cell at r,c (we only call this one when we know r,c is empty)
  // walk back
  let sr=r, sc=c;
  while(inside(sr-dr,sc-dc) && g[sr-dr][sc-dc]){ sr-=dr; sc-=dc; }
  const out=[];
  let i=0;
  while(true){
    const rr=sr+dr*i, cc=sc+dc*i;
    if(!inside(rr,cc)) break;
    const cell = (rr===r && cc===c) ? {k:'__hypo__'} : g[rr][cc];
    if(!cell) break;
    out.push({r:rr,c:cc,cell});
    i++;
  }
  return out;
}
function place(g,r,c,dr,dc,s,id){
  const coords=[];
  for(let i=0;i<s.length;i++){
    const rr=r+dr*i, cc=c+dc*i;
    g[rr][cc]={...(g[rr][cc]||{}),...s[i], id};
    coords.push([rr,cc]);
  }
  return coords;
}

function generateExact(target){
  const g=empty(), placed=[];
  // seed anywhere near center
  for(let seedTry=0; seedTry<300; seedTry++){
    const e0=generateRandomEquation(), s0=seq(e0), d0=Math.random()<0.5?'ac':'dn';
    const dr0=d0==='ac'?0:1, dc0=d0==='ac'?1:0;
    const r0=R(6,ROWS-7), c0=R(6,COLS-7);
    if(canPlace(g,r0,c0,dr0,dc0,s0,false)){
      place(g,r0,c0,dr0,dc0,s0,1); placed.push({id:1,eq:e0});
      break;
    }
  }
  if(placed.length===0) return null;

  let id=2, tries=0;
  while(id<=target && tries<MAX_TRIES){
    tries++;
    const e=generateRandomEquation(), s=seq(e);
    let best=null;
    for(const dir of ['ac','dn']){
      const dr=dir==='ac'?0:1, dc=dir==='ac'?1:0;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(canPlace(g,r,c,dr,dc,s,true)){
            const sc=score(g,r,c,dr,dc,s);
            if(!best || sc>best.sc) best={r,c,dr,dc,sc};
          }
        }
      }
    }
    if(best){
      place(g,best.r,best.c,best.dr,best.dc,s,id);
      placed.push({id,eq:e});
      id++;
    }else{
      return null; // cannot reach target under strict rules
    }
  }
  // final full validation: every contiguous segment must be length 5 and valid
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(!g[r][c]) continue;
      for(const [dr,dc] of [[0,1],[1,0]]){
        const seg=segment(g,r,c,dr,dc);
        if(seg.length>0){
          if(seg.length!==5 || !validStrip(seg)) return null;
        }
      }
    }
  }
  return {g,placed};
}

function score(g,r,c,dr,dc,s){
  // prefer more intersections and centrality
  let inter=0; for(let i=0;i<s.length;i++){ if(g[r+dr*i][c+dc*i]) inter++; }
  const mr=(ROWS-1)/2, mc=(COLS-1)/2;
  const er=r+dr*(s.length-1), ec=c+dc*(s.length-1);
  const dist=Math.hypot((r+er)/2-mr, (c+ec)/2-mc);
  return inter*10 - dist;
}

function cropBounds(g){
  const cells=[]; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(g[r][c]) cells.push([r,c]);
  const minR=Math.min(...cells.map(x=>x[0])), maxR=Math.max(...cells.map(x=>x[0]));
  const minC=Math.min(...cells.map(x=>x[1])), maxC=Math.max(...cells.map(x=>x[1]));
  return {minR,maxR,minC,maxC,rows:maxR-minR+1,cols:maxC-minC+1};
}
function t(tag,attrs){const n=document.createElementNS('http://www.w3.org/2000/svg',tag);for(const k in attrs)n.setAttribute(k,attrs[k]);return n}

function draw(model,givensCount){
  const {g}=model;
  // collect number cells
  const numCells=[];
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const cell=g[r][c]; if(cell && cell.k==='num') numCells.push({r,c});}
  if(givensCount>numCells.length) throw new Error(`requested ${givensCount} givens but only ${numCells.length} number cells exist`);

  // choose exact givens
  const arr=[...numCells]; for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];}
  const givenSet=new Set(arr.slice(0,givensCount).map(p=>p.r+','+p.c));

  const b=cropBounds(g);
  const targetPx=720, cell=Math.max(18, Math.floor(targetPx/b.cols));
  const W=b.cols*cell, H=b.rows*cell;
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('width',W); svg.setAttribute('height',H);
  svg.innerHTML='';

  for(let r=b.minR;r<=b.maxR;r++){
    for(let c=b.minC;c<=b.maxC;c++){
      const cellObj=g[r][c]; if(!cellObj) continue;
      const x=(c-b.minC)*cell, y=(r-b.minR)*cell;
      svg.appendChild(t('rect',{x,y,width:cell,height:cell,fill:'#fff',stroke:'#000','stroke-width':1}));
      let text=cellObj.ch;
      if(cellObj.k==='num' && !ans.checked){ text = givenSet.has(r+','+c) ? cellObj.ch : ''; }
      const fs = (text && text.length>=2) ? Math.floor(cell*0.55) : Math.floor(cell*0.7);
      const node=t('text',{x:x+cell/2,y:y+cell/2+1,'text-anchor':'middle','dominant-baseline':'middle','font-size':fs,'font-family':'sans-serif'});
      node.textContent=text||''; svg.appendChild(node);
    }
  }
  svg.appendChild(t('rect',{x:0,y:0,width:W,height:H,fill:'none',stroke:'#000','stroke-width':2}));

  // adjust givens slider max and persist
  givSlider.max = String(numCells.length);
  if(parseInt(givSlider.value)>numCells.length){
    givSlider.value=String(numCells.length); givOut.textContent=givSlider.value; setCookie('mx_gv', givSlider.value);
  }
  return {numTotal:numCells.length};
}

function getSelectedOperations() {
  const ops = [];
  if (opAdd.checked) ops.push('+');
  if (opSub.checked) ops.push('-');
  if (opMul.checked) ops.push('√ó');
  if (opDiv.checked) ops.push('√∑');
  return ops.length > 0 ? ops : ['+']; // Fallback to addition if none selected
}

function getNumberRange() {
  let min=0, max=20;
  const preset = rangePreset.value;
  if(preset==='custom'){
    min = clamp(parseInt(minRange.value)||0,0,999);
    max = clamp(parseInt(maxRange.value)||20,1,999);
    if(max<min) [min,max]=[max,min];
  } else if(/^(\d+)-(\d+)$/.test(preset)){
    const m=preset.match(/^(\d+)-(\d+)$/);
    min = parseInt(m[1]);
    max = parseInt(m[2]);
  }
  // Enforce digits setting (if selected)
  const digits = digitsSelect.value;
  if(digits==='1'){ min = Math.max(min, 0); max = Math.min(max, 9); }
  if(digits==='2'){ min = Math.max(min, 10); max = Math.min(max, 99); }
  // Ensure positive non-zero results where needed
  return { min, max };
}

function validateEquation(A, B, C, op, range = null) {
  A = parseInt(A); B = parseInt(B); C = parseInt(C);

  const currentRange = range || getNumberRange();

  // Ensure all numbers are positive and within range
  if (A < currentRange.min || A > currentRange.max ||
      B < currentRange.min || B > currentRange.max ||
      C < currentRange.min || C > currentRange.max) return false;
  if (!Number.isInteger(A) || !Number.isInteger(B) || !Number.isInteger(C)) return false;
  if (A <= 0 || B <= 0 || C <= 0) return false; // Ensure all positive

  switch (op) {
    case '+': return A + B === C;
    case '-': return A - B === C && C > 0; // Explicitly check result is positive
    case '√ó': return A * B === C;
    case '√∑': return B !== 0 && A / B === C && A % B === 0; // Must be exact division
    default: return false;
  }
}

function generateRandomEquation() {
  const operations = getSelectedOperations();
  const range = getNumberRange();
  const digits = digitsSelect.value;

  for (let attempts = 0; attempts < 300; attempts++) {
    const op = operations[Math.floor(Math.random() * operations.length)];
    let A, B, C;

    switch (op) {
      case '+': {
        // Choose A in range; choose B so that C stays in range
        A = R(range.min, Math.max(range.min, range.max));
        const bMax = range.max - A;
        if (bMax < range.min) continue;
        B = R(range.min, bMax);
        // Optional digits enforcement
        if (digits==='1' && (A>9 || B>9)) continue;
        if (digits==='2' && (A<10 || B<10)) continue;
        C = A + B;
        break; }

      case '-': {
        // Ensure A >= B and all in range
        A = R(Math.max(range.min, 1), range.max);
        B = R(range.min, A);
        if (digits==='1' && (A>9 || B>9)) continue;
        if (digits==='2' && (A<10 || B<10)) continue;
        C = A - B;
        if (C < range.min || C > range.max) continue;
        break; }

      case '√ó': {
        const maxFactor = Math.min(Math.floor(Math.sqrt(range.max)), 20);
        A = R(2, Math.max(2, maxFactor));
        B = R(2, Math.max(2, maxFactor));
        if (digits==='1' && (A>9 || B>9)) continue;
        if (digits==='2' && (A<10 || B<10)) continue;
        C = A * B;
        if (C < range.min || C > range.max) continue;
        break; }

      case '√∑': {
        // Generate exact division within range
        const maxDivisor = Math.min(Math.floor(Math.sqrt(range.max)), 20);
        B = R(2, Math.max(2, maxDivisor));
        C = R(Math.max(range.min, 1), Math.max(range.min, Math.floor(range.max / B)));
        A = B * C;
        if (A < range.min || A > range.max) continue;
        if (digits==='1' && (A>9 || B>9 || C>9)) continue;
        if (digits==='2' && ((A<10 && A!==0) || (B<10 && B!==0) || (C<10 && C!==0))) continue;
        break; }
    }

    if (validateEquation(A, B, C, op, range)) {
      return {A, B, C, op};
    }
  }

  // Guaranteed valid fallback based on range
  const fallbackRange = range.max <= 20 ? {A: 8, B: 4, C: 2} : {A: 12, B: 4, C: 3};
  return {...fallbackRange, op: '√∑'};
}

function getIntersectionValue(grid, r, c) {
  return grid[r] && grid[r][c] && grid[r][c].k === 'num' ? parseInt(grid[r][c].ch) : null;
}

function findValidEquationForConstraints(constraints) {
  // constraints: {pos0: value, pos2: value, pos4: value} where positions are 0=A, 2=B, 4=C
  const operations = ['+', '-', '√ó', '√∑'];

  for (let attempt = 0; attempt < 1000; attempt++) {
    const eq = generateRandomEquation();
    const values = [eq.A, eq.B, eq.C];

    let valid = true;
    for (const [pos, requiredValue] of Object.entries(constraints)) {
      if (values[parseInt(pos) / 2] !== requiredValue) {
        valid = false;
        break;
      }
    }

    if (valid && validateEquation(eq.A, eq.B, eq.C, eq.op)) {
      return eq;
    }
  }

  // If no valid equation found with constraints, try to modify an equation
  if (Object.keys(constraints).length === 1) {
    const [pos, value] = Object.entries(constraints)[0];
    const position = parseInt(pos) / 2;

    // Try to build equation around the constraint
    for (const op of operations) {
      let A, B, C;

      if (position === 0) { // A is constrained
        A = value;
        for (let i = 0; i < 50; i++) {
          if (op === '+') {
            B = Math.floor(Math.random() * 40) + 10;
            C = A + B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '-') {
            B = Math.floor(Math.random() * Math.min(A - 1, 40)) + 1;
            C = A - B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√ó') {
            B = Math.floor(Math.random() * Math.min(9, Math.floor(99/A))) + 2;
            C = A * B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√∑') {
            const divisors = [];
            for (let d = 2; d <= Math.min(9, A); d++) {
              if (A % d === 0) divisors.push(d);
            }
            if (divisors.length > 0) {
              B = divisors[Math.floor(Math.random() * divisors.length)];
              C = A / B;
              if (validateEquation(A, B, C, op)) return {A, B, C, op};
            }
          }
        }
      } else if (position === 1) { // B is constrained
        B = value;
        for (let i = 0; i < 50; i++) {
          if (op === '+') {
            A = Math.floor(Math.random() * (99 - B)) + 10;
            C = A + B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '-') {
            A = Math.floor(Math.random() * 40) + B + 10;
            C = A - B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√ó') {
            A = Math.floor(Math.random() * Math.min(9, Math.floor(99/B))) + 2;
            C = A * B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√∑') {
            C = Math.floor(Math.random() * 10) + 2;
            A = B * C;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          }
        }
      } else if (position === 2) { // C is constrained
        C = value;
        for (let i = 0; i < 50; i++) {
          if (op === '+') {
            A = Math.floor(Math.random() * Math.min(C - 10, 50)) + 10;
            B = C - A;
            if (B >= 10 && B <= 50) return {A, B, C, op};
          } else if (op === '-') {
            B = Math.floor(Math.random() * Math.min(30, C - 1)) + 10;
            A = C + B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          } else if (op === '√ó') {
            const factors = [];
            for (let f = 2; f <= Math.min(9, C); f++) {
              if (C % f === 0 && C/f >= 2 && C/f <= 9) {
                factors.push([f, C/f]);
              }
            }
            if (factors.length > 0) {
              const [A, B] = factors[Math.floor(Math.random() * factors.length)];
              if (validateEquation(A, B, C, op)) return {A, B, C, op};
            }
          } else if (op === '√∑') {
            B = Math.floor(Math.random() * 8) + 2;
            A = C * B;
            if (validateEquation(A, B, C, op)) return {A, B, C, op};
          }
        }
      }
    }
  }

  return generateRandomEquation(); // Fallback
}

function createRandomCrossword(numEquations) {
  const grid = Array.from({length: 24}, () => Array(24).fill(null));
  const equations = [];
  const maxAttempts = 100;

  // Start with first equation in center area
  const firstRow = Math.floor(Math.random() * 8) + 8;
  const firstCol = Math.floor(Math.random() * 8) + 8;
  const firstAcross = Math.random() < 0.5;

  const firstEq = generateRandomEquation();
  const firstSeq = [
    {k: 'num', ch: String(firstEq.A)},
    {k: 'op', ch: firstEq.op},
    {k: 'num', ch: String(firstEq.B)},
    {k: 'eq', ch: '='},
    {k: 'num', ch: String(firstEq.C)}
  ];

  // Place first equation
  for (let i = 0; i < 5; i++) {
    const r = firstAcross ? firstRow : firstRow + i;
    const c = firstAcross ? firstCol + i : firstCol;
    grid[r][c] = {...firstSeq[i], id: 1};
  }

  equations.push({
    across: firstAcross,
    row: firstRow,
    col: firstCol,
    eq: firstEq
  });

  // Add remaining equations
  for (let eqNum = 2; eqNum <= numEquations; eqNum++) {
    let placed = false;

    for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
      // Try to find intersection with existing equations
      const possibleIntersections = [];

      for (let r = 1; r < 23; r++) {
        for (let c = 1; c < 23; c++) {
          if (grid[r][c] && grid[r][c].k === 'num') {
            // Try both orientations
            for (const across of [true, false]) {
              for (let pos = 0; pos < 5; pos += 2) { // Only number positions (0, 2, 4)
                const startR = across ? r : r - pos;
                const startC = across ? c - pos : c;

                // Check if this position would work
                if (startR >= 0 && startR < 24 && startC >= 0 && startC < 24) {
                  let canPlace = true;
                  const constraints = {};

                  // Check all 5 positions of potential equation
                  for (let i = 0; i < 5; i++) {
                    const checkR = across ? startR : startR + i;
                    const checkC = across ? startC + i : startC;

                    if (checkR >= 24 || checkC >= 24) {
                      canPlace = false;
                      break;
                    }

                    const existing = grid[checkR][checkC];
                    if (existing) {
                      if (i === pos) {
                        // This is our intersection point
                        if (existing.k === 'num') {
                          constraints[i] = parseInt(existing.ch);
                        } else {
                          canPlace = false;
                          break;
                        }
                      } else {
                        // Another cell is occupied
                        canPlace = false;
                        break;
                      }
                    }
                  }

                  if (canPlace) {
                    possibleIntersections.push({
                      row: startR,
                      col: startC,
                      across: across,
                      constraints: constraints
                    });
                  }
                }
              }
            }
          }
        }
      }

      if (possibleIntersections.length > 0) {
        // Pick random intersection
        const intersection = possibleIntersections[Math.floor(Math.random() * possibleIntersections.length)];
        const eq = findValidEquationForConstraints(intersection.constraints);

        const sequence = [
          {k: 'num', ch: String(eq.A)},
          {k: 'op', ch: eq.op},
          {k: 'num', ch: String(eq.B)},
          {k: 'eq', ch: '='},
          {k: 'num', ch: String(eq.C)}
        ];

        // Place equation
        for (let i = 0; i < 5; i++) {
          const r = intersection.across ? intersection.row : intersection.row + i;
          const c = intersection.across ? intersection.col + i : intersection.col;
          if (!grid[r][c]) {
            grid[r][c] = {...sequence[i], id: eqNum};
          }
        }

        equations.push({
          across: intersection.across,
          row: intersection.row,
          col: intersection.col,
          eq: eq
        });

        placed = true;
      }
    }

    // If we couldn't place intersecting, try placing separately
    if (!placed) {
      for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
        const row = Math.floor(Math.random() * 16) + 4;
        const col = Math.floor(Math.random() * 16) + 4;
        const across = Math.random() < 0.5;

        let canPlace = true;
        for (let i = 0; i < 5; i++) {
          const r = across ? row : row + i;
          const c = across ? col + i : col;
          if (r >= 24 || c >= 24 || grid[r][c]) {
            canPlace = false;
            break;
          }
        }

        if (canPlace) {
          const eq = generateRandomEquation();
          const sequence = [
            {k: 'num', ch: String(eq.A)},
            {k: 'op', ch: eq.op},
            {k: 'num', ch: String(eq.B)},
            {k: 'eq', ch: '='},
            {k: 'num', ch: String(eq.C)}
          ];

          for (let i = 0; i < 5; i++) {
            const r = across ? row : row + i;
            const c = across ? col + i : col;
            grid[r][c] = {...sequence[i], id: eqNum};
          }

          equations.push({
            across: across,
            row: row,
            col: col,
            eq: eq
          });

          placed = true;
        }
      }
    }
  }

  return {grid, equations};
}

function canSolvePuzzle(grid, equations, givenPositions) {
  // Create a copy of the grid with only givens
  const solveGrid = Array.from({length: 24}, () => Array(24).fill(null));

  // Place only the given cells
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r][c] && givenPositions.has(`${r},${c}`)) {
        solveGrid[r][c] = grid[r][c];
      } else if (grid[r][c]) {
        solveGrid[r][c] = {k: grid[r][c].k, ch: grid[r][c].k === 'num' ? null : grid[r][c].ch, id: grid[r][c].id};
      }
    }
  }

  // Try to solve using constraint propagation
  let changed = true;
  let iterations = 0;
  const maxIterations = 50;

  while (changed && iterations < maxIterations) {
    changed = false;
    iterations++;

    for (const eq of equations) {
      const cells = [];
      for (let i = 0; i < 5; i++) {
        const r = eq.across ? eq.row : eq.row + i;
        const c = eq.across ? eq.col + i : eq.col;
        if (r < 24 && c < 24 && solveGrid[r][c]) {
          cells.push({r, c, cell: solveGrid[r][c], pos: i});
        }
      }

      if (cells.length === 5) {
        // Try to deduce missing values
        const numCells = cells.filter(cell => cell.cell.k === 'num');
        const opCell = cells.find(cell => cell.cell.k === 'op');

        if (opCell && numCells.length >= 2) {
          const knownValues = {};
          const unknownPositions = [];

          for (const numCell of numCells) {
            if (numCell.cell.ch !== null) {
              knownValues[numCell.pos] = parseInt(numCell.cell.ch);
            } else {
              unknownPositions.push(numCell.pos);
            }
          }

          // If we have 2 known values, we can deduce the third
          if (Object.keys(knownValues).length === 2 && unknownPositions.length === 1) {
            const op = opCell.cell.ch;
            const unknownPos = unknownPositions[0];
            let deducedValue = null;

            if (unknownPos === 0) { // Deduce A
              const B = knownValues[2];
              const C = knownValues[4];
              if (op === '+') deducedValue = C - B;
              else if (op === '-') deducedValue = C + B;
              else if (op === '√ó') deducedValue = B !== 0 ? C / B : null;
              else if (op === '√∑') deducedValue = C * B;
            } else if (unknownPos === 2) { // Deduce B
              const A = knownValues[0];
              const C = knownValues[4];
              if (op === '+') deducedValue = C - A;
              else if (op === '-') deducedValue = A - C;
              else if (op === '√ó') deducedValue = A !== 0 ? C / A : null;
              else if (op === '√∑') deducedValue = A !== 0 ? A / C : null;
            } else if (unknownPos === 4) { // Deduce C
              const A = knownValues[0];
              const B = knownValues[2];
              if (op === '+') deducedValue = A + B;
              else if (op === '-') deducedValue = A - B;
              else if (op === '√ó') deducedValue = A * B;
              else if (op === '√∑') deducedValue = B !== 0 ? A / B : null;
            }

            if (deducedValue !== null && deducedValue > 0 && deducedValue <= 99 && Number.isInteger(deducedValue)) {
              const targetCell = cells.find(cell => cell.pos === unknownPos);
              if (targetCell && targetCell.cell.ch === null) {
                targetCell.cell.ch = String(deducedValue);
                changed = true;
              }
            }
          }
        }
      }
    }
  }

  // Check if puzzle is completely solved
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r][c] && grid[r][c].k === 'num') {
        if (!solveGrid[r][c] || solveGrid[r][c].ch === null) {
          return false; // Not solvable
        }
      }
    }
  }

  return true; // Puzzle is solvable
}

function getDifficultyTargets(difficulty, totalNumbers) {
  // Define difficulty levels - Expert requires serious deduction
  const difficultySettings = {
    expert: { min: 0.03, max: 0.08, name: 'Expert' },    // Ultra minimal clues for serious deduction
    hard:   { min: 0.15, max: 0.22, name: 'Hard' },     // Reduced from previous
    medium: { min: 0.25, max: 0.35, name: 'Medium' },   // Unchanged
    easy:   { min: 0.35, max: 0.45, name: 'Easy' }      // Slightly more clues
  };

  const setting = difficultySettings[difficulty] || difficultySettings.medium;
  return {
    minGivens: Math.ceil(totalNumbers * setting.min),
    maxGivens: Math.ceil(totalNumbers * setting.max),
    name: setting.name
  };
}

function isCompleteEquation(grid, equations, givenSet) {
  // Check if any equation has ALL its numbers given (making it trivial)
  for (const eq of equations) {
    const numberPositions = [];
    let givenNumbers = 0;

    // Find all number positions in this equation
    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (the numbers)
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        numberPositions.push({r, c});
        if (givenSet.has(`${r},${c}`)) {
          givenNumbers++;
        }
      }
    }

    // If ALL numbers in this equation are given, it's complete (trivial)
    if (numberPositions.length > 0 && givenNumbers === numberPositions.length) {
      return true;
    }

    // Also check for equations where 4+ out of 5 numbers are given (nearly complete)
    if (numberPositions.length >= 4 && givenNumbers >= numberPositions.length - 1) {
      return true;
    }
  }
  return false;
}

function hasAnyIsolatedEquations(grid, equations, givenSet) {
  // Check if any equation has only 1 given number with no intersecting constraints
  for (const eq of equations) {
    const eqPositions = [];
    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (the numbers)
      const r = eq.across ? eq.row : eq.row + i;
      const c = eq.across ? eq.col + i : eq.col;
      if (r < 24 && c < 24) {
        eqPositions.push({r, c, pos: i});
      }
    }

    // Count givens in this equation
    const givenCount = eqPositions.filter(pos => givenSet.has(`${pos.r},${pos.c}`)).length;

    // If only 1 given, check if there are intersecting constraints
    if (givenCount === 1) {
      let hasIntersectingConstraints = false;

      // Check each number position for intersections with other equations
      for (const pos of eqPositions) {
        if (!givenSet.has(`${pos.r},${pos.c}`)) {
          // This position is not given, check if it intersects with other equations that have constraints
          for (const otherEq of equations) {
            if (otherEq === eq) continue; // Skip same equation

            // Check if this position intersects with the other equation
            for (let j = 0; j < 5; j += 2) {
              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;
              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;

              if (otherR === pos.r && otherC === pos.c) {
                // Found intersection! Check if other equation has enough constraints
                const otherPositions = [];
                for (let k = 0; k < 5; k += 2) {
                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;
                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;
                  if (checkR < 24 && checkC < 24) {
                    otherPositions.push(`${checkR},${checkC}`);
                  }
                }
                const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;
                if (otherGivenCount >= 2) {
                  hasIntersectingConstraints = true;
                  break;
                }
              }
            }
            if (hasIntersectingConstraints) break;
          }
          if (hasIntersectingConstraints) break;
        }
      }

      // If no intersecting constraints found, this equation is isolated
      if (!hasIntersectingConstraints) {
        return true;
      }
    }
  }
  return false;
}

function selectOptimalGivens(grid, equations, difficulty) {
  // Get all number cells for difficulty calculation
  const numCells = [];
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {
        numCells.push({r, c});
      }
    }
  }

  const difficultyTargets = getDifficultyTargets(difficulty, numCells.length);

  // Start with strategic givens - for expert be much more conservative
  const strategicGivens = new Set();

  if (difficulty === 'expert') {
    // Expert: Only add 1 number per equation to keep it challenging
    for (const eq of equations) {
      const eqNumbers = [];
      for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers
        const r = eq.across ? eq.row : eq.row + i;
        const c = eq.across ? eq.col + i : eq.col;
        if (r < 24 && c < 24) {
          eqNumbers.push(`${r},${c}`);
        }
      }

      // Expert: Add only 1 number per equation to start
      if (eqNumbers.length > 0) {
        const shuffledNumbers = eqNumbers.sort(() => Math.random() - 0.5);
        strategicGivens.add(shuffledNumbers[0]);
      }
    }
  } else {
    // Other difficulties: Add 2 numbers per equation for solvability
    for (const eq of equations) {
      const eqNumbers = [];
      for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers
        const r = eq.across ? eq.row : eq.row + i;
        const c = eq.across ? eq.col + i : eq.col;
        if (r < 24 && c < 24) {
          eqNumbers.push(`${r},${c}`);
        }
      }

      // Add at least 2 numbers from each equation to ensure solvability
      if (eqNumbers.length >= 2) {
        const shuffledNumbers = eqNumbers.sort(() => Math.random() - 0.5);
        strategicGivens.add(shuffledNumbers[0]);
        strategicGivens.add(shuffledNumbers[1]);
      } else if (eqNumbers.length > 0) {
        strategicGivens.add(eqNumbers[0]);
      }
    }
  }

  // Ensure no equation has insufficient information - but respect expert difficulty
  if (difficulty !== 'expert') {
    // Non-expert: Ensure at least 2 givens per equation
    for (const eq of equations) {
      const eqNumbers = [];
      for (let i = 0; i < 5; i += 2) {
        const r = eq.across ? eq.row : eq.row + i;
        const c = eq.across ? eq.col + i : eq.col;
        if (r < 24 && c < 24) {
          eqNumbers.push(`${r},${c}`);
        }
      }

      // Count how many givens this equation already has
      const givenCount = eqNumbers.filter(pos => strategicGivens.has(pos)).length;

      // If less than 2 givens, add more until we have at least 2
      if (givenCount < 2) {
        const ungiven = eqNumbers.filter(pos => !strategicGivens.has(pos));
        const needed = 2 - givenCount;
        for (let i = 0; i < Math.min(needed, ungiven.length); i++) {
          strategicGivens.add(ungiven[i]);
        }
      }
    }
  }
  // Expert: Skip this step to keep minimal clues

  // For expert level, be more aggressive about accepting minimal puzzles
  if (difficulty === 'expert') {
    // Try to solve with just strategic givens first
    const hasIsolated = hasAnyIsolatedEquations(grid, equations, strategicGivens);
    const isSolvable = canSolvePuzzle(grid, equations, strategicGivens);

    // Accept expert puzzle if it's solvable, even if it has some challenges
    if (isSolvable && strategicGivens.size >= Math.max(1, Math.floor(difficultyTargets.minGivens * 0.5))) {
      return { givens: strategicGivens, difficulty: difficultyTargets };
    }

    // For expert, try adding just 1-2 more strategic clues if needed
    const expertNumberCells = [];
    for (let r = 0; r < 24; r++) {
      for (let c = 0; c < 24; c++) {
        if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {
          expertNumberCells.push({r, c});
        }
      }
    }

    const remaining = expertNumberCells.filter(cell => !strategicGivens.has(`${cell.r},${cell.c}`));
    const shuffled = remaining.sort(() => Math.random() - 0.5);

    let expertGivens = new Set([...strategicGivens]);
    for (let i = 0; i < Math.min(3, shuffled.length); i++) {
      expertGivens.add(`${shuffled[i].r},${shuffled[i].c}`);
      if (canSolvePuzzle(grid, equations, expertGivens) &&
          !isCompleteEquation(grid, equations, expertGivens)) {
        return { givens: expertGivens, difficulty: difficultyTargets };
      }
    }

    // Expert fallback: if we still can't generate, use the regular algorithm but limit maximum
    // This ensures expert puzzles don't fail to generate
    if (strategicGivens.size > 0) {
      // Continue to regular algorithm but with stricter limits for expert
    }
  }

  // Add more givens until we reach the minimum for this difficulty
  const fallbackNumberCells = [];
  for (let r = 0; r < 24; r++) {
    for (let c = 0; c < 24; c++) {
      if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {
        fallbackNumberCells.push({r, c});
      }
    }
  }
  const remaining = fallbackNumberCells.filter(cell => !strategicGivens.has(`${cell.r},${cell.c}`));
  const shuffled = remaining.sort(() => Math.random() - 0.5);

  let currentGivens = new Set([...strategicGivens]);
  let addedIndex = 0;

  // Keep adding until we have enough givens and it's properly solvable
  while (addedIndex < shuffled.length) {
    const needsMoreForDifficulty = currentGivens.size < difficultyTargets.minGivens;
    const isSolvable = canSolvePuzzle(grid, equations, currentGivens);
    const hasCompleteEquation = isCompleteEquation(grid, equations, currentGivens);
    const hasIsolated = hasAnyIsolatedEquations(grid, equations, currentGivens);

    // For expert, be much more strict about complete equations
    if (difficulty === 'expert') {
      if (isSolvable && currentGivens.size >= difficultyTargets.minGivens && !hasCompleteEquation) {
        break; // Expert level: accept if solvable with minimal clues, must not have complete equations
      }
      // Expert level: NEVER accept any complete equations, even if isolated
      if (hasCompleteEquation) {
        // Force continue to avoid this configuration
        if (addedIndex >= shuffled.length) break; // Prevent infinite loop
      }
    } else {
      if (!needsMoreForDifficulty && isSolvable && !hasCompleteEquation && !hasIsolated) {
        break; // Other difficulties: standard requirements
      }
    }

    if (addedIndex < shuffled.length) {
      const testGivens = new Set([...currentGivens]);
      testGivens.add(`${shuffled[addedIndex].r},${shuffled[addedIndex].c}`);

      // Only add if it doesn't create a complete equation
      if (!isCompleteEquation(grid, equations, testGivens)) {
        currentGivens.add(`${shuffled[addedIndex].r},${shuffled[addedIndex].c}`);
      }
      addedIndex++;
    } else {
      break;
    }

    // Stop if we exceed maximum for this difficulty and meet all criteria
    if (difficulty === 'expert') {
      // For expert, stop much earlier to keep puzzles challenging
      if (currentGivens.size >= difficultyTargets.maxGivens && canSolvePuzzle(grid, equations, currentGivens)) {
        break; // Expert: stop at max limit if solvable, regardless of other criteria
      }
    } else {
      if (currentGivens.size >= difficultyTargets.maxGivens &&
          canSolvePuzzle(grid, equations, currentGivens) &&
          !isCompleteEquation(grid, equations, currentGivens) &&
          !hasAnyIsolatedEquations(grid, equations, currentGivens)) {
        break;
      }
    }
  }

  return { givens: currentGivens, difficulty: difficultyTargets };
}

function drawSimpleCrossword(model, difficulty) {
  const {grid, equations} = model;

  // Collect number cells
  const numCells = [];
  for(let r = 0; r < 24; r++) {
    for(let c = 0; c < 24; c++) {
      if(grid[r][c] && grid[r][c].k === 'num') {
        numCells.push({r, c});
      }
    }
  }

  // Select optimal givens that ensure solvability for the chosen difficulty
  const result = selectOptimalGivens(grid, equations, difficulty);
  const givenSet = result.givens;

  // Find bounds of used cells to crop the display
  const usedCells = [];
  for(let r = 0; r < 24; r++) {
    for(let c = 0; c < 24; c++) {
      if(grid[r][c]) {
        usedCells.push({r, c});
      }
    }
  }

  const minR = Math.min(...usedCells.map(p => p.r));
  const maxR = Math.max(...usedCells.map(p => p.r));
  const minC = Math.min(...usedCells.map(p => p.c));
  const maxC = Math.max(...usedCells.map(p => p.c));

  const gridRows = maxR - minR + 1;
  const gridCols = maxC - minC + 1;

  // Dynamic sizing for both web and print
  const containerWidth = Math.min(window.innerWidth - 120, 900); // Responsive to screen width
  const containerHeight = Math.min(window.innerHeight - 400, 600); // Leave space for controls

  // A4 constraints (210mm x 297mm with safe margins to prevent overflow)
  const a4PortraitWidth = 175;  // 210mm - 35mm margins (safer)
  const a4PortraitHeight = 250; // 297mm - 47mm margins
  const a4LandscapeWidth = 225; // 297mm - 72mm margins (extra safe for landscape)
  const a4LandscapeHeight = 175; // 210mm - 35mm margins (rotated)
  const mmToPx = 3.78; // Approximate conversion

  // Try both orientations and pick the best fit
  const portraitCellSizeByWidth = Math.floor((a4PortraitWidth * mmToPx) / gridCols);
  const portraitCellSizeByHeight = Math.floor((a4PortraitHeight * mmToPx) / gridRows);
  const portraitCellSize = Math.min(portraitCellSizeByWidth, portraitCellSizeByHeight);

  const landscapeCellSizeByWidth = Math.floor((a4LandscapeWidth * mmToPx) / gridCols);
  const landscapeCellSizeByHeight = Math.floor((a4LandscapeHeight * mmToPx) / gridRows);
  const landscapeCellSize = Math.min(landscapeCellSizeByWidth, landscapeCellSizeByHeight);

  // Choose orientation that gives larger cells
  const usePortrait = portraitCellSize >= landscapeCellSize;
  const a4CellSize = Math.max(portraitCellSize, landscapeCellSize);

  // Calculate cell size to fit both web and A4 constraints
  const webCellSizeByWidth = Math.floor(containerWidth / gridCols);
  const webCellSizeByHeight = Math.floor(containerHeight / gridRows);

  // Use web constraints for screen display (separate from print sizing)
  const cellSize = Math.min(webCellSizeByWidth, webCellSizeByHeight, 80); // Screen-optimized size

  // Store orientation for print function
  window.preferredPrintOrientation = usePortrait ? 'portrait' : 'landscape';

  const W = gridCols * cellSize;
  const H = gridRows * cellSize;
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('width', W);
  svg.setAttribute('height', H);
  svg.innerHTML = '';

  // Draw grid
  for(let r = minR; r <= maxR; r++) {
    for(let c = minC; c <= maxC; c++) {
      const x = (c - minC) * cellSize;
      const y = (r - minR) * cellSize;
      const cell = grid[r][c];

      if(cell) {
        // Draw cell background
        svg.appendChild(t('rect', {
          x, y, width: cellSize, height: cellSize,
          fill: '#fff', stroke: '#000', 'stroke-width': 2
        }));

        // Draw text
        let text = cell.ch;
        if(cell.k === 'num' && !ans.checked) {
          text = givenSet.has(`${r},${c}`) ? cell.ch : '';
        }

        const fontSize = Math.max(12, text.length >= 2 ? cellSize * 0.5 : cellSize * 0.7);
        const textEl = t('text', {
          x: x + cellSize/2,
          y: y + cellSize/2 + fontSize/4,
          'text-anchor': 'middle',
          'dominant-baseline': 'middle',
          'font-size': fontSize,
          'font-family': 'Arial, sans-serif',
          'font-weight': 'bold'
        });
        textEl.textContent = text;
        svg.appendChild(textEl);
      }
    }
  }

  // Draw border
  svg.appendChild(t('rect', {
    x: 0, y: 0, width: W, height: H,
    fill: 'none', stroke: '#000', 'stroke-width': 3
  }));

  // Hide SVG and generate colorful HTML version for screen
  document.getElementById('grid').style.display = 'none';

  // Generate colorful screen version
  const screenGrid = document.getElementById('screenGrid');
  const container = document.createElement('div');
  container.className = 'print-grid';

  // Use same cell size as calculated above for consistency
  const gridWidth = (maxC - minC + 1) * cellSize;
  const gridHeight = (maxR - minR + 1) * cellSize;
  container.style.width = gridWidth + 'px';
  container.style.height = gridHeight + 'px';

  let cellCounter = 0;

  // Create colorful cells for screen
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      const gridCell = grid[r][c];

      if (gridCell) {
        const cell = document.createElement('div');
        cell.className = 'print-cell screen-view';

        // Position the cell
        const x = (c - minC) * cellSize;
        const y = (r - minR) * cellSize;
        cell.style.left = x + 'px';
        cell.style.top = y + 'px';
        cell.style.width = cellSize + 'px';
        cell.style.height = cellSize + 'px';
        cell.style.fontSize = Math.max(12, Math.floor(cellSize * 0.4)) + 'px';

        // Add border classes for cells that need right/bottom borders
        const hasRightNeighbor = grid[r] && grid[r][c + 1];
        if (!hasRightNeighbor) cell.classList.add('border-right');

        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];
        if (!hasBottomNeighbor) cell.classList.add('border-bottom');

        // Set content and colors
        let text = gridCell.ch;
        let isGiven = false;

        if (gridCell.k === 'num' && !ans.checked) {
          isGiven = givenSet.has(`${r},${c}`);
          text = isGiven ? gridCell.ch : '';
        }

        cell.textContent = text;

        // Apply colors based on content type
        if (gridCell.k === 'op') {
          switch (gridCell.ch) {
            case '+': cell.classList.add('op-add'); break;
            case '-': cell.classList.add('op-sub'); break;
            case '√ó': cell.classList.add('op-mul'); break;
            case '√∑': cell.classList.add('op-div'); break;
          }
        } else if (gridCell.k === 'eq') {
          cell.classList.add('op-eq');
        } else if (gridCell.k === 'num') {
          if (isGiven && !ans.checked) {
            cell.classList.add('given');
          } else {
            cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');
          }
          cellCounter++;
        }

        container.appendChild(cell);
      }
    }
  }

  screenGrid.innerHTML = '';
  screenGrid.appendChild(container);

  // Generate print version
  generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC);

  return {numTotal: numCells.length, actualGivens: givenSet.size, difficulty: result.difficulty};
}

function generateScreenVersion(grid, givenSet, minR, maxR, minC, maxC) {
  const screenGrid = document.getElementById('screenGrid');
  const container = document.createElement('div');
  container.className = 'print-grid';

  // Calculate container size
  const cellSize = 50;
  const gridWidth = (maxC - minC + 1) * cellSize;
  const gridHeight = (maxR - minR + 1) * cellSize;
  container.style.width = gridWidth + 'px';
  container.style.height = gridHeight + 'px';

  let cellCounter = 0;

  // Create colorful cells for screen
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      const gridCell = grid[r][c];

      if (gridCell) {
        const cell = document.createElement('div');
        cell.className = 'print-cell screen-view';

        // Position the cell
        const x = (c - minC) * colorCellSize;
        const y = (r - minR) * colorCellSize;
        cell.style.left = x + 'px';
        cell.style.top = y + 'px';
        cell.style.width = '50px';
        cell.style.height = '50px';
        cell.style.fontSize = '18px';

        // Add border classes for cells that need right/bottom borders
        // Check if there's no cell to the right
        const hasRightNeighbor = grid[r] && grid[r][c + 1];
        if (!hasRightNeighbor) cell.classList.add('border-right');

        // Check if there's no cell below
        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];
        if (!hasBottomNeighbor) cell.classList.add('border-bottom');

        // Set content and colors
        let text = gridCell.ch;
        let isGiven = false;

        if (gridCell.k === 'num' && !ans.checked) {
          isGiven = givenSet.has(`${r},${c}`);
          text = isGiven ? gridCell.ch : '';
        }

        cell.textContent = text;

        // Apply colors based on content type
        if (gridCell.k === 'op') {
          switch (gridCell.ch) {
            case '+': cell.classList.add('op-add'); break;
            case '-': cell.classList.add('op-sub'); break;
            case '√ó': cell.classList.add('op-mul'); break;
            case '√∑': cell.classList.add('op-div'); break;
          }
        } else if (gridCell.k === 'eq') {
          cell.classList.add('op-eq');
        } else if (gridCell.k === 'num') {
          if (isGiven && !ans.checked) {
            cell.classList.add('given');
          } else {
            cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');
          }
          cellCounter++;
        }

        container.appendChild(cell);
      }
    }
  }

  screenGrid.innerHTML = '';
  screenGrid.appendChild(container);
}

function generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC) {
  const printGrid = document.getElementById('printGrid');
  const container = document.createElement('div');
  container.className = 'print-grid';

  // Calculate container size for A4 print
  const gridRows = maxR - minR + 1;
  const gridCols = maxC - minC + 1;

  // A4 constraints - use same logic as screen version with safe margins
  const a4PortraitWidth = 175;  // 210mm - 35mm margins (safer)
  const a4PortraitHeight = 250; // 297mm - 47mm margins
  const a4LandscapeWidth = 225; // 297mm - 72mm margins (extra safe for landscape)
  const a4LandscapeHeight = 175; // 210mm - 35mm margins (rotated)
  const mmToPx = 3.78; // Approximate conversion for print

  // Try both orientations and pick the best fit
  const portraitCellSizeByWidth = Math.floor((a4PortraitWidth * mmToPx) / gridCols);
  const portraitCellSizeByHeight = Math.floor((a4PortraitHeight * mmToPx) / gridRows);
  const portraitCellSize = Math.min(portraitCellSizeByWidth, portraitCellSizeByHeight);

  const landscapeCellSizeByWidth = Math.floor((a4LandscapeWidth * mmToPx) / gridCols);
  const landscapeCellSizeByHeight = Math.floor((a4LandscapeHeight * mmToPx) / gridRows);
  const landscapeCellSize = Math.min(landscapeCellSizeByWidth, landscapeCellSizeByHeight);

  // Use the orientation that gives larger cells - maximize A4 usage for print
  const printCellSize = Math.max(portraitCellSize, landscapeCellSize, 25); // Larger minimum for print
  const usePortrait = portraitCellSize >= landscapeCellSize;

  // Store the orientation decision and print cell size
  window.printOrientation = usePortrait ? 'portrait' : 'landscape';
  window.printCellSize = printCellSize; // Store for print version

  const gridWidth = (maxC - minC + 1) * printCellSize;
  const gridHeight = (maxR - minR + 1) * printCellSize;
  container.style.width = gridWidth + 'px';
  container.style.height = gridHeight + 'px';

  // Only create cells that contain puzzle content
  for (let r = minR; r <= maxR; r++) {
    for (let c = minC; c <= maxC; c++) {
      const gridCell = grid[r][c];

      if (gridCell) {
        // Only create a cell if it has content
        const cell = document.createElement('div');
        cell.className = 'print-cell';

        // Position the cell using print-optimized size
        const printCellSize = window.printCellSize || cellSize;
        const x = (c - minC) * printCellSize;
        const y = (r - minR) * printCellSize;
        cell.style.left = x + 'px';
        cell.style.top = y + 'px';
        cell.style.width = printCellSize + 'px';
        cell.style.height = printCellSize + 'px';
        cell.style.fontSize = Math.max(12, Math.floor(printCellSize * 0.4)) + 'px';

        // Add border classes for cells that need right/bottom borders
        // Check if there's no cell to the right
        const hasRightNeighbor = grid[r] && grid[r][c + 1];
        if (!hasRightNeighbor) cell.classList.add('border-right');

        // Check if there's no cell below
        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];
        if (!hasBottomNeighbor) cell.classList.add('border-bottom');

        // Set the content
        let text = gridCell.ch;
        if (gridCell.k === 'num' && !ans.checked) {
          text = givenSet.has(`${r},${c}`) ? gridCell.ch : '';
        }
        cell.textContent = text;

        container.appendChild(cell);
      }
    }
  }

  printGrid.innerHTML = '';
  printGrid.appendChild(container);
}

function saveSettings() {
  setCookie('mx_eq', eqSlider.value);
  setCookie('mx_diff', difficultySelect.value);
  setCookie('mx_range', rangePreset.value);
  if (rangePreset.value === 'custom') {
    setCookie('mx_range_min', minRange.value);
    setCookie('mx_range_max', maxRange.value);
  }
  setCookie('mx_digits', digitsSelect.value);
  setCookie('mx_ops', JSON.stringify({
    add: opAdd.checked,
    sub: opSub.checked,
    mul: opMul.checked,
    div: opDiv.checked
  }));
}

function regenerate(printAfter=false){
  stat.textContent='Generating puzzle...';
  const numEquations = parseInt(eqSlider.value) || 4;
  const difficulty = difficultySelect.value || 'medium';

  // Check if at least one operation is selected
  const selectedOps = getSelectedOperations();
  if (selectedOps.length === 0) {
    stat.textContent = '‚ö†Ô∏è Please select at least one operation!';
    return;
  }

  saveSettings();

  try {
    const model = createRandomCrossword(numEquations);
    const meta = drawSimpleCrossword(model, difficulty);
    const percentage = Math.round((meta.actualGivens / meta.numTotal) * 100);
    const range = getNumberRange();
    stat.textContent=`‚úÖ Generated ${meta.difficulty.name} puzzle (${range.min}-${range.max}) with ${model.equations.length} equations, showing ${meta.actualGivens}/${meta.numTotal} numbers (${percentage}%)`;

    if(printAfter) setTimeout(() => window.print(), 100);
  } catch(e) {
    console.error('Error generating crossword:', e);
    stat.textContent = '‚ö†Ô∏è Error generating puzzle. Please try again.';
  }
}

function printColorVersion() {
  // Create a new window with only the colored crossword
  const printWindow = window.open('', '_blank', 'width=800,height=600');

  // Generate print-optimized colorful version
  const printGridContent = generateColorfulPrintGrid();

  // Get the orientation decision made during puzzle generation
  const orientation = window.printOrientation || 'portrait';

function generateColorfulPrintGrid() {
  const printGrid = document.getElementById('printGrid');
  if (!printGrid || !printGrid.firstChild) return '<div>No puzzle generated</div>';

  // Clone the print grid but add color classes
  const container = printGrid.firstChild.cloneNode(true);
  const cells = container.querySelectorAll('.print-cell');

  let cellCounter = 0;
  cells.forEach(cell => {
    const text = cell.textContent.trim();

    // Add color classes based on content
    if (['+', '-', '√ó', '√∑'].includes(text)) {
      switch (text) {
        case '+': cell.classList.add('op-add'); break;
        case '-': cell.classList.add('op-sub'); break;
        case '√ó': cell.classList.add('op-mul'); break;
        case '√∑': cell.classList.add('op-div'); break;
      }
    } else if (text === '=') {
      cell.classList.add('op-eq');
    } else if (text && !isNaN(text)) {
      // It's a number
      if (cell.style.fontSize && parseInt(cell.style.fontSize) > 15) {
        cell.classList.add('given'); // Larger font means it's a given
      } else {
        cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');
      }
      cellCounter++;
    }
  });

  return container.outerHTML;
}

  printWindow.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Math Crossword - Color Print</title>
      <style>
        * {
          -webkit-print-color-adjust: exact !important;
          color-adjust: exact !important;
          print-color-adjust: exact !important;
        }

        body {
          margin: 20px;
          font-family: Arial, sans-serif;
          background: white;
        }

        .print-grid {
          position: relative;
          margin: 0 auto;
          font-family: Arial, sans-serif;
        }

        .print-cell {
          position: absolute;
          display: flex;
          align-items: center;
          justify-content: center;
          font-weight: bold;
          box-sizing: border-box;
          border-top: 1px solid #666;
          border-left: 1px solid #666;
        }

        .print-cell.border-right {
          border-right: 1px solid #666;
        }

        .print-cell.border-bottom {
          border-bottom: 1px solid #666;
        }

        .print-cell.op-add {
          background: #e8f5e8 !important;
          color: #4a7c59 !important;
        }
        .print-cell.op-sub {
          background: #fff3e0 !important;
          color: #8d4004 !important;
        }
        .print-cell.op-mul {
          background: #f3e5f5 !important;
          color: #6a1b9a !important;
        }
        .print-cell.op-div {
          background: #e3f2fd !important;
          color: #1565c0 !important;
        }
        .print-cell.op-eq {
          background: #fce4ec !important;
          color: #ad1457 !important;
        }
        .print-cell.num-even {
          background: #f8f9fa !important;
          color: #495057 !important;
        }
        .print-cell.num-odd {
          background: #f1f8e9 !important;
          color: #2e7d32 !important;
        }
        .print-cell.given {
          background: #fff8e1 !important;
          color: #f57c00 !important;
          font-weight: 900 !important;
        }

        @media print {
          * {
            -webkit-print-color-adjust: exact !important;
            color-adjust: exact !important;
            print-color-adjust: exact !important;
          }

          @page {
            size: A4 ${orientation};
            margin: 10mm 10mm 13.5mm 10mm; /* top right bottom left */
          }
        }
      </style>
    </head>
    <body>
      <h2 style="text-align: center; margin-bottom: 20px;">Math Crossword Puzzle</h2>
      ${printGridContent}
      <scr` + `ipt>
        window.onload = function() {
          setTimeout(function() {
            window.print();
          }, 100);
        };
      </scr` + `ipt>
    </body>
    </html>
  `);

  printWindow.document.close();
}

// UI
document.getElementById('gen').addEventListener('click',()=>regenerate(false));
document.getElementById('printColor').addEventListener('click',()=>printColorVersion());
ans.addEventListener('change',()=>regenerate(false));
eqSlider.addEventListener('input',()=>{eqOut.textContent=eqSlider.value; saveSettings();});
difficultySelect.addEventListener('change',()=>{saveSettings(); regenerate(false);});
rangePreset.addEventListener('change',()=>{
  customRange.style.display = (rangePreset.value==='custom') ? 'inline-block' : 'none';
  saveSettings();
  regenerate(false);
});
minRange.addEventListener('input',()=>{saveSettings();});
maxRange.addEventListener('input',()=>{saveSettings();});
digitsSelect.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opAdd.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opSub.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opMul.addEventListener('change',()=>{saveSettings(); regenerate(false);});
opDiv.addEventListener('change',()=>{saveSettings(); regenerate(false);});

// init
syncFromCookies();
regenerate(false); // Fixed syntax error
</script>

</div>
