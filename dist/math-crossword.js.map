{
  "version": 3,
  "sources": ["../js/games/math-crossword.ts"],
  "sourcesContent": ["/**\n * math-crossword game logic\n * Migrated from math-crossword.html\n */\n\n// Import utilities\nimport { setCookie, getCookie } from '../storage-utils';\n\n// Declare globals that might be used\ndeclare const window: any;\ndeclare const document: any;\n\n/* Strict, intersecting math crossword\n   - Token sequence per strip: [NUM][OP][NUM][=][NUM]\n   - Each number is a single cell with value 1\u201399\n   - Exact equation count and exact givens\n   - After every placement, newly completed segments must be valid equations\n   - No segment may exceed length 5\n   - Final board fully validated before draw\n   - Values for sliders persist via cookies\n*/\n\nconst ROWS=24, COLS=24;\nconst MAX_TRIES=25000;        // stronger search\nconst REGEN_ATTEMPTS=250;\n\nconst svg=document.getElementById('grid'), ans=document.getElementById('ans');\nconst eqSlider=document.getElementById('eqSlider'), eqOut=document.getElementById('eqOut');\nconst difficultySelect=document.getElementById('difficultySelect');\nconst rangePreset=document.getElementById('rangePreset');\nconst opAdd=document.getElementById('opAdd'), opSub=document.getElementById('opSub');\nconst opMul=document.getElementById('opMul'), opDiv=document.getElementById('opDiv');\nconst stat=document.getElementById('stat');\n\nconst R=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;\nconst pick=a=>a[Math.floor(Math.random()*a.length)];\nconst inside=(r,c)=>r>=0&&r<ROWS&&c>=0&&c<COLS;\nconst clamp=(x,a,b)=>Math.max(a,Math.min(b,x));\n\nfunction setCookie(name,value,days=365){\n  const d=new Date(); d.setTime(d.getTime()+days*24*60*60*1000);\n  document.cookie=`${name}=${encodeURIComponent(value)};expires=${d.toUTCString()};path=/;SameSite=Lax`;\n}\nfunction getCookie(name){\n  const m=document.cookie.split(';').map(s=>s.trim()).find(s=>s.startsWith(name+'='));\n  return m?decodeURIComponent(m.split('=')[1]):null;\n}\nfunction syncFromCookies(){\n  const eqC=getCookie('mx_eq'), diffC=getCookie('mx_diff');\n  const rangeC=getCookie('mx_range');\n  const opsC=getCookie('mx_ops');\n\n  eqSlider.value = clamp(parseInt(eqC)||30,3,50);    // Start with 30 equations\n  difficultySelect.value = diffC || 'medium';       // Start with medium difficulty\n  if(rangeC){\n    rangePreset.value = rangeC;\n  } else {\n    rangePreset.value = '0-20';\n  }\n  // no custom range UI\n  eqOut.textContent = eqSlider.value;\n\n  // Restore operation settings\n  const ops = opsC ? JSON.parse(opsC) : {add: true, sub: true, mul: true, div: true};\n  opAdd.checked = ops.add !== false;\n  opSub.checked = ops.sub !== false;\n  opMul.checked = ops.mul !== false;\n  opDiv.checked = ops.div !== false;\n}\n\nfunction empty(){return Array.from({length:ROWS},()=>Array(COLS).fill(null))}\n\nfunction seq(e){return[\n  {k:'num',ch:String(e.A)},\n  {k:'op', ch:e.op},\n  {k:'num',ch:String(e.B)},\n  {k:'eq', ch:'='},\n  {k:'num',ch:String(e.C)}\n];}\n\nfunction segment(g, r, c, dr, dc){\n  // walk to start\n  while(inside(r-dr,c-dc) && g[r-dr][c-dc]){ r-=dr; c-=dc; }\n  const cells=[];\n  let i=0;\n  while(inside(r+dr*i,c+dc*i) && g[r+dr*i][c+dc*i]){\n    cells.push({r:r+dr*i,c:c+dc*i,cell:g[r+dr*i][c+dc*i]}); i++;\n  }\n  return cells;\n}\nfunction evalOk(a,op,b,c){\n  a=+a; b=+b; c=+c;\n  if(op==='+') return a+b===c;\n  if(op==='-') return a-b===c;\n  if(op==='\u00D7') return a*b===c;\n  if(op==='\u00F7') return b!==0 && a/b===c;\n  return false;\n}\nfunction validStrip(cells){\n  if(cells.length!==5) return false;\n  const ks=cells.map(x=>x.cell.k);\n  if(ks.join(',')!=='num,op,num,eq,num') return false;\n  return evalOk(cells[0].cell.ch,cells[1].cell.ch,cells[2].cell.ch,cells[4].cell.ch);\n}\n\n// placement rules: token-by-token match, and no segment > 5, and any completed segment must be valid\nfunction canPlace(g,r,c,dr,dc,s,needIntersect){\n  let inter=0;\n  const touched=[];\n  for(let i=0;i<s.length;i++){\n    const rr=r+dr*i, cc=c+dc*i; if(!inside(rr,cc)) return false;\n    const cell=g[rr][cc];\n    if(cell){\n      if(cell.k!==s[i].k || cell.ch!==s[i].ch) return false;\n      inter++;\n    }\n    touched.push([rr,cc]);\n  }\n  if(needIntersect && inter===0) return false;\n\n  // local validation: for each touched cell, check both directions\n  for(const [tr,tc] of touched){\n    for(const [xr,xc] of [[0,1],[1,0]]){\n      const seg=segment(g, tr, tc, xr, xc);\n      // simulate new token where empty\n      const idx=seg.findIndex(p=>p.r===tr&&p.c===tc);\n      if(idx===-1){\n        // tc,tr currently empty in seg view; build a transient segment including new token\n        const tmp=segmentWithHypo(g,tr,tc,xr,xc);\n        if(tmp.length>5) return false;\n        if(tmp.length===5 && !validStrip(tmp)) return false;\n      }else{\n        if(seg.length>5) return false;\n        if(seg.length===5 && !validStrip(seg)) return false;\n      }\n    }\n  }\n  return true;\n}\nfunction segmentWithHypo(g, r, c, dr, dc){\n  // build segment including hypothetical filled cell at r,c (we only call this one when we know r,c is empty)\n  // walk back\n  let sr=r, sc=c;\n  while(inside(sr-dr,sc-dc) && g[sr-dr][sc-dc]){ sr-=dr; sc-=dc; }\n  const out=[];\n  let i=0;\n  while(true){\n    const rr=sr+dr*i, cc=sc+dc*i;\n    if(!inside(rr,cc)) break;\n    const cell = (rr===r && cc===c) ? {k:'__hypo__'} : g[rr][cc];\n    if(!cell) break;\n    out.push({r:rr,c:cc,cell});\n    i++;\n  }\n  return out;\n}\nfunction place(g,r,c,dr,dc,s,id){\n  const coords=[];\n  for(let i=0;i<s.length;i++){\n    const rr=r+dr*i, cc=c+dc*i;\n    g[rr][cc]={...(g[rr][cc]||{}),...s[i], id};\n    coords.push([rr,cc]);\n  }\n  return coords;\n}\n\nfunction generateExact(target){\n  const g=empty(), placed=[];\n  // seed anywhere near center\n  for(let seedTry=0; seedTry<300; seedTry++){\n    const e0=generateRandomEquation(), s0=seq(e0), d0=Math.random()<0.5?'ac':'dn';\n    const dr0=d0==='ac'?0:1, dc0=d0==='ac'?1:0;\n    const r0=R(6,ROWS-7), c0=R(6,COLS-7);\n    if(canPlace(g,r0,c0,dr0,dc0,s0,false)){\n      place(g,r0,c0,dr0,dc0,s0,1); placed.push({id:1,eq:e0});\n      break;\n    }\n  }\n  if(placed.length===0) return null;\n\n  let id=2, tries=0;\n  while(id<=target && tries<MAX_TRIES){\n    tries++;\n    const e=generateRandomEquation(), s=seq(e);\n    let best=null;\n    for(const dir of ['ac','dn']){\n      const dr=dir==='ac'?0:1, dc=dir==='ac'?1:0;\n      for(let r=0;r<ROWS;r++){\n        for(let c=0;c<COLS;c++){\n          if(canPlace(g,r,c,dr,dc,s,true)){\n            const sc=score(g,r,c,dr,dc,s);\n            if(!best || sc>best.sc) best={r,c,dr,dc,sc};\n          }\n        }\n      }\n    }\n    if(best){\n      place(g,best.r,best.c,best.dr,best.dc,s,id);\n      placed.push({id,eq:e});\n      id++;\n    }else{\n      return null; // cannot reach target under strict rules\n    }\n  }\n  // final full validation: every contiguous segment must be length 5 and valid\n  for(let r=0;r<ROWS;r++){\n    for(let c=0;c<COLS;c++){\n      if(!g[r][c]) continue;\n      for(const [dr,dc] of [[0,1],[1,0]]){\n        const seg=segment(g,r,c,dr,dc);\n        if(seg.length>0){\n          if(seg.length!==5 || !validStrip(seg)) return null;\n        }\n      }\n    }\n  }\n  return {g,placed};\n}\n\nfunction score(g,r,c,dr,dc,s){\n  // prefer more intersections and centrality\n  let inter=0; for(let i=0;i<s.length;i++){ if(g[r+dr*i][c+dc*i]) inter++; }\n  const mr=(ROWS-1)/2, mc=(COLS-1)/2;\n  const er=r+dr*(s.length-1), ec=c+dc*(s.length-1);\n  const dist=Math.hypot((r+er)/2-mr, (c+ec)/2-mc);\n  return inter*10 - dist;\n}\n\nfunction cropBounds(g){\n  const cells=[]; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++) if(g[r][c]) cells.push([r,c]);\n  const minR=Math.min(...cells.map(x=>x[0])), maxR=Math.max(...cells.map(x=>x[0]));\n  const minC=Math.min(...cells.map(x=>x[1])), maxC=Math.max(...cells.map(x=>x[1]));\n  return {minR,maxR,minC,maxC,rows:maxR-minR+1,cols:maxC-minC+1};\n}\nfunction t(tag,attrs){const n=document.createElementNS('http://www.w3.org/2000/svg',tag);for(const k in attrs)n.setAttribute(k,attrs[k]);return n}\n\nfunction draw(model,givensCount){\n  const {g}=model;\n  // collect number cells\n  const numCells=[];\n  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){const cell=g[r][c]; if(cell && cell.k==='num') numCells.push({r,c});}\n  if(givensCount>numCells.length) throw new Error(`requested ${givensCount} givens but only ${numCells.length} number cells exist`);\n\n  // choose exact givens\n  const arr=[...numCells]; for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];}\n  const givenSet=new Set(arr.slice(0,givensCount).map(p=>p.r+','+p.c));\n\n  const b=cropBounds(g);\n  const targetPx=720, cell=Math.max(18, Math.floor(targetPx/b.cols));\n  const W=b.cols*cell, H=b.rows*cell;\n  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('width',W); svg.setAttribute('height',H);\n  svg.innerHTML='';\n\n  for(let r=b.minR;r<=b.maxR;r++){\n    for(let c=b.minC;c<=b.maxC;c++){\n      const cellObj=g[r][c]; if(!cellObj) continue;\n      const x=(c-b.minC)*cell, y=(r-b.minR)*cell;\n      svg.appendChild(t('rect',{x,y,width:cell,height:cell,fill:'#fff',stroke:'#000','stroke-width':1}));\n      let text=cellObj.ch;\n      if(cellObj.k==='num' && !ans.checked){ text = givenSet.has(r+','+c) ? cellObj.ch : ''; }\n      const fs = (text && text.length>=2) ? Math.floor(cell*0.55) : Math.floor(cell*0.7);\n      const node=t('text',{x:x+cell/2,y:y+cell/2+1,'text-anchor':'middle','dominant-baseline':'middle','font-size':fs,'font-family':'sans-serif'});\n      node.textContent=text||''; svg.appendChild(node);\n    }\n  }\n  svg.appendChild(t('rect',{x:0,y:0,width:W,height:H,fill:'none',stroke:'#000','stroke-width':2}));\n\n  // adjust givens slider max and persist\n  givSlider.max = String(numCells.length);\n  if(parseInt(givSlider.value)>numCells.length){\n    givSlider.value=String(numCells.length); givOut.textContent=givSlider.value; setCookie('mx_gv', givSlider.value);\n  }\n  return {numTotal:numCells.length};\n}\n\nfunction getSelectedOperations() {\n  const ops = [];\n  if (opAdd.checked) ops.push('+');\n  if (opSub.checked) ops.push('-');\n  if (opMul.checked) ops.push('\u00D7');\n  if (opDiv.checked) ops.push('\u00F7');\n  return ops.length > 0 ? ops : ['+']; // Fallback to addition if none selected\n}\n\nfunction getNumberRange() {\n  let min=0, max=20;\n  const preset = rangePreset.value;\n  if(/^(\\d+)-(\\d+)$/.test(preset)){\n    const m=preset.match(/^(\\d+)-(\\d+)$/);\n    min = parseInt(m[1]);\n    max = parseInt(m[2]);\n  }\n  // Ensure positive non-zero results where needed\n  return { min, max };\n}\n\nfunction validateEquation(A, B, C, op, range = null) {\n  A = parseInt(A); B = parseInt(B); C = parseInt(C);\n\n  const currentRange = range || getNumberRange();\n\n  // Ensure all numbers are positive and within range\n  if (A < currentRange.min || A > currentRange.max ||\n      B < currentRange.min || B > currentRange.max ||\n      C < currentRange.min || C > currentRange.max) return false;\n  if (!Number.isInteger(A) || !Number.isInteger(B) || !Number.isInteger(C)) return false;\n  if (A <= 0 || B <= 0 || C <= 0) return false; // Ensure all positive\n\n  switch (op) {\n    case '+': return A + B === C;\n    case '-': return A - B === C && C > 0; // Explicitly check result is positive\n    case '\u00D7': return A * B === C;\n    case '\u00F7': return B !== 0 && A / B === C && A % B === 0; // Must be exact division\n    default: return false;\n  }\n}\n\nfunction generateRandomEquation() {\n  const operations = getSelectedOperations();\n  const range = getNumberRange();\n  const digits = 'auto';\n\n  for (let attempts = 0; attempts < 300; attempts++) {\n    const op = operations[Math.floor(Math.random() * operations.length)];\n    let A, B, C;\n\n    switch (op) {\n      case '+': {\n        // Pick operands within selected range; result constraints handled in validateEquation\n        A = R(range.min, range.max);\n        B = R(range.min, range.max);\n        // digits auto: do not clamp operands by digits; rely on range\n        C = A + B;\n        break; }\n\n      case '-': {\n        // Ensure A >= B and both in range\n        A = R(Math.max(range.min, 1), range.max);\n        B = R(range.min, range.max);\n        if (B > A) [A, B] = [B, A];\n        // digits auto: do not clamp operands by digits; rely on range\n        C = A - B;\n        break; }\n\n      case '\u00D7': {\n        const maxFactor = Math.min(Math.floor(Math.sqrt(range.max)), 20);\n        A = R(2, Math.max(2, maxFactor));\n        B = R(2, Math.max(2, maxFactor));\n        // digits auto: do not clamp operands by digits; rely on range\n        C = A * B;\n        if (C < range.min || C > range.max) continue;\n        break; }\n\n      case '\u00F7': {\n        // Generate exact division with operands in range\n        B = R(Math.max(range.min, 2), Math.max(range.min, range.max));\n        C = R(Math.max(range.min, 1), Math.max(range.min, range.max));\n        A = B * C;\n        if (A < 1) continue;\n        // digits auto: do not clamp operands by digits; rely on range\n        break; }\n    }\n\n    if (validateEquation(A, B, C, op, range)) {\n      return {A, B, C, op};\n    }\n  }\n\n  // Guaranteed valid fallback based on range\n  const fallbackRange = range.max <= 20 ? {A: 8, B: 4, C: 2} : {A: 12, B: 4, C: 3};\n  return {...fallbackRange, op: '\u00F7'};\n}\n\nfunction getIntersectionValue(grid, r, c) {\n  return grid[r] && grid[r][c] && grid[r][c].k === 'num' ? parseInt(grid[r][c].ch) : null;\n}\n\nfunction findValidEquationForConstraints(constraints) {\n  // constraints: {pos0: value, pos2: value, pos4: value} where positions are 0=A, 2=B, 4=C\n  const operations = ['+', '-', '\u00D7', '\u00F7'];\n\n  for (let attempt = 0; attempt < 1000; attempt++) {\n    const eq = generateRandomEquation();\n    const values = [eq.A, eq.B, eq.C];\n\n    let valid = true;\n    for (const [pos, requiredValue] of Object.entries(constraints)) {\n      if (values[parseInt(pos) / 2] !== requiredValue) {\n        valid = false;\n        break;\n      }\n    }\n\n    if (valid && validateEquation(eq.A, eq.B, eq.C, eq.op)) {\n      return eq;\n    }\n  }\n\n  // If no valid equation found with constraints, try to modify an equation\n  if (Object.keys(constraints).length === 1) {\n    const [pos, value] = Object.entries(constraints)[0];\n    const position = parseInt(pos) / 2;\n\n    // Try to build equation around the constraint\n    for (const op of operations) {\n      let A, B, C;\n\n      if (position === 0) { // A is constrained\n        A = value;\n        for (let i = 0; i < 50; i++) {\n          if (op === '+') {\n            B = Math.floor(Math.random() * 40) + 10;\n            C = A + B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '-') {\n            B = Math.floor(Math.random() * Math.min(A - 1, 40)) + 1;\n            C = A - B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '\u00D7') {\n            B = Math.floor(Math.random() * Math.min(9, Math.floor(99/A))) + 2;\n            C = A * B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '\u00F7') {\n            const divisors = [];\n            for (let d = 2; d <= Math.min(9, A); d++) {\n              if (A % d === 0) divisors.push(d);\n            }\n            if (divisors.length > 0) {\n              B = divisors[Math.floor(Math.random() * divisors.length)];\n              C = A / B;\n              if (validateEquation(A, B, C, op)) return {A, B, C, op};\n            }\n          }\n        }\n      } else if (position === 1) { // B is constrained\n        B = value;\n        for (let i = 0; i < 50; i++) {\n          if (op === '+') {\n            A = Math.floor(Math.random() * (99 - B)) + 10;\n            C = A + B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '-') {\n            A = Math.floor(Math.random() * 40) + B + 10;\n            C = A - B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '\u00D7') {\n            A = Math.floor(Math.random() * Math.min(9, Math.floor(99/B))) + 2;\n            C = A * B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '\u00F7') {\n            C = Math.floor(Math.random() * 10) + 2;\n            A = B * C;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          }\n        }\n      } else if (position === 2) { // C is constrained\n        C = value;\n        for (let i = 0; i < 50; i++) {\n          if (op === '+') {\n            A = Math.floor(Math.random() * Math.min(C - 10, 50)) + 10;\n            B = C - A;\n            if (B >= 10 && B <= 50) return {A, B, C, op};\n          } else if (op === '-') {\n            B = Math.floor(Math.random() * Math.min(30, C - 1)) + 10;\n            A = C + B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          } else if (op === '\u00D7') {\n            const factors = [];\n            for (let f = 2; f <= Math.min(9, C); f++) {\n              if (C % f === 0 && C/f >= 2 && C/f <= 9) {\n                factors.push([f, C/f]);\n              }\n            }\n            if (factors.length > 0) {\n              const [A, B] = factors[Math.floor(Math.random() * factors.length)];\n              if (validateEquation(A, B, C, op)) return {A, B, C, op};\n            }\n          } else if (op === '\u00F7') {\n            B = Math.floor(Math.random() * 8) + 2;\n            A = C * B;\n            if (validateEquation(A, B, C, op)) return {A, B, C, op};\n          }\n        }\n      }\n    }\n  }\n\n  return generateRandomEquation(); // Fallback\n}\n\n// BACKWARD GENERATION ALGORITHM\n// 1. Generate complete crossword with all numbers filled\n// 2. Strategically remove numbers while maintaining unique solvability\n// 3. Stop when target difficulty percentage is reached\n\nfunction generateBackwardCrossword(targetEquations, difficulty) {\n  // Step 1: Generate a complete crossword with all numbers visible\n  const fullModel = createRandomCrossword(targetEquations, difficulty);\n  if (!fullModel) return null;\n\n  // Step 2: Start with all numbers as givens and strategically remove them\n  return optimizeGivensBackward(fullModel, difficulty);\n}\n\nfunction optimizeGivensBackward(model, difficulty) {\n  const {grid, equations} = model;\n\n  // Start with ALL numbers as givens (complete solution)\n  const allNumberPositions = [];\n  for (let r = 0; r < 24; r++) {\n    for (let c = 0; c < 24; c++) {\n      if (grid[r] && grid[r][c] && grid[r][c].k === 'num') {\n        allNumberPositions.push(`${r},${c}`);\n      }\n    }\n  }\n\n  let currentGivens = new Set(allNumberPositions);\n  const difficultyTargets = getNewDifficultyTargets(difficulty, allNumberPositions.length);\n\n  console.log(`=== BACKWARD GENERATION DEBUG ===`);\n  console.log(`Difficulty: ${difficulty}`);\n  console.log(`Total numbers: ${allNumberPositions.length}`);\n  console.log(`Difficulty targets:`, difficultyTargets);\n\n  if (!difficultyTargets || !difficultyTargets.percentage) {\n    console.error('Invalid difficulty targets!', difficultyTargets);\n    return model; // Return original model if targets are invalid\n  }\n\n  console.log(`Target range: ${difficultyTargets.minGivens}-${difficultyTargets.maxGivens} givens (${difficultyTargets.percentage.min}-${difficultyTargets.percentage.max}%)`);\n  console.log(`Starting with: ${currentGivens.size} givens (100%)`);\n  console.log(`===================================`);\n\n  // Step 3: Remove numbers strategically until we hit target difficulty\n  let attempts = 0;\n  const maxAttempts = difficulty === 'expert' ? 1000 : 500; // Allow more attempts for expert\n\n  while (currentGivens.size > difficultyTargets.maxGivens && attempts < maxAttempts) {\n    attempts++;\n    const bestRemoval = findBestNumberToRemove(grid, equations, currentGivens, difficulty);\n\n    if (!bestRemoval) {\n      console.log(`No more removals found at ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%) - target was ${difficultyTargets.maxGivens}`);\n      break; // Cannot remove any more numbers safely\n    }\n\n    if (attempts % 10 === 0) {\n      const currentPercentage = Math.round(currentGivens.size/allNumberPositions.length*100);\n      console.log(`Attempt ${attempts}: ${currentGivens.size}/${allNumberPositions.length} givens (${currentPercentage}%) - removing next...`);\n\n      // Update UI progress\n      if (typeof window !== 'undefined' && window.stat) {\n        window.stat.textContent = `\uD83D\uDD04 Optimizing ${difficulty} difficulty... ${currentPercentage}% \u2192 ${difficultyTargets.percentage.max}% (attempt ${attempts})`;\n      }\n    }\n\n    currentGivens.delete(bestRemoval);\n\n    // For expert mode, use mathematical constraint validation instead of full solvability\n    if (difficulty === 'expert') {\n      // Check if removal creates mathematical ambiguity (multiple valid solutions)\n      if (createsMathematicalAmbiguity(grid, equations, currentGivens)) {\n        currentGivens.add(bestRemoval);\n        console.log(`Removed number created mathematical ambiguity at ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%)`);\n        break;\n      }\n    } else {\n      // For other difficulties, verify puzzle is still computationally solvable\n      if (!canSolvePuzzle(grid, equations, currentGivens)) {\n        currentGivens.add(bestRemoval);\n        console.log(`Removed number broke solvability at ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%)`);\n        break;\n      }\n    }\n  }\n\n  console.log(`Final: ${currentGivens.size}/${allNumberPositions.length} givens (${Math.round(currentGivens.size/allNumberPositions.length*100)}%), target was ${Math.round(difficultyTargets.maxGivens)} (${Math.round(difficultyTargets.maxGivens/allNumberPositions.length*100)}%)`);\n  console.log(`Attempts made: ${attempts}`);\n  console.log(`Generated ${equations.length} equations with ${allNumberPositions.length} total numbers`);\n\n  // Step 4: Final validation to ensure we haven't created any isolated equations\n  const beforeFix = currentGivens.size;\n  currentGivens = fixAnyIsolatedEquations(grid, equations, currentGivens);\n  const afterFix = currentGivens.size;\n\n  if (afterFix > beforeFix) {\n    console.log(`Final validation added ${afterFix - beforeFix} givens back (${beforeFix} -> ${afterFix})`);\n  }\n\n  return {\n    ...model,\n    optimizedGivens: currentGivens\n  };\n}\n\nfunction findBestNumberToRemove(grid, equations, currentGivens, difficulty = 'expert') {\n  const candidates = [];\n\n  // Analyze each given number for removal potential\n  for (const givenPos of currentGivens) {\n    const [r, c] = givenPos.split(',').map(Number);\n    const removalScore = calculateRemovalScore(grid, equations, currentGivens, r, c, difficulty);\n\n    if (removalScore > 0) {\n      candidates.push({pos: givenPos, score: removalScore, r, c});\n    }\n  }\n\n  if (candidates.length === 0) {\n    console.log(`No removal candidates found! Current givens: ${currentGivens.size}`);\n    return null;\n  }\n\n  // Sort by removal score (higher = better to remove)\n  candidates.sort((a, b) => b.score - a.score);\n\n  // Debug: Show top candidates\n  if (candidates.length > 0) {\n    console.log(`Found ${candidates.length} removal candidates, best score: ${candidates[0].score}`);\n  }\n\n  return candidates[0].pos;\n}\n\nfunction calculateRemovalScore(grid, equations, currentGivens, r, c, difficulty = 'expert') {\n  let score = 0;\n\n  // Find which equation(s) this number belongs to\n  const containingEquations = [];\n  for (const eq of equations) {\n    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (numbers)\n      const eqR = eq.across ? eq.row : eq.row + i;\n      const eqC = eq.across ? eq.col + i : eq.col;\n      if (eqR === r && eqC === c) {\n        containingEquations.push({eq, position: i});\n        break;\n      }\n    }\n  }\n\n  for (const {eq, position} of containingEquations) {\n    // Count how many givens this equation currently has\n    const eqPositions = [];\n    for (let i = 0; i < 5; i += 2) {\n      const eqR = eq.across ? eq.row : eq.row + i;\n      const eqC = eq.across ? eq.col + i : eq.col;\n      if (eqR < 24 && eqC < 24) {\n        eqPositions.push(`${eqR},${eqC}`);\n      }\n    }\n\n    const currentEqGivens = eqPositions.filter(pos => currentGivens.has(pos)).length;\n\n    // Difficulty-based removal constraints\n    if (difficulty === 'expert') {\n      // EXPERT: Allow aggressive removal, rely on intersection constraints\n      if (currentEqGivens === 1) {\n        // Only allow if this number has strong intersection constraints\n        const intersectionCount = countIntersectionConstraints(grid, equations, currentGivens, r, c);\n        if (intersectionCount < 2) {\n          return 0; // Need at least 2 intersections to safely remove last number\n        }\n        score += 30; // High reward for aggressive expert removal\n      }\n    } else {\n      // EASIER MODES: More conservative - never remove last given\n      if (currentEqGivens <= 1) {\n        return 0; // Cannot remove - would create equation with 0 givens\n      }\n    }\n\n    // EXPERT MODE: Be much more aggressive about removal scoring\n    if (currentEqGivens >= 3) {\n      score += 20; // Heavily favor removing from fully-given equations\n    } else if (currentEqGivens === 2) {\n      // Check if this number has intersection constraints\n      const intersectionCount = countIntersectionConstraints(grid, equations, currentGivens, r, c);\n      if (intersectionCount >= 2) {\n        score += 15; // Strong intersections = high removal score\n      } else if (intersectionCount >= 1) {\n        score += 10; // Even single intersections get good scores for expert\n      } else {\n        score += 5; // Still consider for removal with weaker constraints\n      }\n    }\n\n    // Prefer removing results over operands for cleaner puzzles\n    if (position === 4) { // Result position\n      score += 2;\n    }\n\n    // Prefer removing larger numbers (they're easier to deduce)\n    const cellValue = parseInt(grid[r][c].ch);\n    if (cellValue > 20) score += 1;\n  }\n\n  return score;\n}\n\nfunction countIntersectionConstraints(grid, equations, currentGivens, r, c) {\n  let count = 0;\n\n  for (const eq of equations) {\n    // Check if this position intersects with this equation\n    for (let i = 0; i < 5; i += 2) {\n      const eqR = eq.across ? eq.row : eq.row + i;\n      const eqC = eq.across ? eq.col + i : eq.col;\n\n      if (eqR === r && eqC === c) {\n        // Found intersection! Check if this equation provides constraints\n        const eqPositions = [];\n        for (let j = 0; j < 5; j += 2) {\n          const checkR = eq.across ? eq.row : eq.row + j;\n          const checkC = eq.across ? eq.col + j : eq.col;\n          if (checkR < 24 && checkC < 24) {\n            eqPositions.push(`${checkR},${checkC}`);\n          }\n        }\n\n        const eqGivens = eqPositions.filter(pos => currentGivens.has(pos)).length;\n        if (eqGivens >= 2) {\n          count++;\n        }\n        break;\n      }\n    }\n  }\n\n  return count;\n}\n\nfunction fixAnyIsolatedEquations(grid, equations, currentGivens) {\n  const fixedGivens = new Set([...currentGivens]);\n  let fixes = 0;\n\n  for (const eq of equations) {\n    const eqPositions = [];\n    for (let i = 0; i < 5; i += 2) {\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        eqPositions.push(`${r},${c}`);\n      }\n    }\n\n    const givenCount = eqPositions.filter(pos => fixedGivens.has(pos)).length;\n\n    // Only fix truly unsolvable cases - be very conservative for expert puzzles\n    if (givenCount === 0) {\n      fixedGivens.add(eqPositions[0]);\n      fixes++;\n      console.log(`Fixed equation with 0 givens (fix #${fixes})`);\n    } else if (givenCount === 1 && eqPositions.length >= 3) {\n      // For expert mode, be extremely conservative - only fix if ALL empty positions are completely isolated\n      let completelyIsolatedCount = 0;\n\n      for (const pos of eqPositions) {\n        if (!fixedGivens.has(pos)) {\n          const [r, c] = pos.split(',').map(Number);\n\n          // Check if this position has ANY intersection at all\n          let hasAnyIntersection = false;\n          for (const otherEq of equations) {\n            if (otherEq === eq) continue;\n            for (let j = 0; j < 5; j += 2) {\n              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;\n              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;\n              if (otherR === r && otherC === c) {\n                hasAnyIntersection = true;\n                break;\n              }\n            }\n            if (hasAnyIntersection) break;\n          }\n\n          if (!hasAnyIntersection) {\n            completelyIsolatedCount++;\n          }\n        }\n      }\n\n      // Only fix if ALL empty positions are completely isolated (extremely rare case)\n      if (completelyIsolatedCount === eqPositions.length - givenCount) {\n        const ungiven = eqPositions.filter(pos => !fixedGivens.has(pos));\n        if (ungiven.length > 0) {\n          fixedGivens.add(ungiven[0]);\n          fixes++;\n          console.log(`Fixed equation with ${completelyIsolatedCount} completely isolated positions (fix #${fixes})`);\n        }\n      }\n    }\n  }\n\n  console.log(`Final validation made ${fixes} fixes total`);\n  return fixedGivens;\n}\n\nfunction createRandomCrossword(numEquations, difficulty = 'expert') {\n  const grid = Array.from({length: 24}, () => Array(24).fill(null));\n  const equations = [];\n  const maxAttempts = 100;\n\n  // Start with first equation in center area\n  const firstRow = Math.floor(Math.random() * 8) + 8;\n  const firstCol = Math.floor(Math.random() * 8) + 8;\n  const firstAcross = Math.random() < 0.5;\n\n  const firstEq = generateRandomEquation();\n  const firstSeq = [\n    {k: 'num', ch: String(firstEq.A)},\n    {k: 'op', ch: firstEq.op},\n    {k: 'num', ch: String(firstEq.B)},\n    {k: 'eq', ch: '='},\n    {k: 'num', ch: String(firstEq.C)}\n  ];\n\n  // Place first equation\n  for (let i = 0; i < 5; i++) {\n    const r = firstAcross ? firstRow : firstRow + i;\n    const c = firstAcross ? firstCol + i : firstCol;\n    grid[r][c] = {...firstSeq[i], id: 1};\n  }\n\n  equations.push({\n    across: firstAcross,\n    row: firstRow,\n    col: firstCol,\n    eq: firstEq\n  });\n\n  // Add remaining equations with difficulty-based connectivity\n  for (let eqNum = 2; eqNum <= numEquations; eqNum++) {\n    let placed = false;\n\n    for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {\n      // Enhanced intersection finding - connectivity varies by difficulty\n      const possibleIntersections = [];\n\n      for (let r = 1; r < 23; r++) {\n        for (let c = 1; c < 23; c++) {\n          if (grid[r][c] && grid[r][c].k === 'num') {\n            // Try both orientations\n            for (const across of [true, false]) {\n              for (let pos = 0; pos < 5; pos += 2) { // Only number positions (0, 2, 4)\n                const startR = across ? r : r - pos;\n                const startC = across ? c - pos : c;\n\n                // Check if this position would work\n                if (startR >= 0 && startR < 24 && startC >= 0 && startC < 24) {\n                  let canPlace = true;\n                  const constraints = {};\n                  let intersectionCount = 0;\n\n                  // Check all 5 positions of potential equation\n                  for (let i = 0; i < 5; i++) {\n                    const checkR = across ? startR : startR + i;\n                    const checkC = across ? startC + i : startC;\n\n                    if (checkR >= 24 || checkC >= 24) {\n                      canPlace = false;\n                      break;\n                    }\n\n                    const existing = grid[checkR][checkC];\n                    if (existing) {\n                      // ENHANCED: Allow multiple intersections and self-loops\n                      if (existing.k === 'num') {\n                        constraints[i] = parseInt(existing.ch);\n                        intersectionCount++;\n                      } else if (existing.k === 'op' && (i === 1)) {\n                        // Allow operation intersections for loops (but be more lenient)\n                        if (getSelectedOperations().map(op => op.symbol).includes(existing.ch)) {\n                          constraints[i] = existing.ch;\n                          intersectionCount++;\n                        } else {\n                          canPlace = false;\n                          break;\n                        }\n                      } else if (existing.k === 'eq' && (i === 3)) {\n                        // Allow equals sign intersections for loops\n                        constraints[i] = existing.ch;\n                        intersectionCount++;\n                      } else {\n                        // For the first few equations, be more lenient about intersections\n                        if (eqNum <= 5) {\n                          // Skip this intersection rather than failing\n                          canPlace = false;\n                          break;\n                        } else {\n                          // Later equations can be more strict\n                          canPlace = false;\n                          break;\n                        }\n                      }\n                    }\n                  }\n\n                  // ENHANCED: Prefer placements with multiple intersections\n                  // Difficulty-based minimum intersection requirements\n                  let minIntersections;\n                  switch (difficulty) {\n                    case 'expert':\n                      minIntersections = eqNum <= 3 ? 1 : 1; // Expert allows single intersections but prefers multiple\n                      break;\n                    case 'hard':\n                      minIntersections = 1; // Hard requires at least one intersection\n                      break;\n                    case 'medium':\n                    case 'easy':\n                      minIntersections = eqNum <= 5 ? 1 : 1; // Easier modes are more flexible\n                      break;\n                    default:\n                      minIntersections = 1;\n                  }\n\n                  if (canPlace && intersectionCount >= minIntersections) {\n                    possibleIntersections.push({\n                      row: startR,\n                      col: startC,\n                      across: across,\n                      constraints: constraints,\n                      intersectionCount: intersectionCount // For scoring\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (possibleIntersections.length > 0) {\n        // ENHANCED: Prefer intersections with higher connectivity based on difficulty\n        // Sort by intersection count (descending) and pick from top candidates\n        possibleIntersections.sort((a, b) => b.intersectionCount - a.intersectionCount);\n\n        // Difficulty-based connectivity selection\n        let topPercentage;\n        switch (difficulty) {\n          case 'expert':\n            topPercentage = 0.4; // Pick from top 40% - reduced from 20%\n            break;\n          case 'hard':\n            topPercentage = 0.6; // Pick from top 60% - reduced from 40%\n            break;\n          case 'medium':\n            topPercentage = 0.8; // Pick from top 80% - reduced from 60%\n            break;\n          case 'easy':\n            topPercentage = 1.0; // Pick from all options - reduced from 80%\n            break;\n          default:\n            topPercentage = 0.5; // Default fallback\n        }\n\n        const topCandidates = possibleIntersections.slice(0, Math.max(1, Math.ceil(possibleIntersections.length * topPercentage)));\n        const intersection = topCandidates[Math.floor(Math.random() * topCandidates.length)];\n\n        let eq = null;\n        let attempts = 0;\n        while (!eq && attempts < 10) {\n          eq = findValidEquationForConstraints(intersection.constraints);\n          attempts++;\n        }\n\n        // If we still can't find a valid equation, try fallback based on difficulty\n        if (!eq && possibleIntersections.length > 1) {\n          if (difficulty === 'expert') {\n            // For expert, try high-connectivity intersections first, then single\n            const multiIntersections = possibleIntersections.filter(int => int.intersectionCount > 1);\n            if (multiIntersections.length > 0) {\n              const multiIntersection = multiIntersections[Math.floor(Math.random() * multiIntersections.length)];\n              eq = findValidEquationForConstraints(multiIntersection.constraints);\n            }\n          }\n\n          // Fallback to simpler intersections if needed\n          if (!eq) {\n            const simplerIntersections = possibleIntersections.filter(int => int.intersectionCount === 1);\n            if (simplerIntersections.length > 0) {\n              const simpleIntersection = simplerIntersections[Math.floor(Math.random() * simplerIntersections.length)];\n              eq = findValidEquationForConstraints(simpleIntersection.constraints);\n            }\n          }\n        }\n\n        if (!eq) {\n          console.log('Failed to generate equation for constraints, using fallback');\n          eq = generateRandomEquation();\n        }\n\n        const sequence = [\n          {k: 'num', ch: String(eq.A)},\n          {k: 'op', ch: eq.op},\n          {k: 'num', ch: String(eq.B)},\n          {k: 'eq', ch: '='},\n          {k: 'num', ch: String(eq.C)}\n        ];\n\n        // Validate equation placement first - ensure values match constraints\n        let canPlaceEquation = true;\n        for (let i = 0; i < 5; i++) {\n          const r = intersection.across ? intersection.row : intersection.row + i;\n          const c = intersection.across ? intersection.col + i : intersection.col;\n          if (grid[r][c] && grid[r][c].k === 'num' && grid[r][c].ch !== sequence[i].ch) {\n            console.warn(`Constraint mismatch at (${r},${c}): expected ${sequence[i].ch}, found ${grid[r][c].ch}`);\n            canPlaceEquation = false;\n            break;\n          }\n        }\n\n        // Only place if validation passes\n        if (canPlaceEquation) {\n          for (let i = 0; i < 5; i++) {\n            const r = intersection.across ? intersection.row : intersection.row + i;\n            const c = intersection.across ? intersection.col + i : intersection.col;\n            if (!grid[r][c]) {\n              grid[r][c] = {...sequence[i], id: eqNum};\n            }\n          }\n        } else {\n          // Skip this placement attempt and try next intersection\n          continue;\n        }\n\n        equations.push({\n          across: intersection.across,\n          row: intersection.row,\n          col: intersection.col,\n          eq: eq\n        });\n\n        placed = true;\n      }\n    }\n\n    // If we couldn't place intersecting, try placing separately\n    if (!placed) {\n      for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {\n        const row = Math.floor(Math.random() * 16) + 4;\n        const col = Math.floor(Math.random() * 16) + 4;\n        const across = Math.random() < 0.5;\n\n        let canPlace = true;\n        for (let i = 0; i < 5; i++) {\n          const r = across ? row : row + i;\n          const c = across ? col + i : col;\n          if (r >= 24 || c >= 24 || grid[r][c]) {\n            canPlace = false;\n            break;\n          }\n        }\n\n        if (canPlace) {\n          const eq = generateRandomEquation();\n          const sequence = [\n            {k: 'num', ch: String(eq.A)},\n            {k: 'op', ch: eq.op},\n            {k: 'num', ch: String(eq.B)},\n            {k: 'eq', ch: '='},\n            {k: 'num', ch: String(eq.C)}\n          ];\n\n          for (let i = 0; i < 5; i++) {\n            const r = across ? row : row + i;\n            const c = across ? col + i : col;\n            grid[r][c] = {...sequence[i], id: eqNum};\n          }\n\n          equations.push({\n            across: across,\n            row: row,\n            col: col,\n            eq: eq\n          });\n\n          placed = true;\n        }\n      }\n\n      // FALLBACK: If no intersections found, place equation in empty space\n      if (!placed) {\n        console.log(`No intersections found for equation ${eqNum}, trying fallback placement`);\n\n        for (let fallbackAttempt = 0; fallbackAttempt < 50 && !placed; fallbackAttempt++) {\n          const row = Math.floor(Math.random() * 20) + 2;\n          const col = Math.floor(Math.random() * 20) + 2;\n          const across = Math.random() < 0.5;\n\n          // Check if this space is free\n          let canPlace = true;\n          for (let i = 0; i < 5; i++) {\n            const checkR = across ? row : row + i;\n            const checkC = across ? col + i : col;\n\n            if (checkR >= 24 || checkC >= 24 || grid[checkR][checkC]) {\n              canPlace = false;\n              break;\n            }\n          }\n\n          if (canPlace) {\n            const eq = generateRandomEquation();\n            const sequence = [\n              {k: 'num', ch: String(eq.A)},\n              {k: 'op', ch: eq.op},\n              {k: 'num', ch: String(eq.B)},\n              {k: 'eq', ch: '='},\n              {k: 'num', ch: String(eq.C)}\n            ];\n\n            // Place the equation\n            for (let i = 0; i < 5; i++) {\n              const r = across ? row : row + i;\n              const c = across ? col + i : col;\n              grid[r][c] = {...sequence[i], id: eqNum};\n            }\n\n            equations.push({\n              across: across,\n              row: row,\n              col: col,\n              eq: eq\n            });\n\n            placed = true;\n            console.log(`Fallback placement successful for equation ${eqNum}`);\n          }\n        }\n\n        if (!placed) {\n          console.log(`Failed to place equation ${eqNum} even with fallback`);\n        }\n      }\n    }\n\n    if (!placed) {\n      console.log(`Could not place equation ${eqNum} after ${maxAttempts} attempts`);\n    }\n  }\n\n  // Final validation: ensure all equations in the grid are mathematically correct\n  console.log('Performing final equation validation...');\n  let validationErrors = 0;\n  for (const eq of equations) {\n    const positions = [];\n    for (let i = 0; i < 5; i += 2) { // Only number positions: 0, 2, 4\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24 && grid[r][c]) {\n        positions.push(parseInt(grid[r][c].ch));\n      } else {\n        console.error(`Missing grid value at (${r},${c}) for equation`);\n        validationErrors++;\n      }\n    }\n\n    if (positions.length === 3) {\n      const [A, B, C] = positions;\n      const op = eq.across ? grid[eq.row][eq.col + 1].ch : grid[eq.row + 1][eq.col].ch;\n\n      let isValid = false;\n      switch (op) {\n        case '+': isValid = (A + B === C); break;\n        case '-': isValid = (A - B === C); break;\n        case '\u00D7': isValid = (A * B === C); break;\n        case '\u00F7': isValid = (B !== 0 && A / B === C); break;\n      }\n\n      if (!isValid) {\n        console.error(`Invalid equation in grid: ${A} ${op} ${B} = ${C}`);\n        validationErrors++;\n      }\n    }\n  }\n\n  if (validationErrors > 0) {\n    console.warn(`Found ${validationErrors} validation errors in generated crossword`);\n  } else {\n    console.log('All equations validated successfully');\n  }\n\n  return {grid, equations};\n}\n\nfunction findValidEquationForConstraints2(constraints) {\n  // ENHANCED: Handle multiple constraints including operators and equals\n  // constraints: {pos0: value, pos1: op, pos2: value, pos3: '=', pos4: value}\n  const operations = getSelectedOperations().map(op => op.symbol);\n\n  for (let attempt = 0; attempt < 2000; attempt++) {\n    const eq = generateRandomEquation();\n\n    // Check if this equation satisfies ALL constraints\n    let valid = true;\n\n    for (const [pos, requiredValue] of Object.entries(constraints)) {\n      const position = parseInt(pos);\n      let actualValue;\n\n      if (position === 0) actualValue = eq.A;\n      else if (position === 1) actualValue = eq.op;\n      else if (position === 2) actualValue = eq.B;\n      else if (position === 3) actualValue = '=';\n      else if (position === 4) actualValue = eq.C;\n\n      if (actualValue !== requiredValue) {\n        valid = false;\n        break;\n      }\n    }\n\n    if (valid && validateEquation(eq.A, eq.B, eq.C, eq.op)) {\n      return eq;\n    }\n  }\n\n  // If no valid equation found with ALL constraints, try to build one systematically\n  const numConstraints = Object.keys(constraints).filter(pos => [0, 2, 4].includes(parseInt(pos)));\n  if (numConstraints.length >= 1) {\n    return buildEquationWithConstraints(constraints);\n  }\n\n  // Fallback to random equation\n  return generateRandomEquation();\n}\n\nfunction buildEquationWithConstraints(constraints) {\n  // Build equation systematically when we have specific number constraints\n  const operations = getSelectedOperations().map(op => op.symbol);\n\n  // Extract constraints\n  const A = constraints[0] ? parseInt(constraints[0]) : null;\n  const op = constraints[1] || null;\n  const B = constraints[2] ? parseInt(constraints[2]) : null;\n  const C = constraints[4] ? parseInt(constraints[4]) : null;\n\n  // Try to satisfy constraints systematically\n  for (const testOp of (op ? [op] : operations)) {\n    for (let attempt = 0; attempt < 100; attempt++) {\n      let testA, testB, testC;\n\n      if (A !== null && B !== null) {\n        // Both operands known, calculate result\n        testA = A;\n        testB = B;\n        if (testOp === '+') testC = testA + testB;\n        else if (testOp === '-') testC = testA - testB;\n        else if (testOp === '\u00D7') testC = testA * testB;\n        else if (testOp === '\u00F7' && testB !== 0 && testA % testB === 0) testC = testA / testB;\n        else continue;\n      } else if (A !== null && C !== null) {\n        // First operand and result known, calculate second operand\n        testA = A;\n        testC = C;\n        if (testOp === '+') testB = testC - testA;\n        else if (testOp === '-') testB = testA - testC;\n        else if (testOp === '\u00D7' && testA !== 0 && testC % testA === 0) testB = testC / testA;\n        else if (testOp === '\u00F7' && testA !== 0) testB = testA / testC;\n        else continue;\n      } else if (B !== null && C !== null) {\n        // Second operand and result known, calculate first operand\n        testB = B;\n        testC = C;\n        if (testOp === '+') testA = testC - testB;\n        else if (testOp === '-') testA = testC + testB;\n        else if (testOp === '\u00D7' && testB !== 0 && testC % testB === 0) testA = testC / testB;\n        else if (testOp === '\u00F7') testA = testC * testB;\n        else continue;\n      } else {\n        // Only one constraint, generate others randomly\n        const range = getNumberRange();\n        if (A !== null) {\n          testA = A;\n          testB = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;\n        } else if (B !== null) {\n          testB = B;\n          testA = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;\n        } else if (C !== null) {\n          testC = C;\n          testA = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;\n          testB = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;\n        }\n\n        // Calculate missing value\n        if (testC === undefined) {\n          if (testOp === '+') testC = testA + testB;\n          else if (testOp === '-') testC = testA - testB;\n          else if (testOp === '\u00D7') testC = testA * testB;\n          else if (testOp === '\u00F7' && testB !== 0 && testA % testB === 0) testC = testA / testB;\n          else continue;\n        }\n      }\n\n      // Validate the constructed equation\n      if (testA > 0 && testB > 0 && testC > 0 &&\n          testA <= 99 && testB <= 99 && testC <= 99 &&\n          validateEquation(testA, testB, testC, testOp)) {\n        return {A: testA, B: testB, C: testC, op: testOp};\n      }\n    }\n  }\n\n  // Fallback\n  return generateRandomEquation();\n}\n\nfunction getNewDifficultyTargets(difficulty, totalNumbers) {\n  console.log(`getNewDifficultyTargets called with: ${difficulty}, ${totalNumbers}`);\n\n  // Define difficulty levels with target percentages\n  const difficultySettings = {\n    expert: { min: 0.05, max: 0.40, name: 'Expert' },    // Target \u226440% - Ultra minimal for serious deduction\n    hard:   { min: 0.35, max: 0.50, name: 'Hard' },     // Target ~50% - Requires logical thinking\n    medium: { min: 0.55, max: 0.65, name: 'Medium' },   // Target ~60% - Moderate challenge\n    easy:   { min: 0.65, max: 0.75, name: 'Easy' }      // Target ~70% - More guidance\n  };\n\n  const setting = difficultySettings[difficulty] || difficultySettings.medium;\n  console.log(`Found setting:`, setting);\n\n  const result = {\n    minGivens: Math.ceil(totalNumbers * setting.min),\n    maxGivens: Math.ceil(totalNumbers * setting.max),\n    name: setting.name,\n    percentage: {\n      min: Math.round(setting.min * 100),\n      max: Math.round(setting.max * 100)\n    }\n  };\n\n  console.log(`Returning:`, result);\n  return result;\n}\n\nfunction canSolvePuzzle(grid, equations, givenPositions) {\n  // Create a copy of the grid with only givens\n  const solveGrid = Array.from({length: 24}, () => Array(24).fill(null));\n\n  // Place only the given cells\n  for (let r = 0; r < 24; r++) {\n    for (let c = 0; c < 24; c++) {\n      if (grid[r][c] && givenPositions.has(`${r},${c}`)) {\n        solveGrid[r][c] = grid[r][c];\n      } else if (grid[r][c]) {\n        solveGrid[r][c] = {k: grid[r][c].k, ch: grid[r][c].k === 'num' ? null : grid[r][c].ch, id: grid[r][c].id};\n      }\n    }\n  }\n\n  // Enhanced solving with multiple passes and techniques\n  let globalChanged = true;\n  let globalIterations = 0;\n  const maxGlobalIterations = 10;\n\n  while (globalChanged && globalIterations < maxGlobalIterations) {\n    globalChanged = false;\n    globalIterations++;\n\n    // Pass 1: Basic constraint propagation (equations with 2 knowns)\n    let changed = true;\n    let iterations = 0;\n    const maxIterations = 20;\n\n    while (changed && iterations < maxIterations) {\n      changed = false;\n      iterations++;\n\n      for (const eq of equations) {\n        const cells = [];\n        for (let i = 0; i < 5; i++) {\n          const r = eq.across ? eq.row : eq.row + i;\n          const c = eq.across ? eq.col + i : eq.col;\n          if (r < 24 && c < 24 && solveGrid[r][c]) {\n            cells.push({r, c, cell: solveGrid[r][c], pos: i});\n          }\n        }\n\n        if (cells.length === 5) {\n          const numCells = cells.filter(cell => cell.cell.k === 'num');\n          const opCell = cells.find(cell => cell.cell.k === 'op');\n\n          if (opCell && numCells.length >= 2) {\n            const knownValues = {};\n            const unknownPositions = [];\n\n            for (const numCell of numCells) {\n              if (numCell.cell.ch !== null) {\n                knownValues[numCell.pos] = parseInt(numCell.cell.ch);\n              } else {\n                unknownPositions.push(numCell.pos);\n              }\n            }\n\n            // If we have 2 known values, we can deduce the third\n            if (Object.keys(knownValues).length === 2 && unknownPositions.length === 1) {\n              const op = opCell.cell.ch;\n              const unknownPos = unknownPositions[0];\n              let deducedValue = null;\n\n              if (unknownPos === 0) { // Deduce A\n                const B = knownValues[2];\n                const C = knownValues[4];\n                if (op === '+') deducedValue = C - B;\n                else if (op === '-') deducedValue = C + B;\n                else if (op === '\u00D7') deducedValue = B !== 0 ? C / B : null;\n                else if (op === '\u00F7') deducedValue = C * B;\n              } else if (unknownPos === 2) { // Deduce B\n                const A = knownValues[0];\n                const C = knownValues[4];\n                if (op === '+') deducedValue = C - A;\n                else if (op === '-') deducedValue = A - C;\n                else if (op === '\u00D7') deducedValue = A !== 0 ? C / A : null;\n                else if (op === '\u00F7') deducedValue = A !== 0 ? A / C : null;\n              } else if (unknownPos === 4) { // Deduce C\n                const A = knownValues[0];\n                const B = knownValues[2];\n                if (op === '+') deducedValue = A + B;\n                else if (op === '-') deducedValue = A - B;\n                else if (op === '\u00D7') deducedValue = A * B;\n                else if (op === '\u00F7') deducedValue = B !== 0 ? A / B : null;\n              }\n\n              if (deducedValue !== null && deducedValue > 0 && deducedValue <= 99 && Number.isInteger(deducedValue)) {\n                const targetCell = cells.find(cell => cell.pos === unknownPos);\n                if (targetCell && targetCell.cell.ch === null) {\n                  targetCell.cell.ch = String(deducedValue);\n                  changed = true;\n                  globalChanged = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Pass 2: Advanced constraint analysis (single constraints with intersection analysis)\n    for (const eq of equations) {\n      const cells = [];\n      for (let i = 0; i < 5; i++) {\n        const r = eq.across ? eq.row : eq.row + i;\n        const c = eq.across ? eq.col + i : eq.col;\n        if (r < 24 && c < 24 && solveGrid[r][c]) {\n          cells.push({r, c, cell: solveGrid[r][c], pos: i});\n        }\n      }\n\n      if (cells.length === 5) {\n        const numCells = cells.filter(cell => cell.cell.k === 'num');\n        const opCell = cells.find(cell => cell.cell.k === 'op');\n\n        if (opCell && numCells.length >= 1) {\n          const knownValues = {};\n          const unknownPositions = [];\n\n          for (const numCell of numCells) {\n            if (numCell.cell.ch !== null) {\n              knownValues[numCell.pos] = parseInt(numCell.cell.ch);\n            } else {\n              unknownPositions.push(numCell.pos);\n            }\n          }\n\n          // Advanced: Try to solve with 1 known + intersection constraints\n          if (Object.keys(knownValues).length === 1 && unknownPositions.length === 2) {\n            // Try to deduce one unknown from intersection constraints\n            for (const unknownPos of unknownPositions) {\n              const cell = cells.find(c => c.pos === unknownPos);\n              const possibleValues = getPossibleValuesFromIntersections(solveGrid, equations, cell.r, cell.c);\n\n              if (possibleValues && possibleValues.length === 1) {\n                // Only one possible value from intersections - use it\n                cell.cell.ch = String(possibleValues[0]);\n                globalChanged = true;\n                break; // Process one at a time\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Check if puzzle is completely solved\n  for (let r = 0; r < 24; r++) {\n    for (let c = 0; c < 24; c++) {\n      if (grid[r][c] && grid[r][c].k === 'num') {\n        if (!solveGrid[r][c] || solveGrid[r][c].ch === null) {\n          return false; // Not solvable\n        }\n      }\n    }\n  }\n\n  return true; // Puzzle is solvable\n}\n\nfunction getPossibleValuesFromIntersections(solveGrid, equations, targetR, targetC) {\n  // Find intersecting equations that constrain this position\n  const possibleValues = [];\n  const range = getNumberRange();\n\n  for (let testValue = range.min; testValue <= range.max; testValue++) {\n    let isValid = true;\n\n    // Test if this value would be consistent with all intersecting equations\n    for (const eq of equations) {\n      let isInThisEquation = false;\n      let positionInEquation = -1;\n\n      // Check if this position is part of this equation\n      for (let i = 0; i < 5; i += 2) {\n        const eqR = eq.across ? eq.row : eq.row + i;\n        const eqC = eq.across ? eq.col + i : eq.col;\n        if (eqR === targetR && eqC === targetC) {\n          isInThisEquation = true;\n          positionInEquation = i;\n          break;\n        }\n      }\n\n      if (isInThisEquation) {\n        // This equation contains our target position\n        const eqCells = [];\n        for (let i = 0; i < 5; i++) {\n          const eqR = eq.across ? eq.row : eq.row + i;\n          const eqC = eq.across ? eq.col + i : eq.col;\n          if (eqR < 24 && eqC < 24 && solveGrid[eqR][eqC]) {\n            eqCells.push({r: eqR, c: eqC, cell: solveGrid[eqR][eqC], pos: i});\n          }\n        }\n\n        if (eqCells.length === 5) {\n          const numCells = eqCells.filter(cell => cell.cell.k === 'num');\n          const opCell = eqCells.find(cell => cell.cell.k === 'op');\n\n          if (opCell && numCells.length === 3) {\n            // Build equation with test value\n            const values = {};\n            let hasUnknowns = false;\n\n            for (const numCell of numCells) {\n              if (numCell.r === targetR && numCell.c === targetC) {\n                values[numCell.pos] = testValue;\n              } else if (numCell.cell.ch !== null) {\n                values[numCell.pos] = parseInt(numCell.cell.ch);\n              } else {\n                hasUnknowns = true;\n              }\n            }\n\n            // If we have at least 2 values (including our test), check equation validity\n            if (Object.keys(values).length >= 2 && !hasUnknowns) {\n              const A = values[0];\n              const B = values[2];\n              const C = values[4];\n              const op = opCell.cell.ch;\n\n              if (A !== undefined && B !== undefined && C !== undefined) {\n                if (!evalOk(A, op, B, C)) {\n                  isValid = false;\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (isValid) {\n      possibleValues.push(testValue);\n    }\n  }\n\n  return possibleValues;\n}\n\nfunction createsMathematicalAmbiguity(grid, equations, givenPositions) {\n  // ULTRA-PERMISSIVE for expert mode - only prevent the most extreme impossibilities\n\n  for (const eq of equations) {\n    const eqPositions = [];\n    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        eqPositions.push({r, c, pos: i});\n      }\n    }\n\n    const givenCount = eqPositions.filter(pos => givenPositions.has(`${pos.r},${pos.c}`)).length;\n\n    // ONLY prevent equations with absolutely NO constraints\n    if (givenCount === 0) {\n      console.log('Mathematical ambiguity: equation with 0 givens');\n      return true; // No constraints = infinite solutions\n    }\n\n    // For equations with only 1 given, check if it's COMPLETELY isolated\n    // Only flag if there are literally NO intersections at all for ANY empty position\n    if (eqPositions.length >= 3 && givenCount === 1) {\n      let totalIntersections = 0;\n\n      for (const pos of eqPositions) {\n        if (!givenPositions.has(`${pos.r},${pos.c}`)) {\n          // Count intersections for this empty position\n          for (const otherEq of equations) {\n            if (otherEq === eq) continue;\n\n            for (let j = 0; j < 5; j += 2) {\n              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;\n              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;\n\n              if (otherR === pos.r && otherC === pos.c) {\n                totalIntersections++;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      // Only flag if this equation has ZERO intersections total\n      // This is extremely rare with high connectivity\n      if (totalIntersections === 0) {\n        console.log(`Mathematical ambiguity: equation has zero intersections total`);\n        return true;\n      }\n    }\n  }\n\n  return false; // Allow everything else - trust the connectivity network\n}\n\nfunction getDifficultyTargets(difficulty, totalNumbers) {\n  // Define difficulty levels with target percentages\n  const difficultySettings = {\n    expert: { min: 0.05, max: 0.40, name: 'Expert' },    // Target \u226440% - Ultra minimal clues for serious deduction\n    hard:   { min: 0.35, max: 0.50, name: 'Hard' },     // Target ~50% - Requires logical thinking\n    medium: { min: 0.55, max: 0.65, name: 'Medium' },   // Target ~60% - Moderate challenge\n    easy:   { min: 0.65, max: 0.75, name: 'Easy' }      // Target ~70% - More guidance\n  };\n\n  const setting = difficultySettings[difficulty] || difficultySettings.medium;\n  return {\n    minGivens: Math.ceil(totalNumbers * setting.min),\n    maxGivens: Math.ceil(totalNumbers * setting.max),\n    name: setting.name\n  };\n}\n\nfunction isCompleteEquation(grid, equations, givenSet) {\n  // Check if any equation has ALL its numbers given (making it trivial)\n  for (const eq of equations) {\n    const numberPositions = [];\n    let givenNumbers = 0;\n\n    // Find all number positions in this equation\n    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (the numbers)\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        numberPositions.push({r, c});\n        if (givenSet.has(`${r},${c}`)) {\n          givenNumbers++;\n        }\n      }\n    }\n\n    // If ALL numbers in this equation are given, it's complete (trivial)\n    if (numberPositions.length > 0 && givenNumbers === numberPositions.length) {\n      return true;\n    }\n\n    // Also check for equations where 4+ out of 5 numbers are given (nearly complete)\n    if (numberPositions.length >= 4 && givenNumbers >= numberPositions.length - 1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction hasAnyIsolatedEquations(grid, equations, givenSet) {\n  // Check and fix equations with insufficient givens to determine a unique solution\n  let foundIssues = false;\n\n  for (const eq of equations) {\n    const eqPositions = [];\n    for (let i = 0; i < 5; i += 2) { // Check positions 0, 2, 4 (the numbers)\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        eqPositions.push({r, c, pos: i});\n      }\n    }\n\n    // Count givens in this equation\n    const givenCount = eqPositions.filter(pos => givenSet.has(`${pos.r},${pos.c}`)).length;\n\n    // CRITICAL: Equations need sufficient givens to prevent ambiguity\n    if (givenCount === 0) {\n      foundIssues = true;\n      continue; // No givens = unsolvable, but continue checking other equations\n    }\n\n    // For equations with 3 numbers (A op B = C), having only 1 given can create ambiguity\n    // We need to ensure ALL empty positions have intersecting constraints\n    if (eqPositions.length >= 3 && givenCount === 1) {\n      let emptyPositionsWithConstraints = 0;\n      let totalEmptyPositions = 0;\n\n      for (const pos of eqPositions) {\n        if (!givenSet.has(`${pos.r},${pos.c}`)) {\n          totalEmptyPositions++;\n\n          // Check if this empty position intersects with other equations that have constraints\n          let hasIntersectionConstraint = false;\n          for (const otherEq of equations) {\n            if (otherEq === eq) continue; // Skip same equation\n\n            // Check if this position intersects with the other equation\n            for (let j = 0; j < 5; j += 2) {\n              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;\n              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;\n\n              if (otherR === pos.r && otherC === pos.c) {\n                // Found intersection! Check if other equation has sufficient constraints\n                const otherPositions = [];\n                for (let k = 0; k < 5; k += 2) {\n                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;\n                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;\n                  if (checkR < 24 && checkC < 24) {\n                    otherPositions.push(`${checkR},${checkC}`);\n                  }\n                }\n                const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;\n                const otherEmptyCount = otherPositions.length - otherGivenCount;\n\n                // The intersecting equation must have enough constraints to determine this value\n                // For a 3-number equation, need at least 2 knowns (including intersections)\n                if (otherGivenCount >= 2 || (otherGivenCount === 1 && otherEmptyCount === 1)) {\n                  hasIntersectionConstraint = true;\n                }\n                break;\n              }\n            }\n            if (hasIntersectionConstraint) break;\n          }\n\n          if (hasIntersectionConstraint) {\n            emptyPositionsWithConstraints++;\n          }\n        }\n      }\n\n      // ALL empty positions must have intersection constraints to prevent ambiguity\n      // Example: \"_ - _ = 11\" needs both operands constrained by intersections\n      if (totalEmptyPositions > 0 && emptyPositionsWithConstraints < totalEmptyPositions) {\n        // Instead of rejecting, add a strategic given to fix this equation\n        const unconstrainedPositions = [];\n        for (const pos of eqPositions) {\n          if (!givenSet.has(`${pos.r},${pos.c}`)) {\n            // Check if this position lacks intersection constraints\n            let hasConstraint = false;\n            for (const otherEq of equations) {\n              if (otherEq === eq) continue;\n              for (let j = 0; j < 5; j += 2) {\n                const otherR = otherEq.across ? otherEq.row : otherEq.row + j;\n                const otherC = otherEq.across ? otherEq.col + j : otherEq.col;\n                if (otherR === pos.r && otherC === pos.c) {\n                  const otherPositions = [];\n                  for (let k = 0; k < 5; k += 2) {\n                    const checkR = otherEq.across ? otherEq.row : otherEq.row + k;\n                    const checkC = otherEq.across ? otherEq.col + k : otherEq.col;\n                    if (checkR < 24 && checkC < 24) {\n                      otherPositions.push(`${checkR},${checkC}`);\n                    }\n                  }\n                  const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;\n                  const otherEmptyCount = otherPositions.length - otherGivenCount;\n                  if (otherGivenCount >= 2 || (otherGivenCount === 1 && otherEmptyCount === 1)) {\n                    hasConstraint = true;\n                    break;\n                  }\n                }\n              }\n              if (hasConstraint) break;\n            }\n            if (!hasConstraint) {\n              unconstrainedPositions.push(`${pos.r},${pos.c}`);\n            }\n          }\n        }\n\n        // Add a given to one of the unconstrained positions to fix the equation\n        if (unconstrainedPositions.length > 0) {\n          givenSet.add(unconstrainedPositions[0]);\n          // Continue checking other equations instead of returning true\n        }\n      }\n    }\n\n    // If only 1 given and equation has 2 numbers, check if there are intersecting constraints\n    if (givenCount === 1 && eqPositions.length === 2) {\n      let hasIntersectingConstraints = false;\n\n      // Check each number position for intersections with other equations\n      for (const pos of eqPositions) {\n        if (!givenSet.has(`${pos.r},${pos.c}`)) {\n          // This position is not given, check if it intersects with other equations that have constraints\n          for (const otherEq of equations) {\n            if (otherEq === eq) continue; // Skip same equation\n\n            // Check if this position intersects with the other equation\n            for (let j = 0; j < 5; j += 2) {\n              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;\n              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;\n\n              if (otherR === pos.r && otherC === pos.c) {\n                // Found intersection! Check if other equation has enough constraints\n                const otherPositions = [];\n                for (let k = 0; k < 5; k += 2) {\n                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;\n                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;\n                  if (checkR < 24 && checkC < 24) {\n                    otherPositions.push(`${checkR},${checkC}`);\n                  }\n                }\n                const otherGivenCount = otherPositions.filter(p => givenSet.has(p)).length;\n                if (otherGivenCount >= 2) {\n                  hasIntersectingConstraints = true;\n                  break;\n                }\n              }\n            }\n            if (hasIntersectingConstraints) break;\n          }\n          if (hasIntersectingConstraints) break;\n        }\n      }\n\n      // If no intersecting constraints found, this equation is isolated\n      if (!hasIntersectingConstraints) {\n        foundIssues = true;\n      }\n    }\n  }\n  return foundIssues;\n}\n\nfunction selectOptimalGivens(grid, equations, difficulty) {\n  // Get all number cells for difficulty calculation\n  const numCells = [];\n  for (let r = 0; r < 24; r++) {\n    for (let c = 0; c < 24; c++) {\n      if (grid[r] && grid[r][c] && grid[r][c].k === 'num') {\n        numCells.push({r, c});\n      }\n    }\n  }\n\n  const difficultyTargets = getDifficultyTargets(difficulty, numCells.length);\n\n  // Start with strategic givens - ALWAYS ensure at least 1 number per equation for unique solutions\n  const strategicGivens = new Set();\n\n  // Start with minimal strategic givens - let intersections provide constraints\n  for (const eq of equations) {\n    const eqNumbers = [];\n    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        eqNumbers.push({pos: `${r},${c}`, index: i});\n      }\n    }\n\n    if (eqNumbers.length > 0) {\n      // Start with just 1 number per equation - let intersections provide additional constraints\n      const shuffledNumbers = eqNumbers.sort(() => Math.random() - 0.5);\n      strategicGivens.add(shuffledNumbers[0].pos);\n\n      // For easier difficulties, add one more number to some equations\n      if (difficulty === 'easy' && Math.random() < 0.5) {\n        if (eqNumbers.length >= 2) {\n          strategicGivens.add(shuffledNumbers[1].pos);\n        }\n      } else if (difficulty === 'medium' && Math.random() < 0.3) {\n        if (eqNumbers.length >= 2) {\n          strategicGivens.add(shuffledNumbers[1].pos);\n        }\n      }\n    }\n  }\n\n  // Let intersection-based solving work - don't force additional givens here\n\n  // For expert level, be more aggressive about accepting minimal puzzles\n  if (difficulty === 'expert') {\n    // Try to solve with just strategic givens first\n    const hasIsolated = hasAnyIsolatedEquations(grid, equations, strategicGivens);\n    const isSolvable = canSolvePuzzle(grid, equations, strategicGivens);\n\n    // Accept expert puzzle if it's solvable, even if it has some challenges\n    if (isSolvable && strategicGivens.size >= Math.max(1, Math.floor(difficultyTargets.minGivens * 0.5))) {\n      return { givens: strategicGivens, difficulty: difficultyTargets };\n    }\n\n    // For expert, try adding just 1-2 more strategic clues if needed\n    const expertNumberCells = [];\n    for (let r = 0; r < 24; r++) {\n      for (let c = 0; c < 24; c++) {\n        if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {\n          expertNumberCells.push({r, c});\n        }\n      }\n    }\n\n    const remaining = expertNumberCells.filter(cell => !strategicGivens.has(`${cell.r},${cell.c}`));\n    const shuffled = remaining.sort(() => Math.random() - 0.5);\n\n    let expertGivens = new Set([...strategicGivens]);\n    for (let i = 0; i < Math.min(3, shuffled.length); i++) {\n      expertGivens.add(`${shuffled[i].r},${shuffled[i].c}`);\n      if (canSolvePuzzle(grid, equations, expertGivens) &&\n          !isCompleteEquation(grid, equations, expertGivens)) {\n        return { givens: expertGivens, difficulty: difficultyTargets };\n      }\n    }\n\n    // Expert fallback: if we still can't generate, use the regular algorithm but limit maximum\n    // This ensures expert puzzles don't fail to generate\n    if (strategicGivens.size > 0) {\n      // Continue to regular algorithm but with stricter limits for expert\n    }\n  }\n\n  // Add more givens until we reach the minimum for this difficulty\n  const fallbackNumberCells = [];\n  for (let r = 0; r < 24; r++) {\n    for (let c = 0; c < 24; c++) {\n      if (grid[r] && grid[r][c] && grid[r][c].type === 'number') {\n        fallbackNumberCells.push({r, c});\n      }\n    }\n  }\n  const remaining = fallbackNumberCells.filter(cell => !strategicGivens.has(`${cell.r},${cell.c}`));\n  const shuffled = remaining.sort(() => Math.random() - 0.5);\n\n  let currentGivens = new Set([...strategicGivens]);\n  let addedIndex = 0;\n\n  // Keep adding until we have enough givens and it's properly solvable\n  while (addedIndex < shuffled.length) {\n    const needsMoreForDifficulty = currentGivens.size < difficultyTargets.minGivens;\n    const isSolvable = canSolvePuzzle(grid, equations, currentGivens);\n    const hasCompleteEquation = isCompleteEquation(grid, equations, currentGivens);\n    const hasIsolated = hasAnyIsolatedEquations(grid, equations, currentGivens);\n\n    // For expert, be much more strict about complete equations\n    if (difficulty === 'expert') {\n      if (isSolvable && currentGivens.size >= difficultyTargets.minGivens && !hasCompleteEquation) {\n        break; // Expert level: accept if solvable with minimal clues, must not have complete equations\n      }\n      // Expert level: NEVER accept any complete equations, even if isolated\n      if (hasCompleteEquation) {\n        // Force continue to avoid this configuration\n        if (addedIndex >= shuffled.length) break; // Prevent infinite loop\n      }\n    } else {\n      if (!needsMoreForDifficulty && isSolvable && !hasCompleteEquation && !hasIsolated) {\n        break; // Other difficulties: standard requirements\n      }\n    }\n\n    if (addedIndex < shuffled.length) {\n      const testGivens = new Set([...currentGivens]);\n      testGivens.add(`${shuffled[addedIndex].r},${shuffled[addedIndex].c}`);\n\n      // Only add if it doesn't create a complete equation\n      if (!isCompleteEquation(grid, equations, testGivens)) {\n        currentGivens.add(`${shuffled[addedIndex].r},${shuffled[addedIndex].c}`);\n      }\n      addedIndex++;\n    } else {\n      break;\n    }\n\n    // Stop if we exceed maximum for this difficulty and meet all criteria\n    if (difficulty === 'expert') {\n      // For expert, stop much earlier to keep puzzles challenging\n      if (currentGivens.size >= difficultyTargets.maxGivens && canSolvePuzzle(grid, equations, currentGivens)) {\n        break; // Expert: stop at max limit if solvable, regardless of other criteria\n      }\n    } else {\n      if (currentGivens.size >= difficultyTargets.maxGivens &&\n          canSolvePuzzle(grid, equations, currentGivens) &&\n          !isCompleteEquation(grid, equations, currentGivens) &&\n          !hasAnyIsolatedEquations(grid, equations, currentGivens)) {\n        break;\n      }\n    }\n  }\n\n  // FINAL SAFETY CHECK: Only add givens for truly isolated equations\n  for (const eq of equations) {\n    const eqNumbers = [];\n    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        eqNumbers.push(`${r},${c}`);\n      }\n    }\n\n    // Count givens in this equation\n    const givenCount = eqNumbers.filter(pos => currentGivens.has(pos)).length;\n\n    // Only enforce minimum givens if equation has NO givens at all\n    if (eqNumbers.length > 0 && givenCount === 0) {\n      // Ensure at least 1 given to prevent completely unsolvable equations\n      currentGivens.add(eqNumbers[0]);\n    }\n  }\n\n  // OPTIMIZATION: Remove redundant givens from over-constrained equations\n  // Example: if we have \"36 - 14 = 22\" with both 36 and 22 given, we can remove 22\n  const optimizedGivens = new Set([...currentGivens]);\n\n  for (const eq of equations) {\n    const eqNumbers = [];\n    for (let i = 0; i < 5; i += 2) { // positions 0, 2, 4 are numbers (A, B, C)\n      const r = eq.across ? eq.row : eq.row + i;\n      const c = eq.across ? eq.col + i : eq.col;\n      if (r < 24 && c < 24) {\n        eqNumbers.push({pos: `${r},${c}`, index: i});\n      }\n    }\n\n    if (eqNumbers.length === 3) { // A op B = C equation\n      const givenPositions = eqNumbers.filter(num => optimizedGivens.has(num.pos));\n\n      // If we have 3 givens (all positions), we can safely remove one\n      if (givenPositions.length === 3) {\n        // Remove the result (position 4 = C) as it's most redundant\n        const resultPos = eqNumbers.find(num => num.index === 4);\n        if (resultPos) {\n          optimizedGivens.delete(resultPos.pos);\n        }\n      }\n      // If we have exactly 2 givens, check if one can be removed due to intersections\n      else if (givenPositions.length === 2) {\n        // For each given position, check if it has strong intersection constraints\n        for (const givenPos of givenPositions) {\n          const [r, c] = givenPos.pos.split(',').map(Number);\n\n          // Count intersections with well-constrained equations\n          let strongIntersections = 0;\n          for (const otherEq of equations) {\n            if (otherEq === eq) continue;\n\n            // Check if this position intersects with the other equation\n            for (let j = 0; j < 5; j += 2) {\n              const otherR = otherEq.across ? otherEq.row : otherEq.row + j;\n              const otherC = otherEq.across ? otherEq.col + j : otherEq.col;\n\n              if (otherR === r && otherC === c) {\n                // Found intersection! Check if other equation is well-constrained\n                const otherPositions = [];\n                for (let k = 0; k < 5; k += 2) {\n                  const checkR = otherEq.across ? otherEq.row : otherEq.row + k;\n                  const checkC = otherEq.across ? otherEq.col + k : otherEq.col;\n                  if (checkR < 24 && checkC < 24) {\n                    otherPositions.push(`${checkR},${checkC}`);\n                  }\n                }\n                const otherGivenCount = otherPositions.filter(p => optimizedGivens.has(p)).length;\n\n                // If the intersecting equation has 2+ givens, it provides strong constraint\n                if (otherGivenCount >= 2) {\n                  strongIntersections++;\n                }\n                break;\n              }\n            }\n          }\n\n          // If this position has strong intersection constraints, we might be able to remove it\n          // But only for non-expert difficulties to avoid making puzzles too hard\n          if (strongIntersections >= 1 && difficulty !== 'expert') {\n            // Prefer removing the result (C) over operands (A, B) for cleaner puzzles\n            if (givenPos.index === 4) { // This is the result position\n              optimizedGivens.delete(givenPos.pos);\n              break; // Only remove one per equation\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return { givens: optimizedGivens, difficulty: difficultyTargets };\n}\n\nfunction drawCompletedCrossword(model, difficulty) {\n  const {grid, equations, optimizedGivens} = model;\n\n  // Use the optimized givens from backward generation\n  const givenSet = optimizedGivens || new Set();\n\n  // Find bounds of used cells to crop the display\n  const usedCells = [];\n  for(let r = 0; r < 24; r++) {\n    for(let c = 0; c < 24; c++) {\n      if(grid[r][c]) {\n        usedCells.push({r, c});\n      }\n    }\n  }\n\n  const minR = Math.min(...usedCells.map(p => p.r));\n  const maxR = Math.max(...usedCells.map(p => p.r));\n  const minC = Math.min(...usedCells.map(p => p.c));\n  const maxC = Math.max(...usedCells.map(p => p.c));\n\n  const gridRows = maxR - minR + 1;\n  const gridCols = maxC - minC + 1;\n\n  // Use smaller cell size for better overview of the whole puzzle\n  const cellSize = Math.min(32, Math.floor(320 / Math.max(gridRows, gridCols))); // 20% smaller: 40->32, 400->320\n  const W = gridCols * cellSize;\n  const H = gridRows * cellSize;\n\n  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);\n  svg.setAttribute('width', W);\n  svg.setAttribute('height', H);\n  svg.innerHTML = '';\n\n  // Draw grid\n  for(let r = minR; r <= maxR; r++) {\n    for(let c = minC; c <= maxC; c++) {\n      const x = (c - minC) * cellSize;\n      const y = (r - minR) * cellSize;\n      const cell = grid[r][c];\n\n      if(cell) {\n        // Draw cell background\n        svg.appendChild(t('rect', {\n          x, y, width: cellSize, height: cellSize,\n          fill: '#fff', stroke: '#000', 'stroke-width': 2\n        }));\n\n        // Draw text\n        let text = cell.ch;\n        if(cell.k === 'num' && !ans.checked) {\n          text = givenSet.has(`${r},${c}`) ? cell.ch : '';\n        }\n\n        const fontSize = Math.max(12, text.length >= 2 ? cellSize * 0.5 : cellSize * 0.7);\n        const textEl = t('text', {\n          x: x + cellSize/2,\n          y: y + cellSize/2 + fontSize/4,\n          'text-anchor': 'middle',\n          'dominant-baseline': 'middle',\n          'font-size': fontSize,\n          'font-family': 'Arial, sans-serif',\n          'font-weight': 'bold'\n        });\n        textEl.textContent = text;\n        svg.appendChild(textEl);\n      }\n    }\n  }\n\n  // Draw border\n  svg.appendChild(t('rect', {\n    x: 0, y: 0, width: W, height: H,\n    fill: 'none', stroke: '#000', 'stroke-width': 3\n  }));\n\n  // Hide SVG and generate colorful HTML version for screen\n  document.getElementById('grid').style.display = 'none';\n\n  // Generate colorful screen and print versions\n  generateScreenVersion(grid, givenSet, minR, maxR, minC, maxC);\n  generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC);\n\n  // Count number cells for stats\n  const numCells = [];\n  for(let r = 0; r < 24; r++) {\n    for(let c = 0; c < 24; c++) {\n      if(grid[r][c] && grid[r][c].k === 'num') {\n        numCells.push({r, c});\n      }\n    }\n  }\n\n  const difficultyTargets = getDifficultyTargets(difficulty, numCells.length);\n  return {numTotal: numCells.length, actualGivens: givenSet.size, difficulty: difficultyTargets};\n}\n\nfunction drawSimpleCrossword(model, difficulty) {\n  const {grid, equations} = model;\n\n  // Collect number cells\n  const numCells = [];\n  for(let r = 0; r < 24; r++) {\n    for(let c = 0; c < 24; c++) {\n      if(grid[r][c] && grid[r][c].k === 'num') {\n        numCells.push({r, c});\n      }\n    }\n  }\n\n  // Select optimal givens that ensure solvability for the chosen difficulty\n  const result = selectOptimalGivens(grid, equations, difficulty);\n  const givenSet = result.givens;\n\n  // Find bounds of used cells to crop the display\n  const usedCells = [];\n  for(let r = 0; r < 24; r++) {\n    for(let c = 0; c < 24; c++) {\n      if(grid[r][c]) {\n        usedCells.push({r, c});\n      }\n    }\n  }\n\n  const minR = Math.min(...usedCells.map(p => p.r));\n  const maxR = Math.max(...usedCells.map(p => p.r));\n  const minC = Math.min(...usedCells.map(p => p.c));\n  const maxC = Math.max(...usedCells.map(p => p.c));\n\n  const gridRows = maxR - minR + 1;\n  const gridCols = maxC - minC + 1;\n\n  // Dynamic sizing for both web and print\n  const containerWidth = Math.min(window.innerWidth - 120, 900); // Responsive to screen width\n  const containerHeight = Math.min(window.innerHeight - 400, 600); // Leave space for controls\n\n  // A4 constraints (210mm x 297mm with safe margins to prevent overflow)\n  const a4PortraitWidth = 175;  // 210mm - 35mm margins (safer)\n  const a4PortraitHeight = 250; // 297mm - 47mm margins\n  const a4LandscapeWidth = 225; // 297mm - 72mm margins (extra safe for landscape)\n  const a4LandscapeHeight = 175; // 210mm - 35mm margins (rotated)\n  const mmToPx = 3.78; // Approximate conversion\n\n  // Try both orientations and pick the best fit\n  const portraitCellSizeByWidth = Math.floor((a4PortraitWidth * mmToPx) / gridCols);\n  const portraitCellSizeByHeight = Math.floor((a4PortraitHeight * mmToPx) / gridRows);\n  const portraitCellSize = Math.min(portraitCellSizeByWidth, portraitCellSizeByHeight);\n\n  const landscapeCellSizeByWidth = Math.floor((a4LandscapeWidth * mmToPx) / gridCols);\n  const landscapeCellSizeByHeight = Math.floor((a4LandscapeHeight * mmToPx) / gridRows);\n  const landscapeCellSize = Math.min(landscapeCellSizeByWidth, landscapeCellSizeByHeight);\n\n  // Choose orientation that gives larger cells\n  const usePortrait = portraitCellSize >= landscapeCellSize;\n  const a4CellSize = Math.max(portraitCellSize, landscapeCellSize);\n\n  // Calculate cell size to fit both web and A4 constraints\n  const webCellSizeByWidth = Math.floor(containerWidth / gridCols);\n  const webCellSizeByHeight = Math.floor(containerHeight / gridRows);\n\n  // Use web constraints for screen display (separate from print sizing)\n  const cellSize = Math.min(webCellSizeByWidth, webCellSizeByHeight, 80); // Screen-optimized size\n\n  // Store orientation for print function\n  window.preferredPrintOrientation = usePortrait ? 'portrait' : 'landscape';\n\n  const W = gridCols * cellSize;\n  const H = gridRows * cellSize;\n  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);\n  svg.setAttribute('width', W);\n  svg.setAttribute('height', H);\n  svg.innerHTML = '';\n\n  // Draw grid\n  for(let r = minR; r <= maxR; r++) {\n    for(let c = minC; c <= maxC; c++) {\n      const x = (c - minC) * cellSize;\n      const y = (r - minR) * cellSize;\n      const cell = grid[r][c];\n\n      if(cell) {\n        // Draw cell background\n        svg.appendChild(t('rect', {\n          x, y, width: cellSize, height: cellSize,\n          fill: '#fff', stroke: '#000', 'stroke-width': 2\n        }));\n\n        // Draw text\n        let text = cell.ch;\n        if(cell.k === 'num' && !ans.checked) {\n          text = givenSet.has(`${r},${c}`) ? cell.ch : '';\n        }\n\n        const fontSize = Math.max(12, text.length >= 2 ? cellSize * 0.5 : cellSize * 0.7);\n        const textEl = t('text', {\n          x: x + cellSize/2,\n          y: y + cellSize/2 + fontSize/4,\n          'text-anchor': 'middle',\n          'dominant-baseline': 'middle',\n          'font-size': fontSize,\n          'font-family': 'Arial, sans-serif',\n          'font-weight': 'bold'\n        });\n        textEl.textContent = text;\n        svg.appendChild(textEl);\n      }\n    }\n  }\n\n  // Draw border\n  svg.appendChild(t('rect', {\n    x: 0, y: 0, width: W, height: H,\n    fill: 'none', stroke: '#000', 'stroke-width': 3\n  }));\n\n  // Hide SVG and generate colorful HTML version for screen\n  document.getElementById('grid').style.display = 'none';\n\n  // Generate colorful screen version\n  const screenGrid = document.getElementById('screenGrid');\n  const container = document.createElement('div');\n  container.className = 'print-grid';\n\n  // Use same cell size as calculated above for consistency\n  const gridWidth = (maxC - minC + 1) * cellSize;\n  const gridHeight = (maxR - minR + 1) * cellSize;\n  container.style.width = gridWidth + 'px';\n  container.style.height = gridHeight + 'px';\n\n  let cellCounter = 0;\n\n  // Create colorful cells for screen\n  for (let r = minR; r <= maxR; r++) {\n    for (let c = minC; c <= maxC; c++) {\n      const gridCell = grid[r][c];\n\n      if (gridCell) {\n        const cell = document.createElement('div');\n        cell.className = 'print-cell screen-view';\n\n        // Position the cell\n        const x = (c - minC) * cellSize;\n        const y = (r - minR) * cellSize;\n        cell.style.left = x + 'px';\n        cell.style.top = y + 'px';\n        cell.style.width = cellSize + 'px';\n        cell.style.height = cellSize + 'px';\n        cell.style.fontSize = Math.max(12, Math.floor(cellSize * 0.4)) + 'px';\n\n        // Add border classes for cells that need right/bottom borders\n        const hasRightNeighbor = grid[r] && grid[r][c + 1];\n        if (!hasRightNeighbor) cell.classList.add('border-right');\n\n        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];\n        if (!hasBottomNeighbor) cell.classList.add('border-bottom');\n\n        // Set content and colors\n        let text = gridCell.ch;\n        let isGiven = false;\n\n        if (gridCell.k === 'num' && !ans.checked) {\n          isGiven = givenSet.has(`${r},${c}`);\n          text = isGiven ? gridCell.ch : '';\n        }\n\n        cell.textContent = text;\n\n        // Apply colors based on content type\n        if (gridCell.k === 'op') {\n          switch (gridCell.ch) {\n            case '+': cell.classList.add('op-add'); break;\n            case '-': cell.classList.add('op-sub'); break;\n            case '\u00D7': cell.classList.add('op-mul'); break;\n            case '\u00F7': cell.classList.add('op-div'); break;\n          }\n        } else if (gridCell.k === 'eq') {\n          cell.classList.add('op-eq');\n        } else if (gridCell.k === 'num') {\n          if (isGiven && !ans.checked) {\n            cell.classList.add('given');\n          } else {\n            cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');\n          }\n          cellCounter++;\n        }\n\n        container.appendChild(cell);\n      }\n    }\n  }\n\n  screenGrid.innerHTML = '';\n  screenGrid.appendChild(container);\n\n  // Generate print version\n  generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC);\n\n  return {numTotal: numCells.length, actualGivens: givenSet.size, difficulty: result.difficulty};\n}\n\nfunction generateScreenVersion(grid, givenSet, minR, maxR, minC, maxC) {\n  const screenGrid = document.getElementById('screenGrid');\n  const container = document.createElement('div');\n  container.className = 'print-grid';\n\n  // Calculate container size - smaller for better overview (20% smaller: 30->24)\n  const cellSize = 24;\n  const gridWidth = (maxC - minC + 1) * cellSize;\n  const gridHeight = (maxR - minR + 1) * cellSize;\n  container.style.width = gridWidth + 'px';\n  container.style.height = gridHeight + 'px';\n\n  let cellCounter = 0;\n\n  // Create colorful cells for screen\n  for (let r = minR; r <= maxR; r++) {\n    for (let c = minC; c <= maxC; c++) {\n      const gridCell = grid[r][c];\n\n      if (gridCell) {\n        const cell = document.createElement('div');\n        cell.className = 'print-cell screen-view';\n\n        // Position the cell\n        const x = (c - minC) * cellSize;\n        const y = (r - minR) * cellSize;\n        cell.style.left = x + 'px';\n        cell.style.top = y + 'px';\n        cell.style.width = cellSize + 'px';\n        cell.style.height = cellSize + 'px';\n        cell.style.fontSize = Math.floor(cellSize * 0.6) + 'px';\n\n        // Add border classes for cells that need right/bottom borders\n        // Check if there's no cell to the right\n        const hasRightNeighbor = grid[r] && grid[r][c + 1];\n        if (!hasRightNeighbor) cell.classList.add('border-right');\n\n        // Check if there's no cell below\n        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];\n        if (!hasBottomNeighbor) cell.classList.add('border-bottom');\n\n        // Set content and colors\n        let text = gridCell.ch;\n        let isGiven = false;\n\n        if (gridCell.k === 'num' && !ans.checked) {\n          isGiven = givenSet.has(`${r},${c}`);\n          text = isGiven ? gridCell.ch : '';\n        }\n\n        cell.textContent = text;\n\n        // Apply colors based on content type\n        if (gridCell.k === 'op') {\n          switch (gridCell.ch) {\n            case '+': cell.classList.add('op-add'); break;\n            case '-': cell.classList.add('op-sub'); break;\n            case '\u00D7': cell.classList.add('op-mul'); break;\n            case '\u00F7': cell.classList.add('op-div'); break;\n          }\n        } else if (gridCell.k === 'eq') {\n          cell.classList.add('op-eq');\n        } else if (gridCell.k === 'num') {\n          if (isGiven && !ans.checked) {\n            cell.classList.add('given');\n          } else {\n            cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');\n          }\n          cellCounter++;\n        }\n\n        container.appendChild(cell);\n      }\n    }\n  }\n\n  screenGrid.innerHTML = '';\n  screenGrid.appendChild(container);\n}\n\nfunction generatePrintVersion(grid, givenSet, minR, maxR, minC, maxC) {\n  const printGrid = document.getElementById('printGrid');\n  const container = document.createElement('div');\n  container.className = 'print-grid';\n\n  // Calculate container size for A4 print\n  const gridRows = maxR - minR + 1;\n  const gridCols = maxC - minC + 1;\n\n  // A4 constraints - use same logic as screen version with safe margins\n  const a4PortraitWidth = 175;  // 210mm - 35mm margins (safer)\n  const a4PortraitHeight = 250; // 297mm - 47mm margins\n  const a4LandscapeWidth = 225; // 297mm - 72mm margins (extra safe for landscape)\n  const a4LandscapeHeight = 175; // 210mm - 35mm margins (rotated)\n  const mmToPx = 3.78; // Approximate conversion for print\n\n  // Try both orientations and pick the best fit\n  const portraitCellSizeByWidth = Math.floor((a4PortraitWidth * mmToPx) / gridCols);\n  const portraitCellSizeByHeight = Math.floor((a4PortraitHeight * mmToPx) / gridRows);\n  const portraitCellSize = Math.min(portraitCellSizeByWidth, portraitCellSizeByHeight);\n\n  const landscapeCellSizeByWidth = Math.floor((a4LandscapeWidth * mmToPx) / gridCols);\n  const landscapeCellSizeByHeight = Math.floor((a4LandscapeHeight * mmToPx) / gridRows);\n  const landscapeCellSize = Math.min(landscapeCellSizeByWidth, landscapeCellSizeByHeight);\n\n  // Use the orientation that gives larger cells - maximize A4 usage for print\n  // Reduce print size by 10%\n  const printCellSize = Math.max(Math.floor(portraitCellSize * 0.9), Math.floor(landscapeCellSize * 0.9), 23); // 10% smaller print\n  const usePortrait = portraitCellSize >= landscapeCellSize;\n\n  // Store the orientation decision and print cell size\n  window.printOrientation = usePortrait ? 'portrait' : 'landscape';\n  window.printCellSize = printCellSize; // Store for print version\n\n  const gridWidth = (maxC - minC + 1) * printCellSize;\n  const gridHeight = (maxR - minR + 1) * printCellSize;\n  container.style.width = gridWidth + 'px';\n  container.style.height = gridHeight + 'px';\n\n  // Only create cells that contain puzzle content\n  for (let r = minR; r <= maxR; r++) {\n    for (let c = minC; c <= maxC; c++) {\n      const gridCell = grid[r][c];\n\n      if (gridCell) {\n        // Only create a cell if it has content\n        const cell = document.createElement('div');\n        cell.className = 'print-cell';\n\n        // Position the cell using print-optimized size\n        const printCellSize = window.printCellSize || cellSize;\n        const x = (c - minC) * printCellSize;\n        const y = (r - minR) * printCellSize;\n        cell.style.left = x + 'px';\n        cell.style.top = y + 'px';\n        cell.style.width = printCellSize + 'px';\n        cell.style.height = printCellSize + 'px';\n        cell.style.fontSize = Math.max(12, Math.floor(printCellSize * 0.4)) + 'px';\n\n        // Add border classes for cells that need right/bottom borders\n        // Check if there's no cell to the right\n        const hasRightNeighbor = grid[r] && grid[r][c + 1];\n        if (!hasRightNeighbor) cell.classList.add('border-right');\n\n        // Check if there's no cell below\n        const hasBottomNeighbor = grid[r + 1] && grid[r + 1][c];\n        if (!hasBottomNeighbor) cell.classList.add('border-bottom');\n\n        // Set the content\n        let text = gridCell.ch;\n        if (gridCell.k === 'num' && !ans.checked) {\n          text = givenSet.has(`${r},${c}`) ? gridCell.ch : '';\n        }\n        cell.textContent = text;\n\n        container.appendChild(cell);\n      }\n    }\n  }\n\n  printGrid.innerHTML = '';\n  printGrid.appendChild(container);\n}\n\nfunction saveSettings() {\n  setCookie('mx_eq', eqSlider.value);\n  setCookie('mx_diff', difficultySelect.value);\n  setCookie('mx_range', rangePreset.value);\n  // no custom range cookies\n  setCookie('mx_ops', JSON.stringify({\n    add: opAdd.checked,\n    sub: opSub.checked,\n    mul: opMul.checked,\n    div: opDiv.checked\n  }));\n}\n\nfunction regenerate(printAfter=false){\n  // Show immediate feedback with difficulty info\n  const selectedDifficulty = difficultySelect.value || 'medium';\n  stat.textContent=`\uD83D\uDD04 Generating ${selectedDifficulty} puzzle... (this may take longer for precise difficulty targeting)`;\n  stat.style.background = '#fff3cd';\n  stat.style.color = '#856404';\n  stat.style.border = '2px solid #ffeeba';\n\n  // Use setTimeout to ensure UI updates immediately\n  setTimeout(async () => {\n    const numEquations = parseInt(eqSlider.value) || 30;\n    const difficulty = difficultySelect.value || 'medium';\n\n    // Check if at least one operation is selected\n    const selectedOps = getSelectedOperations();\n    if (selectedOps.length === 0) {\n      stat.textContent = '\u26A0\uFE0F Please select at least one operation!';\n      stat.style.background = '#f8d7da';\n      stat.style.color = '#721c24';\n      stat.style.border = '2px solid #f5c6cb';\n      return;\n    }\n\n    saveSettings();\n\n    // Define target percentage ranges for each difficulty\n    const targetRanges = {\n      expert: { min: 5, max: 40 },   // \u226440% for expert\n      hard:   { min: 35, max: 50 },  // ~50% for hard\n      medium: { min: 55, max: 65 },  // ~60% for medium\n      easy:   { min: 65, max: 75 }   // ~70% for easy\n    };\n\n    const targetRange = targetRanges[difficulty] || targetRanges.medium;\n    let attempt = 0;\n    let finalModel = null;\n    let finalMeta = null;\n    let finalPercentage = 0;\n\n    // Add big spinner in puzzle area\n    const addPuzzleSpinner = () => {\n      // Add spinner CSS if not already present\n      if (!document.getElementById('spinnerStyles')) {\n        const style = document.createElement('style');\n        style.id = 'spinnerStyles';\n        style.textContent = `\n          .puzzle-spinner-container {\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n            justify-content: center;\n            min-height: 400px;\n            background: rgba(248, 249, 250, 0.8);\n            border-radius: 12px;\n            border: 2px dashed #dee2e6;\n          }\n          .puzzle-spinner {\n            width: 60px;\n            height: 60px;\n            border: 6px solid #f3f3f3;\n            border-top: 6px solid #007bff;\n            border-radius: 50%;\n            animation: spin 1.2s linear infinite;\n            margin-bottom: 20px;\n          }\n          .spinner-text {\n            font-size: 16px;\n            color: #6c757d;\n            font-weight: 500;\n          }\n          @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n          }\n        `;\n        document.head.appendChild(style);\n      }\n\n      // Create spinner container in puzzle area\n      const spinnerContainer = document.createElement('div');\n      spinnerContainer.className = 'puzzle-spinner-container';\n      spinnerContainer.id = 'puzzleSpinnerContainer';\n\n      const spinner = document.createElement('div');\n      spinner.className = 'puzzle-spinner';\n\n      const spinnerText = document.createElement('div');\n      spinnerText.className = 'spinner-text';\n      spinnerText.id = 'spinnerText';\n      spinnerText.textContent = 'Generating puzzle...';\n\n      spinnerContainer.appendChild(spinner);\n      spinnerContainer.appendChild(spinnerText);\n\n      // Insert spinner where the screen grid normally goes\n      const screenGrid = document.getElementById('screenGrid');\n      if (screenGrid && screenGrid.parentNode) {\n        screenGrid.parentNode.insertBefore(spinnerContainer, screenGrid);\n      }\n    };\n\n    const removePuzzleSpinner = () => {\n      const spinnerContainer = document.getElementById('puzzleSpinnerContainer');\n      if (spinnerContainer) spinnerContainer.remove();\n    };\n\n    // Hide puzzle grids during generation\n    const svg = document.getElementById('grid');\n    const screenGrid = document.getElementById('screenGrid');\n    const printGrid = document.getElementById('printGrid');\n    const ans = document.getElementById('ans');\n\n    if (svg) svg.style.display = 'none';\n    if (screenGrid) screenGrid.style.display = 'none';\n    if (printGrid) printGrid.style.display = 'none';\n    if (ans) ans.style.display = 'none';\n\n    // Show big spinner in puzzle area\n    addPuzzleSpinner();\n\n    // Retry loop until we hit the target percentage range (max 10 attempts)\n    while (attempt < 10) {\n      attempt++;\n\n      // Update spinner text and status\n      const spinnerText = document.getElementById('spinnerText');\n      if (spinnerText) {\n        spinnerText.textContent = `Generating ${difficulty} puzzle... (attempt ${attempt}/10)`;\n      }\n\n      stat.textContent = `\uD83D\uDD04 Targeting ${targetRange.min}-${targetRange.max}% difficulty (attempt ${attempt}/10)`;\n\n      // Add small delay to allow UI updates and cancellation\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      try {\n        // Use backward generation algorithm for better optimal puzzles\n        const model = generateBackwardCrossword(numEquations, difficulty);\n        if (!model) {\n          console.log(`Attempt ${attempt} failed to generate model`);\n          continue;\n        }\n\n        const meta = drawCompletedCrossword(model, difficulty);\n        const percentage = Math.round((meta.actualGivens / meta.numTotal) * 100);\n\n        // Check if this attempt hit our target range\n        if (percentage >= targetRange.min && percentage <= targetRange.max) {\n          finalModel = model;\n          finalMeta = meta;\n          finalPercentage = percentage;\n          break;\n        } else {\n          console.log(`Attempt ${attempt}: ${percentage}% (outside target ${targetRange.min}-${targetRange.max}%), retrying...`);\n          // Store the closest attempt as fallback\n          if (!finalModel || Math.abs(percentage - (targetRange.min + targetRange.max) / 2) < Math.abs(finalPercentage - (targetRange.min + targetRange.max) / 2)) {\n            finalModel = model;\n            finalMeta = meta;\n            finalPercentage = percentage;\n          }\n        }\n\n      } catch (e) {\n        console.log(`Attempt ${attempt} failed:`, e);\n        continue;\n      }\n    }\n\n    // Remove spinner\n    removePuzzleSpinner();\n\n    // Show only the screen grid (colorful version)\n    if (screenGrid) screenGrid.style.display = '';\n    if (ans) ans.style.display = '';\n    // Keep print grid hidden (only for printing)\n    if (printGrid) printGrid.style.display = 'none';\n\n    // Display results\n    if (finalModel && finalMeta) {\n      const range = getNumberRange();\n\n      // Success styling\n      stat.style.background = '#d4edda';\n      stat.style.color = '#155724';\n      stat.style.border = '2px solid #c3e6cb';\n      stat.textContent=`\u2705 Generated ${finalMeta.difficulty.name} puzzle (${range.min}-${range.max}) with ${finalModel.equations.length} equations, showing ${finalMeta.actualGivens}/${finalMeta.numTotal} numbers (${finalPercentage}%) [attempt ${attempt}]`;\n\n      if(printAfter) setTimeout(() => window.print(), 100);\n    } else {\n      // This shouldn't happen with infinite retries\n      stat.textContent = `\u26A0\uFE0F Unexpected error during generation.`;\n      stat.style.background = '#f8d7da';\n      stat.style.color = '#721c24';\n      stat.style.border = '2px solid #f5c6cb';\n      return;\n    }\n  }, 10); // End setTimeout\n}\n\n// Additional error handling wrapper\nfunction safeRegenerate(printAfter=false) {\n  try {\n    regenerate(printAfter);\n  } catch(e) {\n    console.error('Error generating crossword:', e);\n    stat.textContent = '\u26A0\uFE0F Error generating puzzle. Please try again.';\n    stat.style.background = '#f8d7da';\n    stat.style.color = '#721c24';\n    stat.style.border = '2px solid #f5c6cb';\n  }\n}\n\nfunction printColorVersion() {\n  // Create a new window with only the colored crossword\n  const printWindow = window.open('', '_blank', 'width=800,height=600');\n\n  // Generate print-optimized colorful version\n  const printGridContent = generateColorfulPrintGrid();\n\n  // Get the orientation decision made during puzzle generation\n  const orientation = window.printOrientation || 'portrait';\n\nfunction generateColorfulPrintGrid() {\n  const printGrid = document.getElementById('printGrid');\n  if (!printGrid || !printGrid.firstChild) return '<div>No puzzle generated</div>';\n\n  // Clone the print grid but add color classes\n  const container = printGrid.firstChild.cloneNode(true);\n  const cells = container.querySelectorAll('.print-cell');\n\n  let cellCounter = 0;\n  cells.forEach(cell => {\n    const text = cell.textContent.trim();\n\n    // Add color classes based on content\n    if (['+', '-', '\u00D7', '\u00F7'].includes(text)) {\n      switch (text) {\n        case '+': cell.classList.add('op-add'); break;\n        case '-': cell.classList.add('op-sub'); break;\n        case '\u00D7': cell.classList.add('op-mul'); break;\n        case '\u00F7': cell.classList.add('op-div'); break;\n      }\n    } else if (text === '=') {\n      cell.classList.add('op-eq');\n    } else if (text && !isNaN(text)) {\n      // It's a number\n      if (cell.style.fontSize && parseInt(cell.style.fontSize) > 15) {\n        cell.classList.add('given'); // Larger font means it's a given\n      } else {\n        cell.classList.add(cellCounter % 2 === 0 ? 'num-even' : 'num-odd');\n      }\n      cellCounter++;\n    }\n  });\n\n  return container.outerHTML;\n}\n\n  printWindow.document.write(`\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>Math Crossword - Color Print</title>\n      <style>\n        * {\n          -webkit-print-color-adjust: exact !important;\n          color-adjust: exact !important;\n          print-color-adjust: exact !important;\n        }\n\n        body {\n          margin: 20px;\n          font-family: Arial, sans-serif;\n          background: white;\n        }\n\n        .print-grid {\n          position: relative;\n          margin: 0 auto;\n          font-family: Arial, sans-serif;\n        }\n\n        .print-cell {\n          position: absolute;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          font-weight: bold;\n          box-sizing: border-box;\n          border-top: 1px solid #666;\n          border-left: 1px solid #666;\n        }\n\n        .print-cell.border-right {\n          border-right: 1px solid #666;\n        }\n\n        .print-cell.border-bottom {\n          border-bottom: 1px solid #666;\n        }\n\n        .print-cell.op-add {\n          background: #e8f5e8 !important;\n          color: #4a7c59 !important;\n        }\n        .print-cell.op-sub {\n          background: #fff3e0 !important;\n          color: #8d4004 !important;\n        }\n        .print-cell.op-mul {\n          background: #f3e5f5 !important;\n          color: #6a1b9a !important;\n        }\n        .print-cell.op-div {\n          background: #e3f2fd !important;\n          color: #1565c0 !important;\n        }\n        .print-cell.op-eq {\n          background: #fce4ec !important;\n          color: #ad1457 !important;\n        }\n        .print-cell.num-even {\n          background: #f8f9fa !important;\n          color: #495057 !important;\n        }\n        .print-cell.num-odd {\n          background: #f1f8e9 !important;\n          color: #2e7d32 !important;\n        }\n        .print-cell.given {\n          background: #fff8e1 !important;\n          color: #f57c00 !important;\n          font-weight: 900 !important;\n        }\n\n        @media print {\n          * {\n            -webkit-print-color-adjust: exact !important;\n            color-adjust: exact !important;\n            print-color-adjust: exact !important;\n          }\n\n          @page {\n            size: A4 ${orientation};\n            margin: 10mm 10mm 13.5mm 10mm; /* top right bottom left */\n          }\n        }\n      </style>\n    </head>\n    <body>\n      <h2 style=\"text-align: center; margin-bottom: 20px;\">Math Crossword Puzzle</h2>\n      ${printGridContent}\n      <scr` + `ipt>\n        window.onload = function() {\n          setTimeout(function() {\n            window.print();\n          }, 100);\n        };\n      </scr` + `ipt>\n    </body>\n    </html>\n  `);\n\n  printWindow.document.close();\n}\n\n// UI\ndocument.getElementById('gen').addEventListener('click',()=>regenerate(false));\ndocument.getElementById('printColor').addEventListener('click',()=>printColorVersion());\nans.addEventListener('change',()=>regenerate(false));\neqSlider.addEventListener('input',()=>{eqOut.textContent=eqSlider.value; saveSettings();});\ndifficultySelect.addEventListener('change',()=>{saveSettings(); regenerate(false);});\nrangePreset.addEventListener('change',()=>{ saveSettings(); regenerate(false); });\nopAdd.addEventListener('change',()=>{saveSettings(); regenerate(false);});\nopSub.addEventListener('change',()=>{saveSettings(); regenerate(false);});\nopMul.addEventListener('change',()=>{saveSettings(); regenerate(false);});\nopDiv.addEventListener('change',()=>{saveSettings(); regenerate(false);});\n\n// init\nsyncFromCookies();\nregenerate(false); // Fixed syntax error\n\n// Export init function if it exists\nif (typeof window !== 'undefined') {\n  // Initialization code runs automatically\n}\n"],
  "mappings": ";;;AA0BA,MAAM,MAAI,SAAS,eAAe,MAAM;AAAxC,MAA2C,MAAI,SAAS,eAAe,KAAK;AAC5E,MAAM,WAAS,SAAS,eAAe,UAAU;AAAjD,MAAoD,QAAM,SAAS,eAAe,OAAO;AACzF,MAAM,mBAAiB,SAAS,eAAe,kBAAkB;AACjE,MAAM,cAAY,SAAS,eAAe,aAAa;AACvD,MAAM,QAAM,SAAS,eAAe,OAAO;AAA3C,MAA8C,QAAM,SAAS,eAAe,OAAO;AACnF,MAAM,QAAM,SAAS,eAAe,OAAO;AAA3C,MAA8C,QAAM,SAAS,eAAe,OAAO;AACnF,MAAM,OAAK,SAAS,eAAe,MAAM;AAEzC,MAAM,IAAE,CAAC,GAAE,MAAI,KAAK,MAAM,KAAK,OAAO,KAAG,IAAE,IAAE,EAAE,IAAE;AAGjD,MAAM,QAAM,CAAC,GAAE,GAAE,MAAI,KAAK,IAAI,GAAE,KAAK,IAAI,GAAE,CAAC,CAAC;AAE7C,WAAS,UAAU,MAAK,OAAM,OAAK,KAAI;AACrC,UAAM,IAAE,oBAAI,KAAK;AAAG,MAAE,QAAQ,EAAE,QAAQ,IAAE,OAAK,KAAG,KAAG,KAAG,GAAI;AAC5D,aAAS,SAAO,GAAG,IAAI,IAAI,mBAAmB,KAAK,CAAC,YAAY,EAAE,YAAY,CAAC;AAAA,EACjF;AACA,WAAS,UAAU,MAAK;AACtB,UAAM,IAAE,SAAS,OAAO,MAAM,GAAG,EAAE,IAAI,OAAG,EAAE,KAAK,CAAC,EAAE,KAAK,OAAG,EAAE,WAAW,OAAK,GAAG,CAAC;AAClF,WAAO,IAAE,mBAAmB,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC,IAAE;AAAA,EAC/C;AACA,WAAS,kBAAiB;AACxB,UAAM,MAAI,UAAU,OAAO,GAAG,QAAM,UAAU,SAAS;AACvD,UAAM,SAAO,UAAU,UAAU;AACjC,UAAM,OAAK,UAAU,QAAQ;AAE7B,aAAS,QAAQ,MAAM,SAAS,GAAG,KAAG,IAAG,GAAE,EAAE;AAC7C,qBAAiB,QAAQ,SAAS;AAClC,QAAG,QAAO;AACR,kBAAY,QAAQ;AAAA,IACtB,OAAO;AACL,kBAAY,QAAQ;AAAA,IACtB;AAEA,UAAM,cAAc,SAAS;AAG7B,UAAM,MAAM,OAAO,KAAK,MAAM,IAAI,IAAI,EAAC,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,KAAI;AACjF,UAAM,UAAU,IAAI,QAAQ;AAC5B,UAAM,UAAU,IAAI,QAAQ;AAC5B,UAAM,UAAU,IAAI,QAAQ;AAC5B,UAAM,UAAU,IAAI,QAAQ;AAAA,EAC9B;AAsBA,WAAS,OAAO,GAAE,IAAG,GAAE,GAAE;AACvB,QAAE,CAAC;AAAG,QAAE,CAAC;AAAG,QAAE,CAAC;AACf,QAAG,OAAK,IAAK,QAAO,IAAE,MAAI;AAC1B,QAAG,OAAK,IAAK,QAAO,IAAE,MAAI;AAC1B,QAAG,OAAK,OAAK,QAAO,IAAE,MAAI;AAC1B,QAAG,OAAK,OAAK,QAAO,MAAI,KAAK,IAAE,MAAI;AACnC,WAAO;AAAA,EACT;AAyIA,WAAS,EAAE,KAAI,OAAM;AAAC,UAAM,IAAE,SAAS,gBAAgB,8BAA6B,GAAG;AAAE,eAAU,KAAK,MAAM,GAAE,aAAa,GAAE,MAAM,CAAC,CAAC;AAAE,WAAO;AAAA,EAAC;AAyCjJ,WAAS,wBAAwB;AAC/B,UAAM,MAAM,CAAC;AACb,QAAI,MAAM,QAAS,KAAI,KAAK,GAAG;AAC/B,QAAI,MAAM,QAAS,KAAI,KAAK,GAAG;AAC/B,QAAI,MAAM,QAAS,KAAI,KAAK,MAAG;AAC/B,QAAI,MAAM,QAAS,KAAI,KAAK,MAAG;AAC/B,WAAO,IAAI,SAAS,IAAI,MAAM,CAAC,GAAG;AAAA,EACpC;AAEA,WAAS,iBAAiB;AACxB,QAAI,MAAI,GAAG,MAAI;AACf,UAAM,SAAS,YAAY;AAC3B,QAAG,gBAAgB,KAAK,MAAM,GAAE;AAC9B,YAAM,IAAE,OAAO,MAAM,eAAe;AACpC,YAAM,SAAS,EAAE,CAAC,CAAC;AACnB,YAAM,SAAS,EAAE,CAAC,CAAC;AAAA,IACrB;AAEA,WAAO,EAAE,KAAK,IAAI;AAAA,EACpB;AAEA,WAAS,iBAAiB,GAAG,GAAG,GAAG,IAAI,QAAQ,MAAM;AACnD,QAAI,SAAS,CAAC;AAAG,QAAI,SAAS,CAAC;AAAG,QAAI,SAAS,CAAC;AAEhD,UAAM,eAAe,SAAS,eAAe;AAG7C,QAAI,IAAI,aAAa,OAAO,IAAI,aAAa,OACzC,IAAI,aAAa,OAAO,IAAI,aAAa,OACzC,IAAI,aAAa,OAAO,IAAI,aAAa,IAAK,QAAO;AACzD,QAAI,CAAC,OAAO,UAAU,CAAC,KAAK,CAAC,OAAO,UAAU,CAAC,KAAK,CAAC,OAAO,UAAU,CAAC,EAAG,QAAO;AACjF,QAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAG,QAAO;AAEvC,YAAQ,IAAI;AAAA,MACV,KAAK;AAAK,eAAO,IAAI,MAAM;AAAA,MAC3B,KAAK;AAAK,eAAO,IAAI,MAAM,KAAK,IAAI;AAAA;AAAA,MACpC,KAAK;AAAK,eAAO,IAAI,MAAM;AAAA,MAC3B,KAAK;AAAK,eAAO,MAAM,KAAK,IAAI,MAAM,KAAK,IAAI,MAAM;AAAA;AAAA,MACrD;AAAS,eAAO;AAAA,IAClB;AAAA,EACF;AAEA,WAAS,yBAAyB;AAChC,UAAM,aAAa,sBAAsB;AACzC,UAAM,QAAQ,eAAe;AAC7B,UAAM,SAAS;AAEf,aAAS,WAAW,GAAG,WAAW,KAAK,YAAY;AACjD,YAAM,KAAK,WAAW,KAAK,MAAM,KAAK,OAAO,IAAI,WAAW,MAAM,CAAC;AACnE,UAAI,GAAG,GAAG;AAEV,cAAQ,IAAI;AAAA,QACV,KAAK,KAAK;AAER,cAAI,EAAE,MAAM,KAAK,MAAM,GAAG;AAC1B,cAAI,EAAE,MAAM,KAAK,MAAM,GAAG;AAE1B,cAAI,IAAI;AACR;AAAA,QAAO;AAAA,QAET,KAAK,KAAK;AAER,cAAI,EAAE,KAAK,IAAI,MAAM,KAAK,CAAC,GAAG,MAAM,GAAG;AACvC,cAAI,EAAE,MAAM,KAAK,MAAM,GAAG;AAC1B,cAAI,IAAI,EAAG,EAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC;AAEzB,cAAI,IAAI;AACR;AAAA,QAAO;AAAA,QAET,KAAK,QAAK;AACR,gBAAM,YAAY,KAAK,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM,GAAG,CAAC,GAAG,EAAE;AAC/D,cAAI,EAAE,GAAG,KAAK,IAAI,GAAG,SAAS,CAAC;AAC/B,cAAI,EAAE,GAAG,KAAK,IAAI,GAAG,SAAS,CAAC;AAE/B,cAAI,IAAI;AACR,cAAI,IAAI,MAAM,OAAO,IAAI,MAAM,IAAK;AACpC;AAAA,QAAO;AAAA,QAET,KAAK,QAAK;AAER,cAAI,EAAE,KAAK,IAAI,MAAM,KAAK,CAAC,GAAG,KAAK,IAAI,MAAM,KAAK,MAAM,GAAG,CAAC;AAC5D,cAAI,EAAE,KAAK,IAAI,MAAM,KAAK,CAAC,GAAG,KAAK,IAAI,MAAM,KAAK,MAAM,GAAG,CAAC;AAC5D,cAAI,IAAI;AACR,cAAI,IAAI,EAAG;AAEX;AAAA,QAAO;AAAA,MACX;AAEA,UAAI,iBAAiB,GAAG,GAAG,GAAG,IAAI,KAAK,GAAG;AACxC,eAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,MACrB;AAAA,IACF;AAGA,UAAM,gBAAgB,MAAM,OAAO,KAAK,EAAC,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC,IAAI,EAAC,GAAG,IAAI,GAAG,GAAG,GAAG,EAAC;AAC/E,WAAO,EAAC,GAAG,eAAe,IAAI,OAAG;AAAA,EACnC;AAMA,WAAS,gCAAgC,aAAa;AAEpD,UAAM,aAAa,CAAC,KAAK,KAAK,QAAK,MAAG;AAEtC,aAAS,UAAU,GAAG,UAAU,KAAM,WAAW;AAC/C,YAAM,KAAK,uBAAuB;AAClC,YAAM,SAAS,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAEhC,UAAI,QAAQ;AACZ,iBAAW,CAAC,KAAK,aAAa,KAAK,OAAO,QAAQ,WAAW,GAAG;AAC9D,YAAI,OAAO,SAAS,GAAG,IAAI,CAAC,MAAM,eAAe;AAC/C,kBAAQ;AACR;AAAA,QACF;AAAA,MACF;AAEA,UAAI,SAAS,iBAAiB,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG;AACtD,eAAO;AAAA,MACT;AAAA,IACF;AAGA,QAAI,OAAO,KAAK,WAAW,EAAE,WAAW,GAAG;AACzC,YAAM,CAAC,KAAK,KAAK,IAAI,OAAO,QAAQ,WAAW,EAAE,CAAC;AAClD,YAAM,WAAW,SAAS,GAAG,IAAI;AAGjC,iBAAW,MAAM,YAAY;AAC3B,YAAI,GAAG,GAAG;AAEV,YAAI,aAAa,GAAG;AAClB,cAAI;AACJ,mBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,gBAAI,OAAO,KAAK;AACd,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI;AACrC,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,KAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,GAAG,EAAE,CAAC,IAAI;AACtD,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,QAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,IAAI,GAAG,KAAK,MAAM,KAAG,CAAC,CAAC,CAAC,IAAI;AAChE,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,QAAK;AACrB,oBAAM,WAAW,CAAC;AAClB,uBAAS,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,CAAC,GAAG,KAAK;AACxC,oBAAI,IAAI,MAAM,EAAG,UAAS,KAAK,CAAC;AAAA,cAClC;AACA,kBAAI,SAAS,SAAS,GAAG;AACvB,oBAAI,SAAS,KAAK,MAAM,KAAK,OAAO,IAAI,SAAS,MAAM,CAAC;AACxD,oBAAI,IAAI;AACR,oBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,cACxD;AAAA,YACF;AAAA,UACF;AAAA,QACF,WAAW,aAAa,GAAG;AACzB,cAAI;AACJ,mBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,gBAAI,OAAO,KAAK;AACd,kBAAI,KAAK,MAAM,KAAK,OAAO,KAAK,KAAK,EAAE,IAAI;AAC3C,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,KAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI,IAAI;AACzC,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,QAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,IAAI,GAAG,KAAK,MAAM,KAAG,CAAC,CAAC,CAAC,IAAI;AAChE,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,QAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI;AACrC,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD;AAAA,UACF;AAAA,QACF,WAAW,aAAa,GAAG;AACzB,cAAI;AACJ,mBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,gBAAI,OAAO,KAAK;AACd,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,EAAE,CAAC,IAAI;AACvD,kBAAI,IAAI;AACR,kBAAI,KAAK,MAAM,KAAK,GAAI,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YAC7C,WAAW,OAAO,KAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,CAAC,CAAC,IAAI;AACtD,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD,WAAW,OAAO,QAAK;AACrB,oBAAM,UAAU,CAAC;AACjB,uBAAS,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,CAAC,GAAG,KAAK;AACxC,oBAAI,IAAI,MAAM,KAAK,IAAE,KAAK,KAAK,IAAE,KAAK,GAAG;AACvC,0BAAQ,KAAK,CAAC,GAAG,IAAE,CAAC,CAAC;AAAA,gBACvB;AAAA,cACF;AACA,kBAAI,QAAQ,SAAS,GAAG;AACtB,sBAAM,CAACA,IAAGC,EAAC,IAAI,QAAQ,KAAK,MAAM,KAAK,OAAO,IAAI,QAAQ,MAAM,CAAC;AACjE,oBAAI,iBAAiBD,IAAGC,IAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAAD,IAAG,GAAAC,IAAG,GAAG,GAAE;AAAA,cACxD;AAAA,YACF,WAAW,OAAO,QAAK;AACrB,kBAAI,KAAK,MAAM,KAAK,OAAO,IAAI,CAAC,IAAI;AACpC,kBAAI,IAAI;AACR,kBAAI,iBAAiB,GAAG,GAAG,GAAG,EAAE,EAAG,QAAO,EAAC,GAAG,GAAG,GAAG,GAAE;AAAA,YACxD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,uBAAuB;AAAA,EAChC;AAOA,WAAS,0BAA0B,iBAAiB,YAAY;AAE9D,UAAM,YAAY,sBAAsB,iBAAiB,UAAU;AACnE,QAAI,CAAC,UAAW,QAAO;AAGvB,WAAO,uBAAuB,WAAW,UAAU;AAAA,EACrD;AAEA,WAAS,uBAAuB,OAAO,YAAY;AACjD,UAAM,EAAC,MAAM,UAAS,IAAI;AAG1B,UAAM,qBAAqB,CAAC;AAC5B,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAI,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,OAAO;AACnD,6BAAmB,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAEA,QAAI,gBAAgB,IAAI,IAAI,kBAAkB;AAC9C,UAAM,oBAAoB,wBAAwB,YAAY,mBAAmB,MAAM;AAEvF,YAAQ,IAAI,mCAAmC;AAC/C,YAAQ,IAAI,eAAe,UAAU,EAAE;AACvC,YAAQ,IAAI,kBAAkB,mBAAmB,MAAM,EAAE;AACzD,YAAQ,IAAI,uBAAuB,iBAAiB;AAEpD,QAAI,CAAC,qBAAqB,CAAC,kBAAkB,YAAY;AACvD,cAAQ,MAAM,+BAA+B,iBAAiB;AAC9D,aAAO;AAAA,IACT;AAEA,YAAQ,IAAI,iBAAiB,kBAAkB,SAAS,IAAI,kBAAkB,SAAS,YAAY,kBAAkB,WAAW,GAAG,IAAI,kBAAkB,WAAW,GAAG,IAAI;AAC3K,YAAQ,IAAI,kBAAkB,cAAc,IAAI,gBAAgB;AAChE,YAAQ,IAAI,qCAAqC;AAGjD,QAAI,WAAW;AACf,UAAM,cAAc,eAAe,WAAW,MAAO;AAErD,WAAO,cAAc,OAAO,kBAAkB,aAAa,WAAW,aAAa;AACjF;AACA,YAAM,cAAc,uBAAuB,MAAM,WAAW,eAAe,UAAU;AAErF,UAAI,CAAC,aAAa;AAChB,gBAAQ,IAAI,6BAA6B,cAAc,IAAI,IAAI,mBAAmB,MAAM,YAAY,KAAK,MAAM,cAAc,OAAK,mBAAmB,SAAO,GAAG,CAAC,mBAAmB,kBAAkB,SAAS,EAAE;AAChN;AAAA,MACF;AAEA,UAAI,WAAW,OAAO,GAAG;AACvB,cAAM,oBAAoB,KAAK,MAAM,cAAc,OAAK,mBAAmB,SAAO,GAAG;AACrF,gBAAQ,IAAI,WAAW,QAAQ,KAAK,cAAc,IAAI,IAAI,mBAAmB,MAAM,YAAY,iBAAiB,uBAAuB;AAGvI,YAAI,OAAO,WAAW,eAAe,OAAO,MAAM;AAChD,iBAAO,KAAK,cAAc,wBAAiB,UAAU,kBAAkB,iBAAiB,YAAO,kBAAkB,WAAW,GAAG,cAAc,QAAQ;AAAA,QACvJ;AAAA,MACF;AAEA,oBAAc,OAAO,WAAW;AAGhC,UAAI,eAAe,UAAU;AAE3B,YAAI,6BAA6B,MAAM,WAAW,aAAa,GAAG;AAChE,wBAAc,IAAI,WAAW;AAC7B,kBAAQ,IAAI,oDAAoD,cAAc,IAAI,IAAI,mBAAmB,MAAM,YAAY,KAAK,MAAM,cAAc,OAAK,mBAAmB,SAAO,GAAG,CAAC,IAAI;AAC3L;AAAA,QACF;AAAA,MACF,OAAO;AAEL,YAAI,CAAC,eAAe,MAAM,WAAW,aAAa,GAAG;AACnD,wBAAc,IAAI,WAAW;AAC7B,kBAAQ,IAAI,uCAAuC,cAAc,IAAI,IAAI,mBAAmB,MAAM,YAAY,KAAK,MAAM,cAAc,OAAK,mBAAmB,SAAO,GAAG,CAAC,IAAI;AAC9K;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,IAAI,UAAU,cAAc,IAAI,IAAI,mBAAmB,MAAM,YAAY,KAAK,MAAM,cAAc,OAAK,mBAAmB,SAAO,GAAG,CAAC,kBAAkB,KAAK,MAAM,kBAAkB,SAAS,CAAC,KAAK,KAAK,MAAM,kBAAkB,YAAU,mBAAmB,SAAO,GAAG,CAAC,IAAI;AACpR,YAAQ,IAAI,kBAAkB,QAAQ,EAAE;AACxC,YAAQ,IAAI,aAAa,UAAU,MAAM,mBAAmB,mBAAmB,MAAM,gBAAgB;AAGrG,UAAM,YAAY,cAAc;AAChC,oBAAgB,wBAAwB,MAAM,WAAW,aAAa;AACtE,UAAM,WAAW,cAAc;AAE/B,QAAI,WAAW,WAAW;AACxB,cAAQ,IAAI,0BAA0B,WAAW,SAAS,iBAAiB,SAAS,OAAO,QAAQ,GAAG;AAAA,IACxG;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,iBAAiB;AAAA,IACnB;AAAA,EACF;AAEA,WAAS,uBAAuB,MAAM,WAAW,eAAe,aAAa,UAAU;AACrF,UAAM,aAAa,CAAC;AAGpB,eAAW,YAAY,eAAe;AACpC,YAAM,CAAC,GAAG,CAAC,IAAI,SAAS,MAAM,GAAG,EAAE,IAAI,MAAM;AAC7C,YAAM,eAAe,sBAAsB,MAAM,WAAW,eAAe,GAAG,GAAG,UAAU;AAE3F,UAAI,eAAe,GAAG;AACpB,mBAAW,KAAK,EAAC,KAAK,UAAU,OAAO,cAAc,GAAG,EAAC,CAAC;AAAA,MAC5D;AAAA,IACF;AAEA,QAAI,WAAW,WAAW,GAAG;AAC3B,cAAQ,IAAI,gDAAgD,cAAc,IAAI,EAAE;AAChF,aAAO;AAAA,IACT;AAGA,eAAW,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AAG3C,QAAI,WAAW,SAAS,GAAG;AACzB,cAAQ,IAAI,SAAS,WAAW,MAAM,oCAAoC,WAAW,CAAC,EAAE,KAAK,EAAE;AAAA,IACjG;AAEA,WAAO,WAAW,CAAC,EAAE;AAAA,EACvB;AAEA,WAAS,sBAAsB,MAAM,WAAW,eAAe,GAAG,GAAG,aAAa,UAAU;AAC1F,QAAI,QAAQ;AAGZ,UAAM,sBAAsB,CAAC;AAC7B,eAAW,MAAM,WAAW;AAC1B,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,cAAM,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AAC1C,cAAM,MAAM,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACxC,YAAI,QAAQ,KAAK,QAAQ,GAAG;AAC1B,8BAAoB,KAAK,EAAC,IAAI,UAAU,EAAC,CAAC;AAC1C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,eAAW,EAAC,IAAI,SAAQ,KAAK,qBAAqB;AAEhD,YAAM,cAAc,CAAC;AACrB,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,cAAM,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AAC1C,cAAM,MAAM,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACxC,YAAI,MAAM,MAAM,MAAM,IAAI;AACxB,sBAAY,KAAK,GAAG,GAAG,IAAI,GAAG,EAAE;AAAA,QAClC;AAAA,MACF;AAEA,YAAM,kBAAkB,YAAY,OAAO,SAAO,cAAc,IAAI,GAAG,CAAC,EAAE;AAG1E,UAAI,eAAe,UAAU;AAE3B,YAAI,oBAAoB,GAAG;AAEzB,gBAAM,oBAAoB,6BAA6B,MAAM,WAAW,eAAe,GAAG,CAAC;AAC3F,cAAI,oBAAoB,GAAG;AACzB,mBAAO;AAAA,UACT;AACA,mBAAS;AAAA,QACX;AAAA,MACF,OAAO;AAEL,YAAI,mBAAmB,GAAG;AACxB,iBAAO;AAAA,QACT;AAAA,MACF;AAGA,UAAI,mBAAmB,GAAG;AACxB,iBAAS;AAAA,MACX,WAAW,oBAAoB,GAAG;AAEhC,cAAM,oBAAoB,6BAA6B,MAAM,WAAW,eAAe,GAAG,CAAC;AAC3F,YAAI,qBAAqB,GAAG;AAC1B,mBAAS;AAAA,QACX,WAAW,qBAAqB,GAAG;AACjC,mBAAS;AAAA,QACX,OAAO;AACL,mBAAS;AAAA,QACX;AAAA,MACF;AAGA,UAAI,aAAa,GAAG;AAClB,iBAAS;AAAA,MACX;AAGA,YAAM,YAAY,SAAS,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE;AACxC,UAAI,YAAY,GAAI,UAAS;AAAA,IAC/B;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,6BAA6B,MAAM,WAAW,eAAe,GAAG,GAAG;AAC1E,QAAI,QAAQ;AAEZ,eAAW,MAAM,WAAW;AAE1B,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,cAAM,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AAC1C,cAAM,MAAM,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AAExC,YAAI,QAAQ,KAAK,QAAQ,GAAG;AAE1B,gBAAM,cAAc,CAAC;AACrB,mBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,kBAAM,SAAS,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AAC7C,kBAAM,SAAS,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AAC3C,gBAAI,SAAS,MAAM,SAAS,IAAI;AAC9B,0BAAY,KAAK,GAAG,MAAM,IAAI,MAAM,EAAE;AAAA,YACxC;AAAA,UACF;AAEA,gBAAM,WAAW,YAAY,OAAO,SAAO,cAAc,IAAI,GAAG,CAAC,EAAE;AACnE,cAAI,YAAY,GAAG;AACjB;AAAA,UACF;AACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,wBAAwB,MAAM,WAAW,eAAe;AAC/D,UAAM,cAAc,oBAAI,IAAI,CAAC,GAAG,aAAa,CAAC;AAC9C,QAAI,QAAQ;AAEZ,eAAW,MAAM,WAAW;AAC1B,YAAM,cAAc,CAAC;AACrB,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,cAAM,IAAI,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AACxC,cAAM,IAAI,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACtC,YAAI,IAAI,MAAM,IAAI,IAAI;AACpB,sBAAY,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE;AAAA,QAC9B;AAAA,MACF;AAEA,YAAM,aAAa,YAAY,OAAO,SAAO,YAAY,IAAI,GAAG,CAAC,EAAE;AAGnE,UAAI,eAAe,GAAG;AACpB,oBAAY,IAAI,YAAY,CAAC,CAAC;AAC9B;AACA,gBAAQ,IAAI,sCAAsC,KAAK,GAAG;AAAA,MAC5D,WAAW,eAAe,KAAK,YAAY,UAAU,GAAG;AAEtD,YAAI,0BAA0B;AAE9B,mBAAW,OAAO,aAAa;AAC7B,cAAI,CAAC,YAAY,IAAI,GAAG,GAAG;AACzB,kBAAM,CAAC,GAAG,CAAC,IAAI,IAAI,MAAM,GAAG,EAAE,IAAI,MAAM;AAGxC,gBAAI,qBAAqB;AACzB,uBAAW,WAAW,WAAW;AAC/B,kBAAI,YAAY,GAAI;AACpB,uBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,sBAAM,SAAS,QAAQ,SAAS,QAAQ,MAAM,QAAQ,MAAM;AAC5D,sBAAM,SAAS,QAAQ,SAAS,QAAQ,MAAM,IAAI,QAAQ;AAC1D,oBAAI,WAAW,KAAK,WAAW,GAAG;AAChC,uCAAqB;AACrB;AAAA,gBACF;AAAA,cACF;AACA,kBAAI,mBAAoB;AAAA,YAC1B;AAEA,gBAAI,CAAC,oBAAoB;AACvB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAGA,YAAI,4BAA4B,YAAY,SAAS,YAAY;AAC/D,gBAAM,UAAU,YAAY,OAAO,SAAO,CAAC,YAAY,IAAI,GAAG,CAAC;AAC/D,cAAI,QAAQ,SAAS,GAAG;AACtB,wBAAY,IAAI,QAAQ,CAAC,CAAC;AAC1B;AACA,oBAAQ,IAAI,uBAAuB,uBAAuB,wCAAwC,KAAK,GAAG;AAAA,UAC5G;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,YAAQ,IAAI,yBAAyB,KAAK,cAAc;AACxD,WAAO;AAAA,EACT;AAEA,WAAS,sBAAsB,cAAc,aAAa,UAAU;AAClE,UAAM,OAAO,MAAM,KAAK,EAAC,QAAQ,GAAE,GAAG,MAAM,MAAM,EAAE,EAAE,KAAK,IAAI,CAAC;AAChE,UAAM,YAAY,CAAC;AACnB,UAAM,cAAc;AAGpB,UAAM,WAAW,KAAK,MAAM,KAAK,OAAO,IAAI,CAAC,IAAI;AACjD,UAAM,WAAW,KAAK,MAAM,KAAK,OAAO,IAAI,CAAC,IAAI;AACjD,UAAM,cAAc,KAAK,OAAO,IAAI;AAEpC,UAAM,UAAU,uBAAuB;AACvC,UAAM,WAAW;AAAA,MACf,EAAC,GAAG,OAAO,IAAI,OAAO,QAAQ,CAAC,EAAC;AAAA,MAChC,EAAC,GAAG,MAAM,IAAI,QAAQ,GAAE;AAAA,MACxB,EAAC,GAAG,OAAO,IAAI,OAAO,QAAQ,CAAC,EAAC;AAAA,MAChC,EAAC,GAAG,MAAM,IAAI,IAAG;AAAA,MACjB,EAAC,GAAG,OAAO,IAAI,OAAO,QAAQ,CAAC,EAAC;AAAA,IAClC;AAGA,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,IAAI,cAAc,WAAW,WAAW;AAC9C,YAAM,IAAI,cAAc,WAAW,IAAI;AACvC,WAAK,CAAC,EAAE,CAAC,IAAI,EAAC,GAAG,SAAS,CAAC,GAAG,IAAI,EAAC;AAAA,IACrC;AAEA,cAAU,KAAK;AAAA,MACb,QAAQ;AAAA,MACR,KAAK;AAAA,MACL,KAAK;AAAA,MACL,IAAI;AAAA,IACN,CAAC;AAGD,aAAS,QAAQ,GAAG,SAAS,cAAc,SAAS;AAClD,UAAI,SAAS;AAEb,eAAS,UAAU,GAAG,UAAU,eAAe,CAAC,QAAQ,WAAW;AAEjE,cAAM,wBAAwB,CAAC;AAE/B,iBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,mBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,gBAAI,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,OAAO;AAExC,yBAAW,UAAU,CAAC,MAAM,KAAK,GAAG;AAClC,yBAAS,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG;AACnC,wBAAM,SAAS,SAAS,IAAI,IAAI;AAChC,wBAAM,SAAS,SAAS,IAAI,MAAM;AAGlC,sBAAI,UAAU,KAAK,SAAS,MAAM,UAAU,KAAK,SAAS,IAAI;AAC5D,wBAAI,WAAW;AACf,0BAAM,cAAc,CAAC;AACrB,wBAAI,oBAAoB;AAGxB,6BAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,4BAAM,SAAS,SAAS,SAAS,SAAS;AAC1C,4BAAM,SAAS,SAAS,SAAS,IAAI;AAErC,0BAAI,UAAU,MAAM,UAAU,IAAI;AAChC,mCAAW;AACX;AAAA,sBACF;AAEA,4BAAM,WAAW,KAAK,MAAM,EAAE,MAAM;AACpC,0BAAI,UAAU;AAEZ,4BAAI,SAAS,MAAM,OAAO;AACxB,sCAAY,CAAC,IAAI,SAAS,SAAS,EAAE;AACrC;AAAA,wBACF,WAAW,SAAS,MAAM,QAAS,MAAM,GAAI;AAE3C,8BAAI,sBAAsB,EAAE,IAAI,QAAM,GAAG,MAAM,EAAE,SAAS,SAAS,EAAE,GAAG;AACtE,wCAAY,CAAC,IAAI,SAAS;AAC1B;AAAA,0BACF,OAAO;AACL,uCAAW;AACX;AAAA,0BACF;AAAA,wBACF,WAAW,SAAS,MAAM,QAAS,MAAM,GAAI;AAE3C,sCAAY,CAAC,IAAI,SAAS;AAC1B;AAAA,wBACF,OAAO;AAEL,8BAAI,SAAS,GAAG;AAEd,uCAAW;AACX;AAAA,0BACF,OAAO;AAEL,uCAAW;AACX;AAAA,0BACF;AAAA,wBACF;AAAA,sBACF;AAAA,oBACF;AAIA,wBAAI;AACJ,4BAAQ,YAAY;AAAA,sBAClB,KAAK;AACH,2CAAmB,SAAS,IAAI,IAAI;AACpC;AAAA,sBACF,KAAK;AACH,2CAAmB;AACnB;AAAA,sBACF,KAAK;AAAA,sBACL,KAAK;AACH,2CAAmB,SAAS,IAAI,IAAI;AACpC;AAAA,sBACF;AACE,2CAAmB;AAAA,oBACvB;AAEA,wBAAI,YAAY,qBAAqB,kBAAkB;AACrD,4CAAsB,KAAK;AAAA,wBACzB,KAAK;AAAA,wBACL,KAAK;AAAA,wBACL;AAAA,wBACA;AAAA,wBACA;AAAA;AAAA,sBACF,CAAC;AAAA,oBACH;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,YAAI,sBAAsB,SAAS,GAAG;AAGpC,gCAAsB,KAAK,CAAC,GAAG,MAAM,EAAE,oBAAoB,EAAE,iBAAiB;AAG9E,cAAI;AACJ,kBAAQ,YAAY;AAAA,YAClB,KAAK;AACH,8BAAgB;AAChB;AAAA,YACF,KAAK;AACH,8BAAgB;AAChB;AAAA,YACF,KAAK;AACH,8BAAgB;AAChB;AAAA,YACF,KAAK;AACH,8BAAgB;AAChB;AAAA,YACF;AACE,8BAAgB;AAAA,UACpB;AAEA,gBAAM,gBAAgB,sBAAsB,MAAM,GAAG,KAAK,IAAI,GAAG,KAAK,KAAK,sBAAsB,SAAS,aAAa,CAAC,CAAC;AACzH,gBAAM,eAAe,cAAc,KAAK,MAAM,KAAK,OAAO,IAAI,cAAc,MAAM,CAAC;AAEnF,cAAI,KAAK;AACT,cAAI,WAAW;AACf,iBAAO,CAAC,MAAM,WAAW,IAAI;AAC3B,iBAAK,gCAAgC,aAAa,WAAW;AAC7D;AAAA,UACF;AAGA,cAAI,CAAC,MAAM,sBAAsB,SAAS,GAAG;AAC3C,gBAAI,eAAe,UAAU;AAE3B,oBAAM,qBAAqB,sBAAsB,OAAO,SAAO,IAAI,oBAAoB,CAAC;AACxF,kBAAI,mBAAmB,SAAS,GAAG;AACjC,sBAAM,oBAAoB,mBAAmB,KAAK,MAAM,KAAK,OAAO,IAAI,mBAAmB,MAAM,CAAC;AAClG,qBAAK,gCAAgC,kBAAkB,WAAW;AAAA,cACpE;AAAA,YACF;AAGA,gBAAI,CAAC,IAAI;AACP,oBAAM,uBAAuB,sBAAsB,OAAO,SAAO,IAAI,sBAAsB,CAAC;AAC5F,kBAAI,qBAAqB,SAAS,GAAG;AACnC,sBAAM,qBAAqB,qBAAqB,KAAK,MAAM,KAAK,OAAO,IAAI,qBAAqB,MAAM,CAAC;AACvG,qBAAK,gCAAgC,mBAAmB,WAAW;AAAA,cACrE;AAAA,YACF;AAAA,UACF;AAEA,cAAI,CAAC,IAAI;AACP,oBAAQ,IAAI,6DAA6D;AACzE,iBAAK,uBAAuB;AAAA,UAC9B;AAEA,gBAAM,WAAW;AAAA,YACf,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,YAC3B,EAAC,GAAG,MAAM,IAAI,GAAG,GAAE;AAAA,YACnB,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,YAC3B,EAAC,GAAG,MAAM,IAAI,IAAG;AAAA,YACjB,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,UAC7B;AAGA,cAAI,mBAAmB;AACvB,mBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,kBAAM,IAAI,aAAa,SAAS,aAAa,MAAM,aAAa,MAAM;AACtE,kBAAM,IAAI,aAAa,SAAS,aAAa,MAAM,IAAI,aAAa;AACpE,gBAAI,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,SAAS,KAAK,CAAC,EAAE,CAAC,EAAE,OAAO,SAAS,CAAC,EAAE,IAAI;AAC5E,sBAAQ,KAAK,2BAA2B,CAAC,IAAI,CAAC,eAAe,SAAS,CAAC,EAAE,EAAE,WAAW,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE;AACrG,iCAAmB;AACnB;AAAA,YACF;AAAA,UACF;AAGA,cAAI,kBAAkB;AACpB,qBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,oBAAM,IAAI,aAAa,SAAS,aAAa,MAAM,aAAa,MAAM;AACtE,oBAAM,IAAI,aAAa,SAAS,aAAa,MAAM,IAAI,aAAa;AACpE,kBAAI,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;AACf,qBAAK,CAAC,EAAE,CAAC,IAAI,EAAC,GAAG,SAAS,CAAC,GAAG,IAAI,MAAK;AAAA,cACzC;AAAA,YACF;AAAA,UACF,OAAO;AAEL;AAAA,UACF;AAEA,oBAAU,KAAK;AAAA,YACb,QAAQ,aAAa;AAAA,YACrB,KAAK,aAAa;AAAA,YAClB,KAAK,aAAa;AAAA,YAClB;AAAA,UACF,CAAC;AAED,mBAAS;AAAA,QACX;AAAA,MACF;AAGA,UAAI,CAAC,QAAQ;AACX,iBAAS,UAAU,GAAG,UAAU,eAAe,CAAC,QAAQ,WAAW;AACjE,gBAAM,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI;AAC7C,gBAAM,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI;AAC7C,gBAAM,SAAS,KAAK,OAAO,IAAI;AAE/B,cAAI,WAAW;AACf,mBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,kBAAM,IAAI,SAAS,MAAM,MAAM;AAC/B,kBAAM,IAAI,SAAS,MAAM,IAAI;AAC7B,gBAAI,KAAK,MAAM,KAAK,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;AACpC,yBAAW;AACX;AAAA,YACF;AAAA,UACF;AAEA,cAAI,UAAU;AACZ,kBAAM,KAAK,uBAAuB;AAClC,kBAAM,WAAW;AAAA,cACf,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,cAC3B,EAAC,GAAG,MAAM,IAAI,GAAG,GAAE;AAAA,cACnB,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,cAC3B,EAAC,GAAG,MAAM,IAAI,IAAG;AAAA,cACjB,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,YAC7B;AAEA,qBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,oBAAM,IAAI,SAAS,MAAM,MAAM;AAC/B,oBAAM,IAAI,SAAS,MAAM,IAAI;AAC7B,mBAAK,CAAC,EAAE,CAAC,IAAI,EAAC,GAAG,SAAS,CAAC,GAAG,IAAI,MAAK;AAAA,YACzC;AAEA,sBAAU,KAAK;AAAA,cACb;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAED,qBAAS;AAAA,UACX;AAAA,QACF;AAGA,YAAI,CAAC,QAAQ;AACX,kBAAQ,IAAI,uCAAuC,KAAK,6BAA6B;AAErF,mBAAS,kBAAkB,GAAG,kBAAkB,MAAM,CAAC,QAAQ,mBAAmB;AAChF,kBAAM,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI;AAC7C,kBAAM,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,EAAE,IAAI;AAC7C,kBAAM,SAAS,KAAK,OAAO,IAAI;AAG/B,gBAAI,WAAW;AACf,qBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,oBAAM,SAAS,SAAS,MAAM,MAAM;AACpC,oBAAM,SAAS,SAAS,MAAM,IAAI;AAElC,kBAAI,UAAU,MAAM,UAAU,MAAM,KAAK,MAAM,EAAE,MAAM,GAAG;AACxD,2BAAW;AACX;AAAA,cACF;AAAA,YACF;AAEA,gBAAI,UAAU;AACZ,oBAAM,KAAK,uBAAuB;AAClC,oBAAM,WAAW;AAAA,gBACf,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,gBAC3B,EAAC,GAAG,MAAM,IAAI,GAAG,GAAE;AAAA,gBACnB,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,gBAC3B,EAAC,GAAG,MAAM,IAAI,IAAG;AAAA,gBACjB,EAAC,GAAG,OAAO,IAAI,OAAO,GAAG,CAAC,EAAC;AAAA,cAC7B;AAGA,uBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,sBAAM,IAAI,SAAS,MAAM,MAAM;AAC/B,sBAAM,IAAI,SAAS,MAAM,IAAI;AAC7B,qBAAK,CAAC,EAAE,CAAC,IAAI,EAAC,GAAG,SAAS,CAAC,GAAG,IAAI,MAAK;AAAA,cACzC;AAEA,wBAAU,KAAK;AAAA,gBACb;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,cACF,CAAC;AAED,uBAAS;AACT,sBAAQ,IAAI,8CAA8C,KAAK,EAAE;AAAA,YACnE;AAAA,UACF;AAEA,cAAI,CAAC,QAAQ;AACX,oBAAQ,IAAI,4BAA4B,KAAK,qBAAqB;AAAA,UACpE;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAAC,QAAQ;AACX,gBAAQ,IAAI,4BAA4B,KAAK,UAAU,WAAW,WAAW;AAAA,MAC/E;AAAA,IACF;AAGA,YAAQ,IAAI,yCAAyC;AACrD,QAAI,mBAAmB;AACvB,eAAW,MAAM,WAAW;AAC1B,YAAM,YAAY,CAAC;AACnB,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,cAAM,IAAI,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AACxC,cAAM,IAAI,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACtC,YAAI,IAAI,MAAM,IAAI,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;AAClC,oBAAU,KAAK,SAAS,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;AAAA,QACxC,OAAO;AACL,kBAAQ,MAAM,0BAA0B,CAAC,IAAI,CAAC,gBAAgB;AAC9D;AAAA,QACF;AAAA,MACF;AAEA,UAAI,UAAU,WAAW,GAAG;AAC1B,cAAM,CAAC,GAAG,GAAG,CAAC,IAAI;AAClB,cAAM,KAAK,GAAG,SAAS,KAAK,GAAG,GAAG,EAAE,GAAG,MAAM,CAAC,EAAE,KAAK,KAAK,GAAG,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE;AAE9E,YAAI,UAAU;AACd,gBAAQ,IAAI;AAAA,UACV,KAAK;AAAK,sBAAW,IAAI,MAAM;AAAI;AAAA,UACnC,KAAK;AAAK,sBAAW,IAAI,MAAM;AAAI;AAAA,UACnC,KAAK;AAAK,sBAAW,IAAI,MAAM;AAAI;AAAA,UACnC,KAAK;AAAK,sBAAW,MAAM,KAAK,IAAI,MAAM;AAAI;AAAA,QAChD;AAEA,YAAI,CAAC,SAAS;AACZ,kBAAQ,MAAM,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE;AAChE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,mBAAmB,GAAG;AACxB,cAAQ,KAAK,SAAS,gBAAgB,2CAA2C;AAAA,IACnF,OAAO;AACL,cAAQ,IAAI,sCAAsC;AAAA,IACpD;AAEA,WAAO,EAAC,MAAM,UAAS;AAAA,EACzB;AA4HA,WAAS,wBAAwB,YAAY,cAAc;AACzD,YAAQ,IAAI,wCAAwC,UAAU,KAAK,YAAY,EAAE;AAGjF,UAAM,qBAAqB;AAAA,MACzB,QAAQ,EAAE,KAAK,MAAM,KAAK,KAAM,MAAM,SAAS;AAAA;AAAA,MAC/C,MAAQ,EAAE,KAAK,MAAM,KAAK,KAAM,MAAM,OAAO;AAAA;AAAA,MAC7C,QAAQ,EAAE,KAAK,MAAM,KAAK,MAAM,MAAM,SAAS;AAAA;AAAA,MAC/C,MAAQ,EAAE,KAAK,MAAM,KAAK,MAAM,MAAM,OAAO;AAAA;AAAA,IAC/C;AAEA,UAAM,UAAU,mBAAmB,UAAU,KAAK,mBAAmB;AACrE,YAAQ,IAAI,kBAAkB,OAAO;AAErC,UAAM,SAAS;AAAA,MACb,WAAW,KAAK,KAAK,eAAe,QAAQ,GAAG;AAAA,MAC/C,WAAW,KAAK,KAAK,eAAe,QAAQ,GAAG;AAAA,MAC/C,MAAM,QAAQ;AAAA,MACd,YAAY;AAAA,QACV,KAAK,KAAK,MAAM,QAAQ,MAAM,GAAG;AAAA,QACjC,KAAK,KAAK,MAAM,QAAQ,MAAM,GAAG;AAAA,MACnC;AAAA,IACF;AAEA,YAAQ,IAAI,cAAc,MAAM;AAChC,WAAO;AAAA,EACT;AAEA,WAAS,eAAe,MAAM,WAAW,gBAAgB;AAEvD,UAAM,YAAY,MAAM,KAAK,EAAC,QAAQ,GAAE,GAAG,MAAM,MAAM,EAAE,EAAE,KAAK,IAAI,CAAC;AAGrE,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAI,KAAK,CAAC,EAAE,CAAC,KAAK,eAAe,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG;AACjD,oBAAU,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;AAAA,QAC7B,WAAW,KAAK,CAAC,EAAE,CAAC,GAAG;AACrB,oBAAU,CAAC,EAAE,CAAC,IAAI,EAAC,GAAG,KAAK,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,QAAQ,OAAO,KAAK,CAAC,EAAE,CAAC,EAAE,IAAI,IAAI,KAAK,CAAC,EAAE,CAAC,EAAE,GAAE;AAAA,QAC1G;AAAA,MACF;AAAA,IACF;AAGA,QAAI,gBAAgB;AACpB,QAAI,mBAAmB;AACvB,UAAM,sBAAsB;AAE5B,WAAO,iBAAiB,mBAAmB,qBAAqB;AAC9D,sBAAgB;AAChB;AAGA,UAAI,UAAU;AACd,UAAI,aAAa;AACjB,YAAM,gBAAgB;AAEtB,aAAO,WAAW,aAAa,eAAe;AAC5C,kBAAU;AACV;AAEA,mBAAW,MAAM,WAAW;AAC1B,gBAAM,QAAQ,CAAC;AACf,mBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,kBAAM,IAAI,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AACxC,kBAAM,IAAI,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACtC,gBAAI,IAAI,MAAM,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG;AACvC,oBAAM,KAAK,EAAC,GAAG,GAAG,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG,KAAK,EAAC,CAAC;AAAA,YAClD;AAAA,UACF;AAEA,cAAI,MAAM,WAAW,GAAG;AACtB,kBAAM,WAAW,MAAM,OAAO,UAAQ,KAAK,KAAK,MAAM,KAAK;AAC3D,kBAAM,SAAS,MAAM,KAAK,UAAQ,KAAK,KAAK,MAAM,IAAI;AAEtD,gBAAI,UAAU,SAAS,UAAU,GAAG;AAClC,oBAAM,cAAc,CAAC;AACrB,oBAAM,mBAAmB,CAAC;AAE1B,yBAAW,WAAW,UAAU;AAC9B,oBAAI,QAAQ,KAAK,OAAO,MAAM;AAC5B,8BAAY,QAAQ,GAAG,IAAI,SAAS,QAAQ,KAAK,EAAE;AAAA,gBACrD,OAAO;AACL,mCAAiB,KAAK,QAAQ,GAAG;AAAA,gBACnC;AAAA,cACF;AAGA,kBAAI,OAAO,KAAK,WAAW,EAAE,WAAW,KAAK,iBAAiB,WAAW,GAAG;AAC1E,sBAAM,KAAK,OAAO,KAAK;AACvB,sBAAM,aAAa,iBAAiB,CAAC;AACrC,oBAAI,eAAe;AAEnB,oBAAI,eAAe,GAAG;AACpB,wBAAM,IAAI,YAAY,CAAC;AACvB,wBAAM,IAAI,YAAY,CAAC;AACvB,sBAAI,OAAO,IAAK,gBAAe,IAAI;AAAA,2BAC1B,OAAO,IAAK,gBAAe,IAAI;AAAA,2BAC/B,OAAO,OAAK,gBAAe,MAAM,IAAI,IAAI,IAAI;AAAA,2BAC7C,OAAO,OAAK,gBAAe,IAAI;AAAA,gBAC1C,WAAW,eAAe,GAAG;AAC3B,wBAAM,IAAI,YAAY,CAAC;AACvB,wBAAM,IAAI,YAAY,CAAC;AACvB,sBAAI,OAAO,IAAK,gBAAe,IAAI;AAAA,2BAC1B,OAAO,IAAK,gBAAe,IAAI;AAAA,2BAC/B,OAAO,OAAK,gBAAe,MAAM,IAAI,IAAI,IAAI;AAAA,2BAC7C,OAAO,OAAK,gBAAe,MAAM,IAAI,IAAI,IAAI;AAAA,gBACxD,WAAW,eAAe,GAAG;AAC3B,wBAAM,IAAI,YAAY,CAAC;AACvB,wBAAM,IAAI,YAAY,CAAC;AACvB,sBAAI,OAAO,IAAK,gBAAe,IAAI;AAAA,2BAC1B,OAAO,IAAK,gBAAe,IAAI;AAAA,2BAC/B,OAAO,OAAK,gBAAe,IAAI;AAAA,2BAC/B,OAAO,OAAK,gBAAe,MAAM,IAAI,IAAI,IAAI;AAAA,gBACxD;AAEA,oBAAI,iBAAiB,QAAQ,eAAe,KAAK,gBAAgB,MAAM,OAAO,UAAU,YAAY,GAAG;AACrG,wBAAM,aAAa,MAAM,KAAK,UAAQ,KAAK,QAAQ,UAAU;AAC7D,sBAAI,cAAc,WAAW,KAAK,OAAO,MAAM;AAC7C,+BAAW,KAAK,KAAK,OAAO,YAAY;AACxC,8BAAU;AACV,oCAAgB;AAAA,kBAClB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGA,iBAAW,MAAM,WAAW;AAC1B,cAAM,QAAQ,CAAC;AACf,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,gBAAM,IAAI,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AACxC,gBAAM,IAAI,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACtC,cAAI,IAAI,MAAM,IAAI,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG;AACvC,kBAAM,KAAK,EAAC,GAAG,GAAG,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG,KAAK,EAAC,CAAC;AAAA,UAClD;AAAA,QACF;AAEA,YAAI,MAAM,WAAW,GAAG;AACtB,gBAAM,WAAW,MAAM,OAAO,UAAQ,KAAK,KAAK,MAAM,KAAK;AAC3D,gBAAM,SAAS,MAAM,KAAK,UAAQ,KAAK,KAAK,MAAM,IAAI;AAEtD,cAAI,UAAU,SAAS,UAAU,GAAG;AAClC,kBAAM,cAAc,CAAC;AACrB,kBAAM,mBAAmB,CAAC;AAE1B,uBAAW,WAAW,UAAU;AAC9B,kBAAI,QAAQ,KAAK,OAAO,MAAM;AAC5B,4BAAY,QAAQ,GAAG,IAAI,SAAS,QAAQ,KAAK,EAAE;AAAA,cACrD,OAAO;AACL,iCAAiB,KAAK,QAAQ,GAAG;AAAA,cACnC;AAAA,YACF;AAGA,gBAAI,OAAO,KAAK,WAAW,EAAE,WAAW,KAAK,iBAAiB,WAAW,GAAG;AAE1E,yBAAW,cAAc,kBAAkB;AACzC,sBAAM,OAAO,MAAM,KAAK,OAAK,EAAE,QAAQ,UAAU;AACjD,sBAAM,iBAAiB,mCAAmC,WAAW,WAAW,KAAK,GAAG,KAAK,CAAC;AAE9F,oBAAI,kBAAkB,eAAe,WAAW,GAAG;AAEjD,uBAAK,KAAK,KAAK,OAAO,eAAe,CAAC,CAAC;AACvC,kCAAgB;AAChB;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAI,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,OAAO;AACxC,cAAI,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,UAAU,CAAC,EAAE,CAAC,EAAE,OAAO,MAAM;AACnD,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,mCAAmC,WAAW,WAAW,SAAS,SAAS;AAElF,UAAM,iBAAiB,CAAC;AACxB,UAAM,QAAQ,eAAe;AAE7B,aAAS,YAAY,MAAM,KAAK,aAAa,MAAM,KAAK,aAAa;AACnE,UAAI,UAAU;AAGd,iBAAW,MAAM,WAAW;AAC1B,YAAI,mBAAmB;AACvB,YAAI,qBAAqB;AAGzB,iBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,gBAAM,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AAC1C,gBAAM,MAAM,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACxC,cAAI,QAAQ,WAAW,QAAQ,SAAS;AACtC,+BAAmB;AACnB,iCAAqB;AACrB;AAAA,UACF;AAAA,QACF;AAEA,YAAI,kBAAkB;AAEpB,gBAAM,UAAU,CAAC;AACjB,mBAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,kBAAM,MAAM,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AAC1C,kBAAM,MAAM,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACxC,gBAAI,MAAM,MAAM,MAAM,MAAM,UAAU,GAAG,EAAE,GAAG,GAAG;AAC/C,sBAAQ,KAAK,EAAC,GAAG,KAAK,GAAG,KAAK,MAAM,UAAU,GAAG,EAAE,GAAG,GAAG,KAAK,EAAC,CAAC;AAAA,YAClE;AAAA,UACF;AAEA,cAAI,QAAQ,WAAW,GAAG;AACxB,kBAAM,WAAW,QAAQ,OAAO,UAAQ,KAAK,KAAK,MAAM,KAAK;AAC7D,kBAAM,SAAS,QAAQ,KAAK,UAAQ,KAAK,KAAK,MAAM,IAAI;AAExD,gBAAI,UAAU,SAAS,WAAW,GAAG;AAEnC,oBAAM,SAAS,CAAC;AAChB,kBAAI,cAAc;AAElB,yBAAW,WAAW,UAAU;AAC9B,oBAAI,QAAQ,MAAM,WAAW,QAAQ,MAAM,SAAS;AAClD,yBAAO,QAAQ,GAAG,IAAI;AAAA,gBACxB,WAAW,QAAQ,KAAK,OAAO,MAAM;AACnC,yBAAO,QAAQ,GAAG,IAAI,SAAS,QAAQ,KAAK,EAAE;AAAA,gBAChD,OAAO;AACL,gCAAc;AAAA,gBAChB;AAAA,cACF;AAGA,kBAAI,OAAO,KAAK,MAAM,EAAE,UAAU,KAAK,CAAC,aAAa;AACnD,sBAAM,IAAI,OAAO,CAAC;AAClB,sBAAM,IAAI,OAAO,CAAC;AAClB,sBAAM,IAAI,OAAO,CAAC;AAClB,sBAAM,KAAK,OAAO,KAAK;AAEvB,oBAAI,MAAM,UAAa,MAAM,UAAa,MAAM,QAAW;AACzD,sBAAI,CAAC,OAAO,GAAG,IAAI,GAAG,CAAC,GAAG;AACxB,8BAAU;AACV;AAAA,kBACF;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,UAAI,SAAS;AACX,uBAAe,KAAK,SAAS;AAAA,MAC/B;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,6BAA6B,MAAM,WAAW,gBAAgB;AAGrE,eAAW,MAAM,WAAW;AAC1B,YAAM,cAAc,CAAC;AACrB,eAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,cAAM,IAAI,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM;AACxC,cAAM,IAAI,GAAG,SAAS,GAAG,MAAM,IAAI,GAAG;AACtC,YAAI,IAAI,MAAM,IAAI,IAAI;AACpB,sBAAY,KAAK,EAAC,GAAG,GAAG,KAAK,EAAC,CAAC;AAAA,QACjC;AAAA,MACF;AAEA,YAAM,aAAa,YAAY,OAAO,SAAO,eAAe,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE;AAGtF,UAAI,eAAe,GAAG;AACpB,gBAAQ,IAAI,gDAAgD;AAC5D,eAAO;AAAA,MACT;AAIA,UAAI,YAAY,UAAU,KAAK,eAAe,GAAG;AAC/C,YAAI,qBAAqB;AAEzB,mBAAW,OAAO,aAAa;AAC7B,cAAI,CAAC,eAAe,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG;AAE5C,uBAAW,WAAW,WAAW;AAC/B,kBAAI,YAAY,GAAI;AAEpB,uBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC7B,sBAAM,SAAS,QAAQ,SAAS,QAAQ,MAAM,QAAQ,MAAM;AAC5D,sBAAM,SAAS,QAAQ,SAAS,QAAQ,MAAM,IAAI,QAAQ;AAE1D,oBAAI,WAAW,IAAI,KAAK,WAAW,IAAI,GAAG;AACxC;AACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAIA,YAAI,uBAAuB,GAAG;AAC5B,kBAAQ,IAAI,+DAA+D;AAC3E,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,WAAS,qBAAqB,YAAY,cAAc;AAEtD,UAAM,qBAAqB;AAAA,MACzB,QAAQ,EAAE,KAAK,MAAM,KAAK,KAAM,MAAM,SAAS;AAAA;AAAA,MAC/C,MAAQ,EAAE,KAAK,MAAM,KAAK,KAAM,MAAM,OAAO;AAAA;AAAA,MAC7C,QAAQ,EAAE,KAAK,MAAM,KAAK,MAAM,MAAM,SAAS;AAAA;AAAA,MAC/C,MAAQ,EAAE,KAAK,MAAM,KAAK,MAAM,MAAM,OAAO;AAAA;AAAA,IAC/C;AAEA,UAAM,UAAU,mBAAmB,UAAU,KAAK,mBAAmB;AACrE,WAAO;AAAA,MACL,WAAW,KAAK,KAAK,eAAe,QAAQ,GAAG;AAAA,MAC/C,WAAW,KAAK,KAAK,eAAe,QAAQ,GAAG;AAAA,MAC/C,MAAM,QAAQ;AAAA,IAChB;AAAA,EACF;AAucA,WAAS,uBAAuB,OAAO,YAAY;AACjD,UAAM,EAAC,MAAM,WAAW,gBAAe,IAAI;AAG3C,UAAM,WAAW,mBAAmB,oBAAI,IAAI;AAG5C,UAAM,YAAY,CAAC;AACnB,aAAQ,IAAI,GAAG,IAAI,IAAI,KAAK;AAC1B,eAAQ,IAAI,GAAG,IAAI,IAAI,KAAK;AAC1B,YAAG,KAAK,CAAC,EAAE,CAAC,GAAG;AACb,oBAAU,KAAK,EAAC,GAAG,EAAC,CAAC;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,OAAO,KAAK,IAAI,GAAG,UAAU,IAAI,OAAK,EAAE,CAAC,CAAC;AAChD,UAAM,OAAO,KAAK,IAAI,GAAG,UAAU,IAAI,OAAK,EAAE,CAAC,CAAC;AAChD,UAAM,OAAO,KAAK,IAAI,GAAG,UAAU,IAAI,OAAK,EAAE,CAAC,CAAC;AAChD,UAAM,OAAO,KAAK,IAAI,GAAG,UAAU,IAAI,OAAK,EAAE,CAAC,CAAC;AAEhD,UAAM,WAAW,OAAO,OAAO;AAC/B,UAAM,WAAW,OAAO,OAAO;AAG/B,UAAMC,YAAW,KAAK,IAAI,IAAI,KAAK,MAAM,MAAM,KAAK,IAAI,UAAU,QAAQ,CAAC,CAAC;AAC5E,UAAM,IAAI,WAAWA;AACrB,UAAM,IAAI,WAAWA;AAErB,QAAI,aAAa,WAAW,OAAO,CAAC,IAAI,CAAC,EAAE;AAC3C,QAAI,aAAa,SAAS,CAAC;AAC3B,QAAI,aAAa,UAAU,CAAC;AAC5B,QAAI,YAAY;AAGhB,aAAQ,IAAI,MAAM,KAAK,MAAM,KAAK;AAChC,eAAQ,IAAI,MAAM,KAAK,MAAM,KAAK;AAChC,cAAM,KAAK,IAAI,QAAQA;AACvB,cAAM,KAAK,IAAI,QAAQA;AACvB,cAAM,OAAO,KAAK,CAAC,EAAE,CAAC;AAEtB,YAAG,MAAM;AAEP,cAAI,YAAY,EAAE,QAAQ;AAAA,YACxB;AAAA,YAAG;AAAA,YAAG,OAAOA;AAAA,YAAU,QAAQA;AAAA,YAC/B,MAAM;AAAA,YAAQ,QAAQ;AAAA,YAAQ,gBAAgB;AAAA,UAChD,CAAC,CAAC;AAGF,cAAI,OAAO,KAAK;AAChB,cAAG,KAAK,MAAM,SAAS,CAAC,IAAI,SAAS;AACnC,mBAAO,SAAS,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,KAAK,KAAK;AAAA,UAC/C;AAEA,gBAAM,WAAW,KAAK,IAAI,IAAI,KAAK,UAAU,IAAIA,YAAW,MAAMA,YAAW,GAAG;AAChF,gBAAM,SAAS,EAAE,QAAQ;AAAA,YACvB,GAAG,IAAIA,YAAS;AAAA,YAChB,GAAG,IAAIA,YAAS,IAAI,WAAS;AAAA,YAC7B,eAAe;AAAA,YACf,qBAAqB;AAAA,YACrB,aAAa;AAAA,YACb,eAAe;AAAA,YACf,eAAe;AAAA,UACjB,CAAC;AACD,iBAAO,cAAc;AACrB,cAAI,YAAY,MAAM;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,YAAY,EAAE,QAAQ;AAAA,MACxB,GAAG;AAAA,MAAG,GAAG;AAAA,MAAG,OAAO;AAAA,MAAG,QAAQ;AAAA,MAC9B,MAAM;AAAA,MAAQ,QAAQ;AAAA,MAAQ,gBAAgB;AAAA,IAChD,CAAC,CAAC;AAGF,aAAS,eAAe,MAAM,EAAE,MAAM,UAAU;AAGhD,0BAAsB,MAAM,UAAU,MAAM,MAAM,MAAM,IAAI;AAC5D,yBAAqB,MAAM,UAAU,MAAM,MAAM,MAAM,IAAI;AAG3D,UAAM,WAAW,CAAC;AAClB,aAAQ,IAAI,GAAG,IAAI,IAAI,KAAK;AAC1B,eAAQ,IAAI,GAAG,IAAI,IAAI,KAAK;AAC1B,YAAG,KAAK,CAAC,EAAE,CAAC,KAAK,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,OAAO;AACvC,mBAAS,KAAK,EAAC,GAAG,EAAC,CAAC;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,oBAAoB,qBAAqB,YAAY,SAAS,MAAM;AAC1E,WAAO,EAAC,UAAU,SAAS,QAAQ,cAAc,SAAS,MAAM,YAAY,kBAAiB;AAAA,EAC/F;AA6MA,WAAS,sBAAsB,MAAM,UAAU,MAAM,MAAM,MAAM,MAAM;AACrE,UAAM,aAAa,SAAS,eAAe,YAAY;AACvD,UAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,cAAU,YAAY;AAGtB,UAAMC,YAAW;AACjB,UAAM,aAAa,OAAO,OAAO,KAAKA;AACtC,UAAM,cAAc,OAAO,OAAO,KAAKA;AACvC,cAAU,MAAM,QAAQ,YAAY;AACpC,cAAU,MAAM,SAAS,aAAa;AAEtC,QAAI,cAAc;AAGlB,aAAS,IAAI,MAAM,KAAK,MAAM,KAAK;AACjC,eAAS,IAAI,MAAM,KAAK,MAAM,KAAK;AACjC,cAAM,WAAW,KAAK,CAAC,EAAE,CAAC;AAE1B,YAAI,UAAU;AACZ,gBAAM,OAAO,SAAS,cAAc,KAAK;AACzC,eAAK,YAAY;AAGjB,gBAAM,KAAK,IAAI,QAAQA;AACvB,gBAAM,KAAK,IAAI,QAAQA;AACvB,eAAK,MAAM,OAAO,IAAI;AACtB,eAAK,MAAM,MAAM,IAAI;AACrB,eAAK,MAAM,QAAQA,YAAW;AAC9B,eAAK,MAAM,SAASA,YAAW;AAC/B,eAAK,MAAM,WAAW,KAAK,MAAMA,YAAW,GAAG,IAAI;AAInD,gBAAM,mBAAmB,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE,IAAI,CAAC;AACjD,cAAI,CAAC,iBAAkB,MAAK,UAAU,IAAI,cAAc;AAGxD,gBAAM,oBAAoB,KAAK,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,EAAE,CAAC;AACtD,cAAI,CAAC,kBAAmB,MAAK,UAAU,IAAI,eAAe;AAG1D,cAAI,OAAO,SAAS;AACpB,cAAI,UAAU;AAEd,cAAI,SAAS,MAAM,SAAS,CAAC,IAAI,SAAS;AACxC,sBAAU,SAAS,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE;AAClC,mBAAO,UAAU,SAAS,KAAK;AAAA,UACjC;AAEA,eAAK,cAAc;AAGnB,cAAI,SAAS,MAAM,MAAM;AACvB,oBAAQ,SAAS,IAAI;AAAA,cACnB,KAAK;AAAK,qBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,cACxC,KAAK;AAAK,qBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,cACxC,KAAK;AAAK,qBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,cACxC,KAAK;AAAK,qBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,YAC1C;AAAA,UACF,WAAW,SAAS,MAAM,MAAM;AAC9B,iBAAK,UAAU,IAAI,OAAO;AAAA,UAC5B,WAAW,SAAS,MAAM,OAAO;AAC/B,gBAAI,WAAW,CAAC,IAAI,SAAS;AAC3B,mBAAK,UAAU,IAAI,OAAO;AAAA,YAC5B,OAAO;AACL,mBAAK,UAAU,IAAI,cAAc,MAAM,IAAI,aAAa,SAAS;AAAA,YACnE;AACA;AAAA,UACF;AAEA,oBAAU,YAAY,IAAI;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAEA,eAAW,YAAY;AACvB,eAAW,YAAY,SAAS;AAAA,EAClC;AAEA,WAAS,qBAAqB,MAAM,UAAU,MAAM,MAAM,MAAM,MAAM;AACpE,UAAM,YAAY,SAAS,eAAe,WAAW;AACrD,UAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,cAAU,YAAY;AAGtB,UAAM,WAAW,OAAO,OAAO;AAC/B,UAAM,WAAW,OAAO,OAAO;AAG/B,UAAM,kBAAkB;AACxB,UAAM,mBAAmB;AACzB,UAAM,mBAAmB;AACzB,UAAM,oBAAoB;AAC1B,UAAM,SAAS;AAGf,UAAM,0BAA0B,KAAK,MAAO,kBAAkB,SAAU,QAAQ;AAChF,UAAM,2BAA2B,KAAK,MAAO,mBAAmB,SAAU,QAAQ;AAClF,UAAM,mBAAmB,KAAK,IAAI,yBAAyB,wBAAwB;AAEnF,UAAM,2BAA2B,KAAK,MAAO,mBAAmB,SAAU,QAAQ;AAClF,UAAM,4BAA4B,KAAK,MAAO,oBAAoB,SAAU,QAAQ;AACpF,UAAM,oBAAoB,KAAK,IAAI,0BAA0B,yBAAyB;AAItF,UAAM,gBAAgB,KAAK,IAAI,KAAK,MAAM,mBAAmB,GAAG,GAAG,KAAK,MAAM,oBAAoB,GAAG,GAAG,EAAE;AAC1G,UAAM,cAAc,oBAAoB;AAGxC,WAAO,mBAAmB,cAAc,aAAa;AACrD,WAAO,gBAAgB;AAEvB,UAAM,aAAa,OAAO,OAAO,KAAK;AACtC,UAAM,cAAc,OAAO,OAAO,KAAK;AACvC,cAAU,MAAM,QAAQ,YAAY;AACpC,cAAU,MAAM,SAAS,aAAa;AAGtC,aAAS,IAAI,MAAM,KAAK,MAAM,KAAK;AACjC,eAAS,IAAI,MAAM,KAAK,MAAM,KAAK;AACjC,cAAM,WAAW,KAAK,CAAC,EAAE,CAAC;AAE1B,YAAI,UAAU;AAEZ,gBAAM,OAAO,SAAS,cAAc,KAAK;AACzC,eAAK,YAAY;AAGjB,gBAAMC,iBAAgB,OAAO,iBAAiB;AAC9C,gBAAM,KAAK,IAAI,QAAQA;AACvB,gBAAM,KAAK,IAAI,QAAQA;AACvB,eAAK,MAAM,OAAO,IAAI;AACtB,eAAK,MAAM,MAAM,IAAI;AACrB,eAAK,MAAM,QAAQA,iBAAgB;AACnC,eAAK,MAAM,SAASA,iBAAgB;AACpC,eAAK,MAAM,WAAW,KAAK,IAAI,IAAI,KAAK,MAAMA,iBAAgB,GAAG,CAAC,IAAI;AAItE,gBAAM,mBAAmB,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE,IAAI,CAAC;AACjD,cAAI,CAAC,iBAAkB,MAAK,UAAU,IAAI,cAAc;AAGxD,gBAAM,oBAAoB,KAAK,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,EAAE,CAAC;AACtD,cAAI,CAAC,kBAAmB,MAAK,UAAU,IAAI,eAAe;AAG1D,cAAI,OAAO,SAAS;AACpB,cAAI,SAAS,MAAM,SAAS,CAAC,IAAI,SAAS;AACxC,mBAAO,SAAS,IAAI,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,SAAS,KAAK;AAAA,UACnD;AACA,eAAK,cAAc;AAEnB,oBAAU,YAAY,IAAI;AAAA,QAC5B;AAAA,MACF;AAAA,IACF;AAEA,cAAU,YAAY;AACtB,cAAU,YAAY,SAAS;AAAA,EACjC;AAEA,WAAS,eAAe;AACtB,cAAU,SAAS,SAAS,KAAK;AACjC,cAAU,WAAW,iBAAiB,KAAK;AAC3C,cAAU,YAAY,YAAY,KAAK;AAEvC,cAAU,UAAU,KAAK,UAAU;AAAA,MACjC,KAAK,MAAM;AAAA,MACX,KAAK,MAAM;AAAA,MACX,KAAK,MAAM;AAAA,MACX,KAAK,MAAM;AAAA,IACb,CAAC,CAAC;AAAA,EACJ;AAEA,WAAS,WAAW,aAAW,OAAM;AAEnC,UAAM,qBAAqB,iBAAiB,SAAS;AACrD,SAAK,cAAY,wBAAiB,kBAAkB;AACpD,SAAK,MAAM,aAAa;AACxB,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,SAAS;AAGpB,eAAW,YAAY;AACrB,YAAM,eAAe,SAAS,SAAS,KAAK,KAAK;AACjD,YAAM,aAAa,iBAAiB,SAAS;AAG7C,YAAM,cAAc,sBAAsB;AAC1C,UAAI,YAAY,WAAW,GAAG;AAC5B,aAAK,cAAc;AACnB,aAAK,MAAM,aAAa;AACxB,aAAK,MAAM,QAAQ;AACnB,aAAK,MAAM,SAAS;AACpB;AAAA,MACF;AAEA,mBAAa;AAGb,YAAM,eAAe;AAAA,QACnB,QAAQ,EAAE,KAAK,GAAG,KAAK,GAAG;AAAA;AAAA,QAC1B,MAAQ,EAAE,KAAK,IAAI,KAAK,GAAG;AAAA;AAAA,QAC3B,QAAQ,EAAE,KAAK,IAAI,KAAK,GAAG;AAAA;AAAA,QAC3B,MAAQ,EAAE,KAAK,IAAI,KAAK,GAAG;AAAA;AAAA,MAC7B;AAEA,YAAM,cAAc,aAAa,UAAU,KAAK,aAAa;AAC7D,UAAI,UAAU;AACd,UAAI,aAAa;AACjB,UAAI,YAAY;AAChB,UAAI,kBAAkB;AAGtB,YAAM,mBAAmB,MAAM;AAE7B,YAAI,CAAC,SAAS,eAAe,eAAe,GAAG;AAC7C,gBAAM,QAAQ,SAAS,cAAc,OAAO;AAC5C,gBAAM,KAAK;AACX,gBAAM,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BpB,mBAAS,KAAK,YAAY,KAAK;AAAA,QACjC;AAGA,cAAM,mBAAmB,SAAS,cAAc,KAAK;AACrD,yBAAiB,YAAY;AAC7B,yBAAiB,KAAK;AAEtB,cAAM,UAAU,SAAS,cAAc,KAAK;AAC5C,gBAAQ,YAAY;AAEpB,cAAM,cAAc,SAAS,cAAc,KAAK;AAChD,oBAAY,YAAY;AACxB,oBAAY,KAAK;AACjB,oBAAY,cAAc;AAE1B,yBAAiB,YAAY,OAAO;AACpC,yBAAiB,YAAY,WAAW;AAGxC,cAAMC,cAAa,SAAS,eAAe,YAAY;AACvD,YAAIA,eAAcA,YAAW,YAAY;AACvC,UAAAA,YAAW,WAAW,aAAa,kBAAkBA,WAAU;AAAA,QACjE;AAAA,MACF;AAEA,YAAM,sBAAsB,MAAM;AAChC,cAAM,mBAAmB,SAAS,eAAe,wBAAwB;AACzE,YAAI,iBAAkB,kBAAiB,OAAO;AAAA,MAChD;AAGA,YAAMC,OAAM,SAAS,eAAe,MAAM;AAC1C,YAAM,aAAa,SAAS,eAAe,YAAY;AACvD,YAAM,YAAY,SAAS,eAAe,WAAW;AACrD,YAAMC,OAAM,SAAS,eAAe,KAAK;AAEzC,UAAID,KAAK,CAAAA,KAAI,MAAM,UAAU;AAC7B,UAAI,WAAY,YAAW,MAAM,UAAU;AAC3C,UAAI,UAAW,WAAU,MAAM,UAAU;AACzC,UAAIC,KAAK,CAAAA,KAAI,MAAM,UAAU;AAG7B,uBAAiB;AAGjB,aAAO,UAAU,IAAI;AACnB;AAGA,cAAM,cAAc,SAAS,eAAe,aAAa;AACzD,YAAI,aAAa;AACf,sBAAY,cAAc,cAAc,UAAU,uBAAuB,OAAO;AAAA,QAClF;AAEA,aAAK,cAAc,uBAAgB,YAAY,GAAG,IAAI,YAAY,GAAG,yBAAyB,OAAO;AAGrG,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,EAAE,CAAC;AAEpD,YAAI;AAEF,gBAAM,QAAQ,0BAA0B,cAAc,UAAU;AAChE,cAAI,CAAC,OAAO;AACV,oBAAQ,IAAI,WAAW,OAAO,2BAA2B;AACzD;AAAA,UACF;AAEA,gBAAM,OAAO,uBAAuB,OAAO,UAAU;AACrD,gBAAM,aAAa,KAAK,MAAO,KAAK,eAAe,KAAK,WAAY,GAAG;AAGvE,cAAI,cAAc,YAAY,OAAO,cAAc,YAAY,KAAK;AAClE,yBAAa;AACb,wBAAY;AACZ,8BAAkB;AAClB;AAAA,UACF,OAAO;AACL,oBAAQ,IAAI,WAAW,OAAO,KAAK,UAAU,qBAAqB,YAAY,GAAG,IAAI,YAAY,GAAG,iBAAiB;AAErH,gBAAI,CAAC,cAAc,KAAK,IAAI,cAAc,YAAY,MAAM,YAAY,OAAO,CAAC,IAAI,KAAK,IAAI,mBAAmB,YAAY,MAAM,YAAY,OAAO,CAAC,GAAG;AACvJ,2BAAa;AACb,0BAAY;AACZ,gCAAkB;AAAA,YACpB;AAAA,UACF;AAAA,QAEF,SAAS,GAAG;AACV,kBAAQ,IAAI,WAAW,OAAO,YAAY,CAAC;AAC3C;AAAA,QACF;AAAA,MACF;AAGA,0BAAoB;AAGpB,UAAI,WAAY,YAAW,MAAM,UAAU;AAC3C,UAAIA,KAAK,CAAAA,KAAI,MAAM,UAAU;AAE7B,UAAI,UAAW,WAAU,MAAM,UAAU;AAGzC,UAAI,cAAc,WAAW;AAC3B,cAAM,QAAQ,eAAe;AAG7B,aAAK,MAAM,aAAa;AACxB,aAAK,MAAM,QAAQ;AACnB,aAAK,MAAM,SAAS;AACpB,aAAK,cAAY,oBAAe,UAAU,WAAW,IAAI,YAAY,MAAM,GAAG,IAAI,MAAM,GAAG,UAAU,WAAW,UAAU,MAAM,uBAAuB,UAAU,YAAY,IAAI,UAAU,QAAQ,aAAa,eAAe,eAAe,OAAO;AAErP,YAAG,WAAY,YAAW,MAAM,OAAO,MAAM,GAAG,GAAG;AAAA,MACrD,OAAO;AAEL,aAAK,cAAc;AACnB,aAAK,MAAM,aAAa;AACxB,aAAK,MAAM,QAAQ;AACnB,aAAK,MAAM,SAAS;AACpB;AAAA,MACF;AAAA,IACF,GAAG,EAAE;AAAA,EACP;AAeA,WAAS,oBAAoB;AAE3B,UAAM,cAAc,OAAO,KAAK,IAAI,UAAU,sBAAsB;AAGpE,UAAM,mBAAmB,0BAA0B;AAGnD,UAAM,cAAc,OAAO,oBAAoB;AAEjD,aAAS,4BAA4B;AACnC,YAAM,YAAY,SAAS,eAAe,WAAW;AACrD,UAAI,CAAC,aAAa,CAAC,UAAU,WAAY,QAAO;AAGhD,YAAM,YAAY,UAAU,WAAW,UAAU,IAAI;AACrD,YAAM,QAAQ,UAAU,iBAAiB,aAAa;AAEtD,UAAI,cAAc;AAClB,YAAM,QAAQ,UAAQ;AACpB,cAAM,OAAO,KAAK,YAAY,KAAK;AAGnC,YAAI,CAAC,KAAK,KAAK,QAAK,MAAG,EAAE,SAAS,IAAI,GAAG;AACvC,kBAAQ,MAAM;AAAA,YACZ,KAAK;AAAK,mBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,YACxC,KAAK;AAAK,mBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,YACxC,KAAK;AAAK,mBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,YACxC,KAAK;AAAK,mBAAK,UAAU,IAAI,QAAQ;AAAG;AAAA,UAC1C;AAAA,QACF,WAAW,SAAS,KAAK;AACvB,eAAK,UAAU,IAAI,OAAO;AAAA,QAC5B,WAAW,QAAQ,CAAC,MAAM,IAAI,GAAG;AAE/B,cAAI,KAAK,MAAM,YAAY,SAAS,KAAK,MAAM,QAAQ,IAAI,IAAI;AAC7D,iBAAK,UAAU,IAAI,OAAO;AAAA,UAC5B,OAAO;AACL,iBAAK,UAAU,IAAI,cAAc,MAAM,IAAI,aAAa,SAAS;AAAA,UACnE;AACA;AAAA,QACF;AAAA,MACF,CAAC;AAED,aAAO,UAAU;AAAA,IACnB;AAEE,gBAAY,SAAS,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAqFN,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAQ1B,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAUrB;AAED,gBAAY,SAAS,MAAM;AAAA,EAC7B;AAGA,WAAS,eAAe,KAAK,EAAE,iBAAiB,SAAQ,MAAI,WAAW,KAAK,CAAC;AAC7E,WAAS,eAAe,YAAY,EAAE,iBAAiB,SAAQ,MAAI,kBAAkB,CAAC;AACtF,MAAI,iBAAiB,UAAS,MAAI,WAAW,KAAK,CAAC;AACnD,WAAS,iBAAiB,SAAQ,MAAI;AAAC,UAAM,cAAY,SAAS;AAAO,iBAAa;AAAA,EAAE,CAAC;AACzF,mBAAiB,iBAAiB,UAAS,MAAI;AAAC,iBAAa;AAAG,eAAW,KAAK;AAAA,EAAE,CAAC;AACnF,cAAY,iBAAiB,UAAS,MAAI;AAAE,iBAAa;AAAG,eAAW,KAAK;AAAA,EAAG,CAAC;AAChF,QAAM,iBAAiB,UAAS,MAAI;AAAC,iBAAa;AAAG,eAAW,KAAK;AAAA,EAAE,CAAC;AACxE,QAAM,iBAAiB,UAAS,MAAI;AAAC,iBAAa;AAAG,eAAW,KAAK;AAAA,EAAE,CAAC;AACxE,QAAM,iBAAiB,UAAS,MAAI;AAAC,iBAAa;AAAG,eAAW,KAAK;AAAA,EAAE,CAAC;AACxE,QAAM,iBAAiB,UAAS,MAAI;AAAC,iBAAa;AAAG,eAAW,KAAK;AAAA,EAAE,CAAC;AAGxE,kBAAgB;AAChB,aAAW,KAAK;AAGhB,MAAI,OAAO,WAAW,aAAa;AAAA,EAEnC;",
  "names": ["A", "B", "cellSize", "cellSize", "printCellSize", "screenGrid", "svg", "ans"]
}
